{"version":3,"file":"middletier.js","mappings":";;;;;;;;;AAAA,QAAQ,SAAS,EAAE,mBAAO,CAAC,qEAAY;AACvC,aAAa,mBAAO,CAAC,6EAAa;AAClC,kBAAkB,mBAAO,CAAC,uFAAkB;AAC5C,iBAAiB,mBAAO,CAAC,qFAAiB;AAC1C,iBAAiB,mBAAO,CAAC,qFAAiB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA,QAAQ,WAAW,EAAE,mBAAO,CAAC,kBAAM;AACnC,iBAAiB,mBAAO,CAAC,gFAAY;AACrC,iBAAiB,mBAAO,CAAC,gFAAY;;AAErC,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AClDA,QAAQ,WAAW,EAAE,mBAAO,CAAC,kBAAM;;AAEnC,QAAQ,WAAW,EAAE,mBAAO,CAAC,qFAAkB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,kDAAkD,OAAO;AACjG;;AAEA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,KAAK;AACL,IAAI;AACJ,0CAA0C;AAC1C;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,+CAA+C,aAAa;AAC5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd,iBAAiB;;AAEjB,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,0CAA0C,2BAA2B,2CAA2C,gCAAgC,wCAAwC;AACxL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AC3IA,QAAQ,WAAW,EAAE,mBAAO,CAAC,+EAAY;AACzC,QAAQ,+BAA+B,EAAE,mBAAO,CAAC,2EAAU;AAC3D,aAAa,mBAAO,CAAC,uEAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTA,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,sBAAQ;;AAE3C,QAAQ,WAAW,EAAE,mBAAO,CAAC,qFAAkB;AAC/C,QAAQ,+BAA+B,EAAE,mBAAO,CAAC,iFAAgB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ,gCAAgC,UAAU;AACzE;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AA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AAM;;AAEnC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,iBAAiB,qBAAqB;AACtC,KAAK;AACL;;AAEA,gCAAgC;;AAEhC,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,KAAK,MAAM,yBAAyB;AACxD,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;;;;;;;;;;;ACpHhB;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,gBAAgB;;AAE5C;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACtDjB;AACA,OAAO,mBAAO,CAAC,0EAAO;AACtB;;;;;;;;;;;ACFA;AACA,QAAQ,WAAW,EAAE,mBAAO,CAAC,kBAAM;;AAEnC,QAAQ,gBAAgB,EAAE,mBAAO,CAAC,iFAAgB;AAClD,aAAa,mBAAO,CAAC,6EAAc;;AAEnC;AACA,YAAY,mBAAO,CAAC,qFAAkB;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;;AAE1B;AACA,kEAAkE,IAAI;AACtE,oCAAoC;;AAEpC;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,IAAI;AACpC,oCAAoC;;AAEpC;AACA;AACA,gCAAgC,IAAI;;AAEpC;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;;AAEA,8CAA8C,qDAAqD,IAAI;;AAEvG;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD,6BAA6B;;AAE7B;AACA;AACA,uDAAuD,IAAI;AAC3D;;AAEA;AACA,SAAS;AACT;AACA,+BAA+B;AAC/B;AACA,+BAA+B;;AAE/B;AACA,yCAAyC,yBAAyB,OAAO;;AAEzE;AACA,+BAA+B;;AAE/B,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC,aAAa;AACb,IAAI;AACJ;AACA,gCAAgC;;AAEhC;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,oDAAoD,KAAK;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;;AAEA,kBAAkB,uBAAuB,OAAO;;AAEhD;AACA;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,OAAO;AACjD,IAAI;AACJ,oCAAoC,KAAK;AACzC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa,OAAO;AACjD;;AAEA;AACA;AACA;AACA,wBAAwB,oBAAoB;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;;AAEA;AACA;AACA,0BAA0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;;AAE1B;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACvSA;AACA,OAAO,mBAAO,CAAC,yEAAO;AACtB,OAAO,mBAAO,CAAC,yEAAO;AACtB;;;;;;;;;;;ACHA,QAAQ,WAAW,EAAE,mBAAO,CAAC,kBAAM;;AAEnC,mBAAmB,mBAAO,CAAC,yEAAO;;AAElC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA,0BAA0B;;AAE1B,8BAA8B;;AAE9B;AACA,kCAAkC;AAClC;AACA,MAAM;AACN,gCAAgC;AAChC;AACA;AACA;AACA;AACA,oCAAoC,8CAA8C,MAAM;;AAExF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC3CA;AACA,QAAQ,WAAW,EAAE,mBAAO,CAAC,kBAAM;;AAEnC,aAAa,mBAAO,CAAC,6EAAc;AACnC,YAAY,mBAAO,CAAC,qFAAkB;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,YAAY,WAAW;;AAEtD;AACA;AACA;;AAEA,kDAAkD,OAAO,gBAAgB;;AAEzE;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ,2DAA2D,KAAK;AAChE;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,6DAA6D;AAC7D;AACA,oBAAoB,eAAe,OAAO;AAC1C,IAAI;AACJ;AACA,oBAAoB,eAAe,OAAO;AAC1C;;AAEA;AACA,iFAAiF,mBAAmB;AACpG;;AAEA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,iBAAiB,eAAe,eAAe;AAC/C;;AAEA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA,kBAAkB,WAAW,IAAI,IAAI,OAAO;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oCAAoC,KAAK;AACzC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA,gEAAgE,oBAAoB;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA,oBAAoB;;AAEpB,qBAAqB;;AAErB;AACA,oBAAoB,YAAY,WAAW;;AAE3C;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA,2CAA2C;;AAE3C,oDAAoD;;AAEpD,cAAc,iBAAiB;AAC/B,8CAA8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A;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,gBAAgB,mBAAO,CAAC,0CAAkB;;AAE1C;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,0BAA0B;AAC1B,2BAA2B;AAC3B,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACrLA;;AAEA;;AAEA,eAAe,mBAAO,CAAC,gEAAe;AACtC,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sEAAsE;AACtE;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,qCAAqC;AACrC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,CAAC;;;;;;;;;;;AC7OD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,yGAAwC;AAC/D,yBAAyB,2GAA0C;AACnE,eAAe,kDAAwB;;AAEvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC;;AAExC;AACA,6CAA6C;AAC7C;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,kBAAkB;AAC3B;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D,cAAc,oBAAoB;AAClC;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;ACzgBA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,mBAAmB,0DAA8B;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,mBAAO,CAAC,oFAAqB;AACrE,CAAC;;AAED;AACA,uCAAuC,mBAAO,CAAC,0FAAwB;AACvE,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC9EA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA,iCAAiC,QAAQ;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,MAAM;AACN,2DAA2D,QAAQ,IAAI,KAAK;AAC5E;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,UAAU,KAAK,OAAO;;AAE7E;AACA;AACA;AACA,QAAQ;AACR,gBAAgB,IAAI;AACpB;AACA,KAAK;;AAEL,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA,qBAAqB;AACrB,oBAAoB;;;;;;;;;;;;AChHP;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;;AAEF,qGAAqG,qBAAqB,mBAAmB;;AAE7I;AACA;AACA;;AAEA,kBAAe;AACf;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;;AAEA,qEAAqE,oFAAoF,wDAAwD;;AAEjN;AACA;;AAEA;AACA;AACA,KAAK;AACL;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C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ACtJ;AACA,6DAA6D,gBAAgB;AAC7E,yCAAyC,OAAO;AAChD;;AAEA;AACA,cAAc,mCAAmC,IAAI;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,eAAe,WAAW,qBAAqB;;AAE/C;AACA;AACA;AACA,+CAA+C,MAAM;AACrD;AACA;;AAEA;AACA;AACA,6CAA6C,MAAM;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,aAAa;;AAEb;;AAEA,iCAAiC,cAAc;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA,iCAAiC,cAAc;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,UAAU;AACV,2CAA2C,MAAM;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,WAAW;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;;AAEX,mCAAmC,kCAAkC;AACrE;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA,YAAY,qBAAqB;AACjC,UAAU,YAAY;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,qBAAqB;;AAExF;AACA;AACA;AACA;AACA,0CAA0C,iDAAiD;AAC3F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;;AAEjE;AACA;AACA,oDAAoD,+BAA+B;AACnF;;AAEA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB;;AAEvF;AACA;AACA;AACA;AACA,kDAAkD,+BAA+B;AACjF;AACA,yCAAyC,MAAM;AAC/C;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA,YAAY,qBAAqB;AACjC,UAAU,YAAY;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4DAA4D,OAAO;;AAEnE;AACA;AACA;AACA;AACA,2CAA2C,6CAA6C,IAAI,iDAAiD;AAC7I;AACA;AACA;AACA;AACA,2CAA2C,6CAA6C;AACxF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA;AACA;AACA,+DAA+D,0BAA0B;;AAEzF;AACA;AACA;AACA;AACA,wDAAwD,OAAO;;AAE/D;AACA;AACA,UAAU;AACV,qBAAqB,yBAAyB;AAC9C;;AAEA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB;;AAEvF;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;;AAEA,mBAAmB;;;;;;;;;;;AClbnB,QAAQ,MAAM,EAAE,mBAAO,CAAC,cAAI;;AAE5B,eAAe,mBAA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,mBAAO,CAAC,sBAAQ;;AAExC,kBAAkB,mBAAO,CAAC,kEAAa;AACvC,eAAe,mBAAO,CAAC,wDAAW;;AAElC;AACA;AACA;;AAEA;AACA;AACA,iEAAiE,IAAI;AACrE;AACA,sCAAsC,oBAAoB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA,mBAAmB,OAAO,IAAI;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzKA,QAAQ,yCAAyC,EAAE,mBAAO,CAAC,sBAAQ;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wDAAwD,IAAI;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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EA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,YAAY;AACZ;;AAEA;AACA,uCAAuC;AACvC;AACA,MAAM,OAAO;AACb,SAAS,8FAA8F;AACvG;;AAEA;AACA,4CAA4C,QAAQ;AACpD;;AAEA;;AAEA,KAAK,GAAG,WAAW;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,oDAAoD;AAClF,QAAQ;AACR,8BAA8B,sDAAsD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,sBAAsB;AACrD,QAAQ;AACR;AACA,sDAAsD,sBAAsB;AAC5E,QAAQ;AACR;AACA,sDAAsD,sBAAsB;AAC5E;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN,8EAA8E,qBAAqB;;AAEnG;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wEAAwE,QAAQ,QAAQ,QAAQ;;AAEhG;AACA,UAAU,sBAAsB;AAChC;AACA;AACA;AACA,6CAA6C,uBAAuB;AACpE;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1OA,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,kBAAM;;AAEzC,QAAQ,YAAY,EAAE,mBAAO,CAAC,kEAAgB;AAC9C,mBAAmB,mBAAO,CAAC,4EAAqB;AAChD,kBAAkB,mB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;AACL,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,oCAAoC,iCAAiC;AACrE,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxHA,mBAAmB,mBAAO,CAAC,4EAAqB;AAChD,kBAAkB,mBAAO,CAAC,wEAAmB;AAC7C,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,QAAQ,+BAA+B,EAAE,mBAAO,CAAC,wDAAW;;AAE5D;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACrEA,eAAe,mBAAO,CAAC,wDAAW;;AAElC,kBAAkB,mBAAO,CAAC,2DAAU;;AAEpC,eAAe,mBAAO,CAAC,6DAAW;AAClC,cAAc,mBAAO,CAAC,2DAAU;AAChC,eAAe,mBAAO,CAAC,6DAAW;AAClC,eAAe,mBAAO,CAAC,6DAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,IAAI;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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;AACvE,OAAO;AACP;AACA;AACA,oBAAoB,SAAS,oBAAoB,IAAI,kBAAkB;AACvE,OAAO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,qDAAqD,6CAA6C;AAClG;AACA,eAAe;AACf;AACA,aAAa;AACb,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,2DAA2D,yDAAyD;AACpH;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,gEAAgE,iEAAiE;AACjI;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,sDAAsD,yEAAyE;AAC/H;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,qDAAqD;;AAEjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,yCAAyC;AACzE;;AAEA,8BAA8B,qBAAqB;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,eAAe,IAAI;AACnB;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA,cAAc,uBAAuB,EAAE;AACvC;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;;AAEA;AACA;AACA,uEAAuE,sBAAsB;AAC7F;;AAEA;AACA,YAAY,8DAA8D;AAC1E;AACA,8DAA8D,8BAA8B;AAC5F;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA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AkC,oCAAoC;AACtE;AACA,oBAAoB,kBAAkB;AACtC,sBAAsB,SAAS;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvGA,kBAAkB,mBAAO,CAAC,wEAAmB;AAC7C,mBAAmB,mBAAO,CAAC,4EAAqB;AAChD,iBAAiB,mBAAO,CAAC,wEAAmB;AAC5C,kBAAkB,mBAAO,CAAC,0EAAoB;AAC9C,QAAQ,aAAa,EAAE,mBAAO,CAAC,wDAAW;AAC1C,QAAQ,OAAO,EAAE,mBAAO,CAAC,wDAAQ;AACjC,eAAe,mBAAO,CAAC,oEAAiB;;AAExC,oBAAoB,mBAAO,CAAC,qEAAe;;AAE3C;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,0CAA0C;;AAEtD;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR,6DAA6D;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;A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CA;;AAEA;AACA,0CAA0C,YAAY;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,iBAAiB;AACjB;AACA;;AAEA,0HAA0H;AAC1H;;AAEA,sCAAsC,YAAY;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,0HAA0H;AAC1H;;AAEA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;ACvKD,QAAQ,kBAAkB,EAAE,mBAAO,CAAC,wDAAW;;AAE/C;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;;AAEA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;;AAEA;AACA,kCAAkC,MAAM;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5CA,iBAAiB,mBAAO,CAAC,wEAAmB;AAC5C,aAAa,mBAAO,CAAC,8DAAc;AACnC,cAAc,mBAAO,CAAC,gEAAe;AACrC,eAAe,mBAAO,CAAC,oEAAiB;AACxC,YAAY,mBAAO,CAAC,wDAAQ;;AAE5B,iBAAiB,mHAAwC;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA,IAAI;;AAEJ;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;AC7FA,iBAAiB,mBAAO,CAAC,wEAAmB;AAC5C,cAAc,mBAAO,CAAC,gEAAe;AACrC,aAAa,mBAAO,CAAC,8DAAc;AACnC,eAAe,mBAAO,CAAC,oEAAiB;AACxC,QAAQ,eAAe,EAAE,mBAAO,CAAC,gEAAe;AAChD,QAAQ,8BAA8B,EAAE,mBAAO,CAAC,wDAAW;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,mFAAsB;AAClC,eAAe,mBAAO,CAAC,2DAAU;;AAEjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,kCAAkC,gBAAgB;AAClD;;AAEA;AACA,OAAO,MAAM,8BAA8B,gBAAgB,SAAS,kCAAkC;AACtG;AACA,IAAI;AACJ,gCAAgC,gBAAgB,SAAS,kBAAkB;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,eAAe;AAC1B;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,mCAAmC;AACnC;AACA,wCAAwC;AACxC;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,KAA0B;;AAE5C;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,QAAQ,UAAU;AAC7B,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ,UAAU;AAC7B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACntDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,kCAAkC,mBAAO,CAAC,0FAAW;AACrD,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,yCAAyC,mBAAO,CAAC,sEAAkB;AACnE,eAAe,mBAAO,CAAC,+DAAU;AACjC,aAAa,mBAAO,CAAC,2DAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,qBAAqB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,2CAA2C;;;;;;;;;;;ACjL9B;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA,2CAA2C;;;;;;;;;;;ACtB9B;AACb,cAAc,mBAAO,CAAC,6DAAS;AAC/B;AACA,2CAA2C;;;;;;;;;;;ACH9B;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,kCAAkC,mBAAO,CAAC,0FAAW;AACrD,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,yCAAyC,mBAAO,CAAC,sEAAkB;AACnE,eAAe,mBAAO,CAAC,+DAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,2CAA2C;;;;;;;;;;ACjH3C;;AAEA;AACA;AACA,UAAU,mBAAO,CAAC,sDAAW;AAC7B,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA,cAAc,mBAAO,CAAC,gFAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH,qBAAqB,uCAAuC;AAC5D;AACA,CAAC;;AAED;AACA,qBAAqB,6BAA6B;AAClD;AACA,CAAC;;AAED;AACA,qBAAqB,qCAAqC;AAC1D;AACA,CAAC;;AAED;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpdA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,0CAA0C,OAAO;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA,gCAAgC,iBAAiB;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6BAA6B;AACnE;AACA;AACA,SAAS,2BAA2B;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA;AACA,SAAS,6BAA6B;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;ACjXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,0DAAY;AAC/B,YAAY,mBAAO,CAAC,oBAAO;AAC3B,gBAAgB,mBAAO,CAAC,8CAAM;AAC9B,iBAAiB,mBAAO,CAAC,gCAAa;AACtC,gBAAgB,mBAAO,CAAC,8BAAY;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,YAAY,UAAU;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D,GAAG;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACzgBA;AACA;AACA;AACA;AACA;;AAEa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACzFA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF,EAAE,oGAAuC;AACzC;;;;;;;;;;;ACRA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH,sBAAsB;AACtB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChHa;;AAEb,eAAe,mBAAO,CAAC,0BAAU;AACjC,mBAAmB,mBAAO,CAAC,8EAAyB;;AAEpD;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,gDAAgD,4BAA4B;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;;;;;;;;;;;AChMpB;AACb,YAAY,mBAAO,CAAC,mFAAqB;;AAEzC,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,qBAAqB;AACpE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,+CAA+C;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uCAAuC;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,2CAA2C;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,6BAA6B,uCAAuC;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6CAA6C;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,2CAA2C;AAC1E;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACvMa;;AAEb,oBAAoB,mBAAO,CAAC,sGAAoB;AAChD,cAAc,mBAAO,CAAC,8DAAY;AAClC,aAAa,mBAAO,CAAC,qEAAgB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,cAAc,UAAU;AACxB,cAAc;AACd;AACA;;;;;;;;;;;;;AClMa;;AAEb,uGAAwC;AACxC,4IAAkE;AAClE,wJAA8E;AAC9E,8IAAoE;AACpE,gJAAsE;AACtE,gJAAsE;AACtE,8IAAoE;AACpE,oJAA0E;AAC1E,oIAA0D;;;;;;;;;;;;ACV7C;AACb,iBAAiB,mBAAO,CAAC,0BAAU;AACnC,aAAa,mBAAO,CAAC,8CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,8CAA8C;AAC9C;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,+CAA+C,sEAAsE;AACrH;;;;;;;;;;;;AChxCa;;AAEb,oBAAoB;AACpB;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA,4BAA4B;AAC5B,yBAAyB;;AAEzB,6BAA6B;AAC7B;AACA;;AAEA,6BAA6B;AAC7B;AACA;;;;;;;;;;;;;AClBa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,iBAAiB;AACnE,mDAAmD,gBAAgB;;AAEnE,oDAAoD,iBAAiB;AACrE,6DAA6D,gBAAgB;;AAE7E,mDAAmD,iBAAiB;AACpE,4DAA4D,gBAAgB;;AAE5E,wDAAwD,sCAAsC;AAC9F,iEAAiE,qCAAqC;;AAEtG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC5LA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACA4B;AACJ;AACF;AACa;AACT;AACF;;AAExB;;AAEA;AACA,iBAAiB,4CAAe;;AAEhC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,oBAAoB,+CAAkB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,kCAAkC;AAC9D;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,mCAAM,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mCAAM;AAC3B;AACA,iHAAiH,UAAU,IAAI,YAAY;AAC3I;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,+EAA+E,YAAY,UAAU,YAAY;AACjH;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB;AAC3B,aAAa,kBAAkB;AAC/B,gBAAgB,kBAAkB;AAClC,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE,SAAS;AAC9E;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,mCAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,YAAY,QAAQ,eAAe;AACvG,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yEAAyE,WAAW,IAAI,YAAY;AACpG;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,YAAY,cAAc,YAAY;AACnF;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,4EAA4E,WAAW,IAAI,YAAY;AACvG;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,GAAG;AACf,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,mCAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB,GAAG;AACH;AACA,4CAA4C;AAC5C,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,8BAA8B,WAAW,mBAAmB;AAC5D,GAAG,yBAAyB,mCAAM;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA,yBAAyB,MAAM;AAC/B;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,SAAS,kBAAkB;AAC3B,WAAW,kBAAkB;AAC7B,YAAY;AACZ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,8CAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,OAAO,kBAAkB;AACzB,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,YAAY,kBAAkB;AAC9B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,YAAY,oCAAO,IAAI,2CAAa;;AAEpC;AACA,kBAAkB,sCAAS;AAC3B,mBAAmB,uCAAU;;AAE7B;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,mEAAsC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,MAAM;AAClC;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,aAAa,kBAAkB;AAC/B,UAAU,kBAAkB;AAC5B,WAAW;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,4CAAe;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,oCAAO,IAAI,2CAAa;;AAEtC;AACA,sBAAsB,+CAAkB;;AAExC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,kCAAK,GAAG,iCAAI;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA,+CAA+C,4CAAe;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA,uCAAuC,aAAa,kBAAkB,YAAY;;AAElF;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sGAAsG,YAAY;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAAiB;AAC5B,iBAAiB,8CAAiB;AAClC;;AAEA;AACA;AACA,qBAAqB,8CAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAkB;AACzC,OAAO;AACP,uBAAuB,kDAAqB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iCAAiC,wDAA2B;AAC5D,qBAAqB,wDAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEA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","sources":["webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/api.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/base/buffer.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/base/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/base/node.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/base/reporter.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/constants/der.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/constants/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/decoders/der.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/decoders/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/decoders/pem.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/encoders/der.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/encoders/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/@panva/asn1.js/lib/asn1/encoders/pem.js","webpack://@ebi/macos-outlook-addin/./src/middle-tier/msgraph-helper.ts","webpack://@ebi/macos-outlook-addin/./src/middle-tier/ssoauth-helper.ts","webpack://@ebi/macos-outlook-addin/../../node_modules/basic-auth/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/cookie-parser/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/cors/lib/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/depd/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/depd/lib/compat/callsite-tostring.js","webpack://@ebi/macos-outlook-addin/../../node_modules/depd/lib/compat/event-listener-count.js","webpack://@ebi/macos-outlook-addin/../../node_modules/depd/lib/compat/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/dotenv/lib/main.js","webpack://@ebi/macos-outlook-addin/../../node_modules/form-urlencoded/dist/form-urlencoded.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/errors.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/algorithm_identifier.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/ec_private_key.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/oids.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/one_asymmetric_key.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/private_key.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/private_key_info.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/public_key_info.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/rsa_private_key.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/asn1/rsa_public_key.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/base64url.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/consts.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/deep_clone.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/ecdsa_signatures.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/epoch.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/generate_iv.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/get_key.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/is_disjoint.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/is_object.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/key_object.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/key_utils.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/node_alg.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/rsa_primes.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/runtime_support.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/secs.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/timing_safe_equal.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/uint64be.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/help/validate_crit.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/aes_cbc_hmac_sha2.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/aes_gcm.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/aes_gcm_kw.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/aes_kw.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/ecdh/compute_secret.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/ecdh/derive.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/ecdh/dir.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/ecdh/kw.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/ecdsa.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/eddsa.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/hmac.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/none.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/pbes2.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/rsaes.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/rsassa.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwa/rsassa_pss.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwe/decrypt.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwe/encrypt.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwe/generate_cek.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwe/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwe/serializers.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwe/validate_headers.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/generate.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/import.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/base.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/ec.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/embedded.jwk.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/embedded.x5c.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/none.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/oct.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/okp.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/key/rsa.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwk/thumbprint.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwks/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwks/keystore.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jws/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jws/serializers.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jws/sign.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jws/verify.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwt/decode.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwt/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwt/profiles.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwt/shared_validations.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwt/sign.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/jwt/verify.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/ec_curves.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/ecdh_derive_lengths.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/iv_lengths.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/jwa.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/jwk.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/key_lengths.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jose/lib/registry/okp_curves.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/JwksClient.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/errors/ArgumentError.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/errors/JwksError.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/errors/JwksRateLimitError.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/errors/SigningKeyNotFoundError.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/errors/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/integrations/config.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/integrations/express.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/integrations/hapi.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/integrations/koa.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/integrations/passport.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/utils.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/wrappers/cache.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/wrappers/callbackSupport.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/wrappers/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/wrappers/interceptor.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/wrappers/rateLimit.js","webpack://@ebi/macos-outlook-addin/../../node_modules/jwks-rsa/src/wrappers/request.js","webpack://@ebi/macos-outlook-addin/../../node_modules/limiter/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/limiter/lib/clock.js","webpack://@ebi/macos-outlook-addin/../../node_modules/limiter/lib/rateLimiter.js","webpack://@ebi/macos-outlook-addin/../../node_modules/limiter/lib/tokenBucket.js","webpack://@ebi/macos-outlook-addin/../../node_modules/lodash.clonedeep/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/lru-memoizer/lib/async.js","webpack://@ebi/macos-outlook-addin/../../node_modules/lru-memoizer/lib/freeze.js","webpack://@ebi/macos-outlook-addin/../../node_modules/lru-memoizer/lib/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/lru-memoizer/lib/sync.js","webpack://@ebi/macos-outlook-addin/../../node_modules/lru-memoizer/node_modules/lru-cache/lib/lru-cache.js","webpack://@ebi/macos-outlook-addin/../../node_modules/lru-memoizer/node_modules/yallist/yallist.js","webpack://@ebi/macos-outlook-addin/../../node_modules/morgan/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/object-assign/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/pseudomap/map.js","webpack://@ebi/macos-outlook-addin/../../node_modules/pseudomap/pseudomap.js","webpack://@ebi/macos-outlook-addin/../../node_modules/tr46/index.js","webpack://@ebi/macos-outlook-addin/../../node_modules/whatwg-url/lib/URL-impl.js","webpack://@ebi/macos-outlook-addin/../../node_modules/whatwg-url/lib/URL.js","webpack://@ebi/macos-outlook-addin/../../node_modules/whatwg-url/lib/public-api.js","webpack://@ebi/macos-outlook-addin/../../node_modules/whatwg-url/lib/url-state-machine.js","webpack://@ebi/macos-outlook-addin/../../node_modules/whatwg-url/lib/utils.js","webpack://@ebi/macos-outlook-addin/../../node_modules/whatwg-url/node_modules/webidl-conversions/lib/index.js","webpack://@ebi/macos-outlook-addin/external commonjs \"cookie\"","webpack://@ebi/macos-outlook-addin/external commonjs \"cookie-signature\"","webpack://@ebi/macos-outlook-addin/external commonjs \"debug\"","webpack://@ebi/macos-outlook-addin/external commonjs \"events\"","webpack://@ebi/macos-outlook-addin/external commonjs \"express\"","webpack://@ebi/macos-outlook-addin/external commonjs \"http-errors\"","webpack://@ebi/macos-outlook-addin/external commonjs \"jsonwebtoken\"","webpack://@ebi/macos-outlook-addin/external commonjs \"on-finished\"","webpack://@ebi/macos-outlook-addin/external commonjs \"on-headers\"","webpack://@ebi/macos-outlook-addin/external commonjs \"punycode\"","webpack://@ebi/macos-outlook-addin/external commonjs \"safe-buffer\"","webpack://@ebi/macos-outlook-addin/external commonjs \"vary\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"assert\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"crypto\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"fs\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"http\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"https\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"os\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"path\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"stream\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"url\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"util\"","webpack://@ebi/macos-outlook-addin/external node-commonjs \"zlib\"","webpack://@ebi/macos-outlook-addin/../../node_modules/node-fetch/lib/index.mjs","webpack://@ebi/macos-outlook-addin/webpack/bootstrap","webpack://@ebi/macos-outlook-addin/webpack/runtime/compat get default export","webpack://@ebi/macos-outlook-addin/webpack/runtime/define property getters","webpack://@ebi/macos-outlook-addin/webpack/runtime/hasOwnProperty shorthand","webpack://@ebi/macos-outlook-addin/webpack/runtime/make namespace object","webpack://@ebi/macos-outlook-addin/webpack/runtime/node module decorator","webpack://@ebi/macos-outlook-addin/./src/middle-tier/app.ts"],"sourcesContent":["const { define } = require('./asn1/api')\nconst base = require('./asn1/base')\nconst constants = require('./asn1/constants')\nconst decoders = require('./asn1/decoders')\nconst encoders = require('./asn1/encoders')\n\nmodule.exports = {\n  base,\n  constants,\n  decoders,\n  define,\n  encoders\n}\n","const { inherits } = require('util')\nconst encoders = require('./encoders')\nconst decoders = require('./decoders')\n\nmodule.exports.define = function define (name, body) {\n  return new Entity(name, body)\n}\n\nfunction Entity (name, body) {\n  this.name = name\n  this.body = body\n\n  this.decoders = {}\n  this.encoders = {}\n}\n\nEntity.prototype._createNamed = function createNamed (Base) {\n  const name = this.name\n\n  function Generated (entity) {\n    this._initNamed(entity, name)\n  }\n  inherits(Generated, Base)\n  Generated.prototype._initNamed = function _initNamed (entity, name) {\n    Base.call(this, entity, name)\n  }\n\n  return new Generated(this)\n}\n\nEntity.prototype._getDecoder = function _getDecoder (enc) {\n  enc = enc || 'der'\n  // Lazily create decoder\n  if (!Object.prototype.hasOwnProperty.call(this.decoders, enc)) { this.decoders[enc] = this._createNamed(decoders[enc]) }\n  return this.decoders[enc]\n}\n\nEntity.prototype.decode = function decode (data, enc, options) {\n  return this._getDecoder(enc).decode(data, options)\n}\n\nEntity.prototype._getEncoder = function _getEncoder (enc) {\n  enc = enc || 'der'\n  // Lazily create encoder\n  if (!Object.prototype.hasOwnProperty.call(this.encoders, enc)) { this.encoders[enc] = this._createNamed(encoders[enc]) }\n  return this.encoders[enc]\n}\n\nEntity.prototype.encode = function encode (data, enc, /* internal */ reporter) {\n  return this._getEncoder(enc).encode(data, reporter)\n}\n","const { inherits } = require('util')\n\nconst { Reporter } = require('../base/reporter')\n\nfunction DecoderBuffer (base, options) {\n  Reporter.call(this, options)\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer')\n    return\n  }\n\n  this.base = base\n  this.offset = 0\n  this.length = base.length\n}\ninherits(DecoderBuffer, Reporter)\n\nDecoderBuffer.isDecoderBuffer = function isDecoderBuffer (data) {\n  if (data instanceof DecoderBuffer) {\n    return true\n  }\n\n  // Or accept compatible API\n  const isCompatible = typeof data === 'object' &&\n    Buffer.isBuffer(data.base) &&\n    data.constructor.name === 'DecoderBuffer' &&\n    typeof data.offset === 'number' &&\n    typeof data.length === 'number' &&\n    typeof data.save === 'function' &&\n    typeof data.restore === 'function' &&\n    typeof data.isEmpty === 'function' &&\n    typeof data.readUInt8 === 'function' &&\n    typeof data.skip === 'function' &&\n    typeof data.raw === 'function'\n\n  return isCompatible\n}\n\nDecoderBuffer.prototype.save = function save () {\n  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) }\n}\n\nDecoderBuffer.prototype.restore = function restore (save) {\n  // Return skipped data\n  const res = new DecoderBuffer(this.base)\n  res.offset = save.offset\n  res.length = this.offset\n\n  this.offset = save.offset\n  Reporter.prototype.restore.call(this, save.reporter)\n\n  return res\n}\n\nDecoderBuffer.prototype.isEmpty = function isEmpty () {\n  return this.offset === this.length\n}\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8 (fail) {\n  if (this.offset + 1 <= this.length) { return this.base.readUInt8(this.offset++, true) } else { return this.error(fail || 'DecoderBuffer overrun') }\n}\n\nDecoderBuffer.prototype.skip = function skip (bytes, fail) {\n  if (!(this.offset + bytes <= this.length)) { return this.error(fail || 'DecoderBuffer overrun') }\n\n  const res = new DecoderBuffer(this.base)\n\n  // Share reporter state\n  res._reporterState = this._reporterState\n\n  res.offset = this.offset\n  res.length = this.offset + bytes\n  this.offset += bytes\n  return res\n}\n\nDecoderBuffer.prototype.raw = function raw (save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length)\n}\n\nfunction EncoderBuffer (value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0\n    this.value = value.map(function (item) {\n      if (!EncoderBuffer.isEncoderBuffer(item)) { item = new EncoderBuffer(item, reporter) }\n      this.length += item.length\n      return item\n    }, this)\n  } else if (typeof value === 'number') {\n    if (!(value >= 0 && value <= 0xff)) { return reporter.error('non-byte EncoderBuffer value') }\n    this.value = value\n    this.length = 1\n  } else if (typeof value === 'string') {\n    this.value = value\n    this.length = Buffer.byteLength(value)\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value\n    this.length = value.length\n  } else {\n    return reporter.error(`Unsupported type: ${typeof value}`)\n  }\n}\n\nEncoderBuffer.isEncoderBuffer = function isEncoderBuffer (data) {\n  if (data instanceof EncoderBuffer) {\n    return true\n  }\n\n  // Or accept compatible API\n  const isCompatible = typeof data === 'object' &&\n    data.constructor.name === 'EncoderBuffer' &&\n    typeof data.length === 'number' &&\n    typeof data.join === 'function'\n\n  return isCompatible\n}\n\nEncoderBuffer.prototype.join = function join (out, offset) {\n  if (!out) { out = Buffer.alloc(this.length) }\n  if (!offset) { offset = 0 }\n\n  if (this.length === 0) { return out }\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function (item) {\n      item.join(out, offset)\n      offset += item.length\n    })\n  } else {\n    if (typeof this.value === 'number') { out[offset] = this.value } else if (typeof this.value === 'string') { out.write(this.value, offset) } else if (Buffer.isBuffer(this.value)) { this.value.copy(out, offset) }\n    offset += this.length\n  }\n\n  return out\n}\n\nmodule.exports = {\n  DecoderBuffer,\n  EncoderBuffer\n}\n","const { Reporter } = require('./reporter')\nconst { DecoderBuffer, EncoderBuffer } = require('./buffer')\nconst Node = require('./node')\n\nmodule.exports = {\n  DecoderBuffer,\n  EncoderBuffer,\n  Node,\n  Reporter\n}\n","const { strict: assert } = require('assert')\n\nconst { Reporter } = require('../base/reporter')\nconst { DecoderBuffer, EncoderBuffer } = require('../base/buffer')\n\n// Supported tags\nconst tags = [\n  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',\n  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',\n  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',\n  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'\n]\n\n// Public methods list\nconst methods = [\n  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',\n  'any', 'contains'\n].concat(tags)\n\n// Overrided methods list\nconst overrided = [\n  '_peekTag', '_decodeTag', '_use',\n  '_decodeStr', '_decodeObjid', '_decodeTime',\n  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',\n\n  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',\n  '_encodeNull', '_encodeInt', '_encodeBool'\n]\n\nfunction Node (enc, parent, name) {\n  const state = {}\n  this._baseState = state\n\n  state.name = name\n  state.enc = enc\n\n  state.parent = parent || null\n  state.children = null\n\n  // State\n  state.tag = null\n  state.args = null\n  state.reverseArgs = null\n  state.choice = null\n  state.optional = false\n  state.any = false\n  state.obj = false\n  state.use = null\n  state.useDecoder = null\n  state.key = null\n  state.default = null\n  state.explicit = null\n  state.implicit = null\n  state.contains = null\n\n  // Should create new instance on each method\n  if (!state.parent) {\n    state.children = []\n    this._wrap()\n  }\n}\n\nconst stateProps = [\n  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',\n  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',\n  'implicit', 'contains'\n]\n\nNode.prototype.clone = function clone () {\n  const state = this._baseState\n  const cstate = {}\n  stateProps.forEach(function (prop) {\n    cstate[prop] = state[prop]\n  })\n  const res = new this.constructor(cstate.parent)\n  res._baseState = cstate\n  return res\n}\n\nNode.prototype._wrap = function wrap () {\n  const state = this._baseState\n  methods.forEach(function (method) {\n    this[method] = function _wrappedMethod () {\n      const clone = new this.constructor(this)\n      state.children.push(clone)\n      return clone[method].apply(clone, arguments)\n    }\n  }, this)\n}\n\nNode.prototype._init = function init (body) {\n  const state = this._baseState\n\n  assert(state.parent === null)\n  body.call(this)\n\n  // Filter children\n  state.children = state.children.filter(function (child) {\n    return child._baseState.parent === this\n  }, this)\n  assert.equal(state.children.length, 1, 'Root node can have only one child')\n}\n\nNode.prototype._useArgs = function useArgs (args) {\n  const state = this._baseState\n\n  // Filter children and args\n  const children = args.filter(function (arg) {\n    return arg instanceof this.constructor\n  }, this)\n  args = args.filter(function (arg) {\n    return !(arg instanceof this.constructor)\n  }, this)\n\n  if (children.length !== 0) {\n    assert(state.children === null)\n    state.children = children\n\n    // Replace parent to maintain backward link\n    children.forEach(function (child) {\n      child._baseState.parent = this\n    }, this)\n  }\n  if (args.length !== 0) {\n    assert(state.args === null)\n    state.args = args\n    state.reverseArgs = args.map(function (arg) {\n      if (typeof arg !== 'object' || arg.constructor !== Object) { return arg }\n\n      const res = {}\n      Object.keys(arg).forEach(function (key) {\n        if (key == (key | 0)) { key |= 0 } // eslint-disable-line eqeqeq\n        const value = arg[key]\n        res[value] = key\n      })\n      return res\n    })\n  }\n}\n\n//\n// Overrided methods\n//\n\noverrided.forEach(function (method) {\n  Node.prototype[method] = function _overrided () {\n    const state = this._baseState\n    throw new Error(`${method} not implemented for encoding: ${state.enc}`)\n  }\n})\n\n//\n// Public methods\n//\n\ntags.forEach(function (tag) {\n  Node.prototype[tag] = function _tagMethod () {\n    const state = this._baseState\n    const args = Array.prototype.slice.call(arguments)\n\n    assert(state.tag === null)\n    state.tag = tag\n\n    this._useArgs(args)\n\n    return this\n  }\n})\n\nNode.prototype.use = function use (item) {\n  assert(item)\n  const state = this._baseState\n\n  assert(state.use === null)\n  state.use = item\n\n  return this\n}\n\nNode.prototype.optional = function optional () {\n  const state = this._baseState\n\n  state.optional = true\n\n  return this\n}\n\nNode.prototype.def = function def (val) {\n  const state = this._baseState\n\n  assert(state.default === null)\n  state.default = val\n  state.optional = true\n\n  return this\n}\n\nNode.prototype.explicit = function explicit (num) {\n  const state = this._baseState\n\n  assert(state.explicit === null && state.implicit === null)\n  state.explicit = num\n\n  return this\n}\n\nNode.prototype.implicit = function implicit (num) {\n  const state = this._baseState\n\n  assert(state.explicit === null && state.implicit === null)\n  state.implicit = num\n\n  return this\n}\n\nNode.prototype.obj = function obj () {\n  const state = this._baseState\n  const args = Array.prototype.slice.call(arguments)\n\n  state.obj = true\n\n  if (args.length !== 0) { this._useArgs(args) }\n\n  return this\n}\n\nNode.prototype.key = function key (newKey) {\n  const state = this._baseState\n\n  assert(state.key === null)\n  state.key = newKey\n\n  return this\n}\n\nNode.prototype.any = function any () {\n  const state = this._baseState\n\n  state.any = true\n\n  return this\n}\n\nNode.prototype.choice = function choice (obj) {\n  const state = this._baseState\n\n  assert(state.choice === null)\n  state.choice = obj\n  this._useArgs(Object.keys(obj).map(function (key) {\n    return obj[key]\n  }))\n\n  return this\n}\n\nNode.prototype.contains = function contains (item) {\n  const state = this._baseState\n\n  assert(state.use === null)\n  state.contains = item\n\n  return this\n}\n\n//\n// Decoding\n//\n\nNode.prototype._decode = function decode (input, options) {\n  const state = this._baseState\n\n  // Decode root node\n  if (state.parent === null) { return input.wrapResult(state.children[0]._decode(input, options)) }\n\n  let result = state.default\n  let present = true\n\n  let prevKey = null\n  if (state.key !== null) { prevKey = input.enterKey(state.key) }\n\n  // Check if tag is there\n  if (state.optional) {\n    let tag = null\n    if (state.explicit !== null) { tag = state.explicit } else if (state.implicit !== null) { tag = state.implicit } else if (state.tag !== null) { tag = state.tag }\n\n    if (tag === null && !state.any) {\n      // Trial and Error\n      const save = input.save()\n      try {\n        if (state.choice === null) { this._decodeGeneric(state.tag, input, options) } else { this._decodeChoice(input, options) }\n        present = true\n      } catch (e) {\n        present = false\n      }\n      input.restore(save)\n    } else {\n      present = this._peekTag(input, tag, state.any)\n\n      if (input.isError(present)) { return present }\n    }\n  }\n\n  // Push object on stack\n  let prevObj\n  if (state.obj && present) { prevObj = input.enterObject() }\n\n  if (present) {\n    // Unwrap explicit values\n    if (state.explicit !== null) {\n      const explicit = this._decodeTag(input, state.explicit)\n      if (input.isError(explicit)) { return explicit }\n      input = explicit\n    }\n\n    const start = input.offset\n\n    // Unwrap implicit and normal values\n    if (state.use === null && state.choice === null) {\n      let save\n      if (state.any) { save = input.save() }\n      const body = this._decodeTag(\n        input,\n        state.implicit !== null ? state.implicit : state.tag,\n        state.any\n      )\n      if (input.isError(body)) { return body }\n\n      if (state.any) { result = input.raw(save) } else { input = body }\n    }\n\n    if (options && options.track && state.tag !== null) { options.track(input.path(), start, input.length, 'tagged') }\n\n    if (options && options.track && state.tag !== null) { options.track(input.path(), input.offset, input.length, 'content') }\n\n    // Select proper method for tag\n    if (state.any) {\n      // no-op\n    } else if (state.choice === null) {\n      result = this._decodeGeneric(state.tag, input, options)\n    } else {\n      result = this._decodeChoice(input, options)\n    }\n\n    if (input.isError(result)) { return result }\n\n    // Decode children\n    if (!state.any && state.choice === null && state.children !== null) {\n      state.children.forEach(function decodeChildren (child) {\n        // NOTE: We are ignoring errors here, to let parser continue with other\n        // parts of encoded data\n        child._decode(input, options)\n      })\n    }\n\n    // Decode contained/encoded by schema, only in bit or octet strings\n    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {\n      const data = new DecoderBuffer(result)\n      result = this._getUse(state.contains, input._reporterState.obj)\n        ._decode(data, options)\n    }\n  }\n\n  // Pop object\n  if (state.obj && present) { result = input.leaveObject(prevObj) }\n\n  // Set key\n  if (state.key !== null && (result !== null || present === true)) { input.leaveKey(prevKey, state.key, result) } else if (prevKey !== null) { input.exitKey(prevKey) }\n\n  return result\n}\n\nNode.prototype._decodeGeneric = function decodeGeneric (tag, input, options) {\n  const state = this._baseState\n\n  if (tag === 'seq' || tag === 'set') { return null }\n  if (tag === 'seqof' || tag === 'setof') { return this._decodeList(input, tag, state.args[0], options) } else if (/str$/.test(tag)) { return this._decodeStr(input, tag, options) } else if (tag === 'objid' && state.args) { return this._decodeObjid(input, state.args[0], state.args[1], options) } else if (tag === 'objid') { return this._decodeObjid(input, null, null, options) } else if (tag === 'gentime' || tag === 'utctime') { return this._decodeTime(input, tag, options) } else if (tag === 'null_') { return this._decodeNull(input, options) } else if (tag === 'bool') { return this._decodeBool(input, options) } else if (tag === 'objDesc') { return this._decodeStr(input, tag, options) } else if (tag === 'int' || tag === 'enum') { return this._decodeInt(input, state.args && state.args[0], options) }\n\n  if (state.use !== null) {\n    return this._getUse(state.use, input._reporterState.obj)\n      ._decode(input, options)\n  } else {\n    return input.error(`unknown tag: ${tag}`)\n  }\n}\n\nNode.prototype._getUse = function _getUse (entity, obj) {\n  const state = this._baseState\n  // Create altered use decoder if implicit is set\n  state.useDecoder = this._use(entity, obj)\n  assert(state.useDecoder._baseState.parent === null)\n  state.useDecoder = state.useDecoder._baseState.children[0]\n  if (state.implicit !== state.useDecoder._baseState.implicit) {\n    state.useDecoder = state.useDecoder.clone()\n    state.useDecoder._baseState.implicit = state.implicit\n  }\n  return state.useDecoder\n}\n\nNode.prototype._decodeChoice = function decodeChoice (input, options) {\n  const state = this._baseState\n  let result = null\n  let match = false\n\n  Object.keys(state.choice).some(function (key) {\n    const save = input.save()\n    const node = state.choice[key]\n    try {\n      const value = node._decode(input, options)\n      if (input.isError(value)) { return false }\n\n      result = { type: key, value: value }\n      match = true\n    } catch (e) {\n      input.restore(save)\n      return false\n    }\n    return true\n  }, this)\n\n  if (!match) { return input.error('Choice not matched') }\n\n  return result\n}\n\n//\n// Encoding\n//\n\nNode.prototype._createEncoderBuffer = function createEncoderBuffer (data) {\n  return new EncoderBuffer(data, this.reporter)\n}\n\nNode.prototype._encode = function encode (data, reporter, parent) {\n  const state = this._baseState\n  if (state.default !== null && state.default === data) { return }\n\n  const result = this._encodeValue(data, reporter, parent)\n  if (result === undefined) { return }\n\n  if (this._skipDefault(result, reporter, parent)) { return }\n\n  return result\n}\n\nNode.prototype._encodeValue = function encode (data, reporter, parent) {\n  const state = this._baseState\n\n  // Decode root node\n  if (state.parent === null) { return state.children[0]._encode(data, reporter || new Reporter()) }\n\n  let result = null\n\n  // Set reporter to share it with a child class\n  this.reporter = reporter\n\n  // Check if data is there\n  if (state.optional && data === undefined) {\n    if (state.default !== null) { data = state.default } else { return }\n  }\n\n  // Encode children first\n  let content = null\n  let primitive = false\n  if (state.any) {\n    // Anything that was given is translated to buffer\n    result = this._createEncoderBuffer(data)\n  } else if (state.choice) {\n    result = this._encodeChoice(data, reporter)\n  } else if (state.contains) {\n    content = this._getUse(state.contains, parent)._encode(data, reporter)\n    primitive = true\n  } else if (state.children) {\n    content = state.children.map(function (child) {\n      if (child._baseState.tag === 'null_') { return child._encode(null, reporter, data) }\n\n      if (child._baseState.key === null) { return reporter.error('Child should have a key') }\n      const prevKey = reporter.enterKey(child._baseState.key)\n\n      if (typeof data !== 'object') { return reporter.error('Child expected, but input is not object') }\n\n      const res = child._encode(data[child._baseState.key], reporter, data)\n      reporter.leaveKey(prevKey)\n\n      return res\n    }, this).filter(function (child) {\n      return child\n    })\n    content = this._createEncoderBuffer(content)\n  } else {\n    if (state.tag === 'seqof' || state.tag === 'setof') {\n      if (!(state.args && state.args.length === 1)) { return reporter.error(`Too many args for: ${state.tag}`) }\n\n      if (!Array.isArray(data)) { return reporter.error('seqof/setof, but data is not Array') }\n\n      const child = this.clone()\n      child._baseState.implicit = null\n      content = this._createEncoderBuffer(data.map(function (item) {\n        const state = this._baseState\n\n        return this._getUse(state.args[0], data)._encode(item, reporter)\n      }, child))\n    } else if (state.use !== null) {\n      result = this._getUse(state.use, parent)._encode(data, reporter)\n    } else {\n      content = this._encodePrimitive(state.tag, data)\n      primitive = true\n    }\n  }\n\n  // Encode data itself\n  if (!state.any && state.choice === null) {\n    const tag = state.implicit !== null ? state.implicit : state.tag\n    const cls = state.implicit === null ? 'universal' : 'context'\n\n    if (tag === null) {\n      if (state.use === null) { reporter.error('Tag could be omitted only for .use()') }\n    } else {\n      if (state.use === null) { result = this._encodeComposite(tag, primitive, cls, content) }\n    }\n  }\n\n  // Wrap in explicit\n  if (state.explicit !== null) { result = this._encodeComposite(state.explicit, false, 'context', result) }\n\n  return result\n}\n\nNode.prototype._encodeChoice = function encodeChoice (data, reporter) {\n  const state = this._baseState\n\n  const node = state.choice[data.type]\n  if (!node) {\n    assert(\n      false,\n      `${data.type} not found in ${JSON.stringify(Object.keys(state.choice))}`\n    )\n  }\n  return node._encode(data.value, reporter)\n}\n\nNode.prototype._encodePrimitive = function encodePrimitive (tag, data) {\n  const state = this._baseState\n\n  if (/str$/.test(tag)) { return this._encodeStr(data, tag) } else if (tag === 'objid' && state.args) { return this._encodeObjid(data, state.reverseArgs[0], state.args[1]) } else if (tag === 'objid') { return this._encodeObjid(data, null, null) } else if (tag === 'gentime' || tag === 'utctime') { return this._encodeTime(data, tag) } else if (tag === 'null_') { return this._encodeNull() } else if (tag === 'int' || tag === 'enum') { return this._encodeInt(data, state.args && state.reverseArgs[0]) } else if (tag === 'bool') { return this._encodeBool(data) } else if (tag === 'objDesc') { return this._encodeStr(data, tag) } else { throw new Error(`Unsupported tag: ${tag}`) }\n}\n\nNode.prototype._isNumstr = function isNumstr (str) {\n  return /^[0-9 ]*$/.test(str)\n}\n\nNode.prototype._isPrintstr = function isPrintstr (str) {\n  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str)\n}\n\nmodule.exports = Node\n","const { inherits } = require('util')\n\nfunction Reporter (options) {\n  this._reporterState = {\n    obj: null,\n    path: [],\n    options: options || {},\n    errors: []\n  }\n}\n\nReporter.prototype.isError = function isError (obj) {\n  return obj instanceof ReporterError\n}\n\nReporter.prototype.save = function save () {\n  const state = this._reporterState\n\n  return { obj: state.obj, pathLen: state.path.length }\n}\n\nReporter.prototype.restore = function restore (data) {\n  const state = this._reporterState\n\n  state.obj = data.obj\n  state.path = state.path.slice(0, data.pathLen)\n}\n\nReporter.prototype.enterKey = function enterKey (key) {\n  return this._reporterState.path.push(key)\n}\n\nReporter.prototype.exitKey = function exitKey (index) {\n  const state = this._reporterState\n\n  state.path = state.path.slice(0, index - 1)\n}\n\nReporter.prototype.leaveKey = function leaveKey (index, key, value) {\n  const state = this._reporterState\n\n  this.exitKey(index)\n  if (state.obj !== null) { state.obj[key] = value }\n}\n\nReporter.prototype.path = function path () {\n  return this._reporterState.path.join('/')\n}\n\nReporter.prototype.enterObject = function enterObject () {\n  const state = this._reporterState\n\n  const prev = state.obj\n  state.obj = {}\n  return prev\n}\n\nReporter.prototype.leaveObject = function leaveObject (prev) {\n  const state = this._reporterState\n\n  const now = state.obj\n  state.obj = prev\n  return now\n}\n\nReporter.prototype.error = function error (msg) {\n  let err\n  const state = this._reporterState\n\n  const inherited = msg instanceof ReporterError\n  if (inherited) {\n    err = msg\n  } else {\n    err = new ReporterError(state.path.map(function (elem) {\n      return `[${JSON.stringify(elem)}]`\n    }).join(''), msg.message || msg, msg.stack)\n  }\n\n  if (!state.options.partial) { throw err }\n\n  if (!inherited) { state.errors.push(err) }\n\n  return err\n}\n\nReporter.prototype.wrapResult = function wrapResult (result) {\n  const state = this._reporterState\n  if (!state.options.partial) { return result }\n\n  return {\n    result: this.isError(result) ? null : result,\n    errors: state.errors\n  }\n}\n\nfunction ReporterError (path, msg) {\n  this.path = path\n  this.rethrow(msg)\n}\ninherits(ReporterError, Error)\n\nReporterError.prototype.rethrow = function rethrow (msg) {\n  this.message = `${msg} at: ${this.path || '(shallow)'}`\n  if (Error.captureStackTrace) { Error.captureStackTrace(this, ReporterError) }\n\n  if (!this.stack) {\n    try {\n      // IE only adds stack when thrown\n      throw new Error(this.message)\n    } catch (e) {\n      this.stack = e.stack\n    }\n  }\n  return this\n}\n\nexports.Reporter = Reporter\n","// Helper\nfunction reverse (map) {\n  const res = {}\n\n  Object.keys(map).forEach(function (key) {\n    // Convert key to integer if it is stringified\n    if ((key | 0) == key) { key = key | 0 } // eslint-disable-line eqeqeq\n\n    const value = map[key]\n    res[value] = key\n  })\n\n  return res\n}\n\nexports.tagClass = {\n  0: 'universal',\n  1: 'application',\n  2: 'context',\n  3: 'private'\n}\nexports.tagClassByName = reverse(exports.tagClass)\n\nexports.tag = {\n  0x00: 'end',\n  0x01: 'bool',\n  0x02: 'int',\n  0x03: 'bitstr',\n  0x04: 'octstr',\n  0x05: 'null_',\n  0x06: 'objid',\n  0x07: 'objDesc',\n  0x08: 'external',\n  0x09: 'real',\n  0x0a: 'enum',\n  0x0b: 'embed',\n  0x0c: 'utf8str',\n  0x0d: 'relativeOid',\n  0x10: 'seq',\n  0x11: 'set',\n  0x12: 'numstr',\n  0x13: 'printstr',\n  0x14: 't61str',\n  0x15: 'videostr',\n  0x16: 'ia5str',\n  0x17: 'utctime',\n  0x18: 'gentime',\n  0x19: 'graphstr',\n  0x1a: 'iso646str',\n  0x1b: 'genstr',\n  0x1c: 'unistr',\n  0x1d: 'charstr',\n  0x1e: 'bmpstr'\n}\nexports.tagByName = reverse(exports.tag)\n","module.exports = {\n  der: require('./der')\n}\n","/* global BigInt */\nconst { inherits } = require('util')\n\nconst { DecoderBuffer } = require('../base/buffer')\nconst Node = require('../base/node')\n\n// Import DER constants\nconst der = require('../constants/der')\n\nfunction DERDecoder (entity) {\n  this.enc = 'der'\n  this.name = entity.name\n  this.entity = entity\n\n  // Construct base tree\n  this.tree = new DERNode()\n  this.tree._init(entity.body)\n}\n\nDERDecoder.prototype.decode = function decode (data, options) {\n  if (!DecoderBuffer.isDecoderBuffer(data)) {\n    data = new DecoderBuffer(data, options)\n  }\n\n  return this.tree._decode(data, options)\n}\n\n// Tree methods\n\nfunction DERNode (parent) {\n  Node.call(this, 'der', parent)\n}\ninherits(DERNode, Node)\n\nDERNode.prototype._peekTag = function peekTag (buffer, tag, any) {\n  if (buffer.isEmpty()) { return false }\n\n  const state = buffer.save()\n  const decodedTag = derDecodeTag(buffer, `Failed to peek tag: \"${tag}\"`)\n  if (buffer.isError(decodedTag)) { return decodedTag }\n\n  buffer.restore(state)\n\n  return decodedTag.tag === tag || decodedTag.tagStr === tag || (decodedTag.tagStr + 'of') === tag || any\n}\n\nDERNode.prototype._decodeTag = function decodeTag (buffer, tag, any) {\n  const decodedTag = derDecodeTag(buffer,\n    `Failed to decode tag of \"${tag}\"`)\n  if (buffer.isError(decodedTag)) { return decodedTag }\n\n  let len = derDecodeLen(buffer,\n    decodedTag.primitive,\n    `Failed to get length of \"${tag}\"`)\n\n  // Failure\n  if (buffer.isError(len)) { return len }\n\n  if (!any &&\n      decodedTag.tag !== tag &&\n      decodedTag.tagStr !== tag &&\n      decodedTag.tagStr + 'of' !== tag) {\n    return buffer.error(`Failed to match tag: \"${tag}\"`)\n  }\n\n  if (decodedTag.primitive || len !== null) { return buffer.skip(len, `Failed to match body of: \"${tag}\"`) }\n\n  // Indefinite length... find END tag\n  const state = buffer.save()\n  const res = this._skipUntilEnd(\n    buffer,\n    `Failed to skip indefinite length body: \"${this.tag}\"`)\n  if (buffer.isError(res)) { return res }\n\n  len = buffer.offset - state.offset\n  buffer.restore(state)\n  return buffer.skip(len, `Failed to match body of: \"${tag}\"`)\n}\n\nDERNode.prototype._skipUntilEnd = function skipUntilEnd (buffer, fail) {\n  for (;;) {\n    const tag = derDecodeTag(buffer, fail)\n    if (buffer.isError(tag)) { return tag }\n    const len = derDecodeLen(buffer, tag.primitive, fail)\n    if (buffer.isError(len)) { return len }\n\n    let res\n    if (tag.primitive || len !== null) { res = buffer.skip(len) } else { res = this._skipUntilEnd(buffer, fail) }\n\n    // Failure\n    if (buffer.isError(res)) { return res }\n\n    if (tag.tagStr === 'end') { break }\n  }\n}\n\nDERNode.prototype._decodeList = function decodeList (buffer, tag, decoder,\n  options) {\n  const result = []\n  while (!buffer.isEmpty()) {\n    const possibleEnd = this._peekTag(buffer, 'end')\n    if (buffer.isError(possibleEnd)) { return possibleEnd }\n\n    const res = decoder.decode(buffer, 'der', options)\n    if (buffer.isError(res) && possibleEnd) { break }\n    result.push(res)\n  }\n  return result\n}\n\nDERNode.prototype._decodeStr = function decodeStr (buffer, tag) {\n  if (tag === 'bitstr') {\n    const unused = buffer.readUInt8()\n    if (buffer.isError(unused)) { return unused }\n    return { unused: unused, data: buffer.raw() }\n  } else if (tag === 'bmpstr') {\n    const raw = buffer.raw()\n    if (raw.length % 2 === 1) { return buffer.error('Decoding of string type: bmpstr length mismatch') }\n\n    let str = ''\n    for (let i = 0; i < raw.length / 2; i++) {\n      str += String.fromCharCode(raw.readUInt16BE(i * 2))\n    }\n    return str\n  } else if (tag === 'numstr') {\n    const numstr = buffer.raw().toString('ascii')\n    if (!this._isNumstr(numstr)) {\n      return buffer.error('Decoding of string type: numstr unsupported characters')\n    }\n    return numstr\n  } else if (tag === 'octstr') {\n    return buffer.raw()\n  } else if (tag === 'objDesc') {\n    return buffer.raw()\n  } else if (tag === 'printstr') {\n    const printstr = buffer.raw().toString('ascii')\n    if (!this._isPrintstr(printstr)) {\n      return buffer.error('Decoding of string type: printstr unsupported characters')\n    }\n    return printstr\n  } else if (/str$/.test(tag)) {\n    return buffer.raw().toString()\n  } else {\n    return buffer.error(`Decoding of string type: ${tag} unsupported`)\n  }\n}\n\nDERNode.prototype._decodeObjid = function decodeObjid (buffer, values, relative) {\n  let result\n  const identifiers = []\n  let ident = 0\n  let subident = 0\n  while (!buffer.isEmpty()) {\n    subident = buffer.readUInt8()\n    ident <<= 7\n    ident |= subident & 0x7f\n    if ((subident & 0x80) === 0) {\n      identifiers.push(ident)\n      ident = 0\n    }\n  }\n  if (subident & 0x80) { identifiers.push(ident) }\n\n  const first = (identifiers[0] / 40) | 0\n  const second = identifiers[0] % 40\n\n  if (relative) { result = identifiers } else { result = [first, second].concat(identifiers.slice(1)) }\n\n  if (values) {\n    let tmp = values[result.join(' ')]\n    if (tmp === undefined) { tmp = values[result.join('.')] }\n    if (tmp !== undefined) { result = tmp }\n  }\n\n  return result\n}\n\nDERNode.prototype._decodeTime = function decodeTime (buffer, tag) {\n  const str = buffer.raw().toString()\n\n  let year\n  let mon\n  let day\n  let hour\n  let min\n  let sec\n  if (tag === 'gentime') {\n    year = str.slice(0, 4) | 0\n    mon = str.slice(4, 6) | 0\n    day = str.slice(6, 8) | 0\n    hour = str.slice(8, 10) | 0\n    min = str.slice(10, 12) | 0\n    sec = str.slice(12, 14) | 0\n  } else if (tag === 'utctime') {\n    year = str.slice(0, 2) | 0\n    mon = str.slice(2, 4) | 0\n    day = str.slice(4, 6) | 0\n    hour = str.slice(6, 8) | 0\n    min = str.slice(8, 10) | 0\n    sec = str.slice(10, 12) | 0\n    if (year < 70) { year = 2000 + year } else { year = 1900 + year }\n  } else {\n    return buffer.error(`Decoding ${tag} time is not supported yet`)\n  }\n\n  return Date.UTC(year, mon - 1, day, hour, min, sec, 0)\n}\n\nDERNode.prototype._decodeNull = function decodeNull () {\n  return null\n}\n\nDERNode.prototype._decodeBool = function decodeBool (buffer) {\n  const res = buffer.readUInt8()\n  if (buffer.isError(res)) { return res } else { return res !== 0 }\n}\n\nDERNode.prototype._decodeInt = function decodeInt (buffer, values) {\n  // Bigint, return as it is (assume big endian)\n  const raw = buffer.raw()\n  let res = BigInt(`0x${raw.toString('hex')}`)\n\n  if (values) {\n    res = values[res.toString(10)] || res\n  }\n\n  return res\n}\n\nDERNode.prototype._use = function use (entity, obj) {\n  if (typeof entity === 'function') { entity = entity(obj) }\n  return entity._getDecoder('der').tree\n}\n\n// Utility methods\n\nfunction derDecodeTag (buf, fail) {\n  let tag = buf.readUInt8(fail)\n  if (buf.isError(tag)) { return tag }\n\n  const cls = der.tagClass[tag >> 6]\n  const primitive = (tag & 0x20) === 0\n\n  // Multi-octet tag - load\n  if ((tag & 0x1f) === 0x1f) {\n    let oct = tag\n    tag = 0\n    while ((oct & 0x80) === 0x80) {\n      oct = buf.readUInt8(fail)\n      if (buf.isError(oct)) { return oct }\n\n      tag <<= 7\n      tag |= oct & 0x7f\n    }\n  } else {\n    tag &= 0x1f\n  }\n  const tagStr = der.tag[tag]\n\n  return {\n    cls: cls,\n    primitive: primitive,\n    tag: tag,\n    tagStr: tagStr\n  }\n}\n\nfunction derDecodeLen (buf, primitive, fail) {\n  let len = buf.readUInt8(fail)\n  if (buf.isError(len)) { return len }\n\n  // Indefinite form\n  if (!primitive && len === 0x80) { return null }\n\n  // Definite form\n  if ((len & 0x80) === 0) {\n    // Short form\n    return len\n  }\n\n  // Long form\n  const num = len & 0x7f\n  if (num > 4) { return buf.error('length octect is too long') }\n\n  len = 0\n  for (let i = 0; i < num; i++) {\n    len <<= 8\n    const j = buf.readUInt8(fail)\n    if (buf.isError(j)) { return j }\n    len |= j\n  }\n\n  return len\n}\n\nmodule.exports = DERDecoder\n","module.exports = {\n  der: require('./der'),\n  pem: require('./pem')\n}\n","const { inherits } = require('util')\n\nconst DERDecoder = require('./der')\n\nfunction PEMDecoder (entity) {\n  DERDecoder.call(this, entity)\n  this.enc = 'pem'\n}\ninherits(PEMDecoder, DERDecoder)\n\nPEMDecoder.prototype.decode = function decode (data, options) {\n  const lines = data.toString().split(/[\\r\\n]+/g)\n\n  const label = options.label.toUpperCase()\n\n  const re = /^-----(BEGIN|END) ([^-]+)-----$/\n  let start = -1\n  let end = -1\n  for (let i = 0; i < lines.length; i++) {\n    const match = lines[i].match(re)\n    if (match === null) { continue }\n\n    if (match[2] !== label) { continue }\n\n    if (start === -1) {\n      if (match[1] !== 'BEGIN') { break }\n      start = i\n    } else {\n      if (match[1] !== 'END') { break }\n      end = i\n      break\n    }\n  }\n  if (start === -1 || end === -1) { throw new Error(`PEM section not found for: ${label}`) }\n\n  const base64 = lines.slice(start + 1, end).join('')\n  // Remove excessive symbols\n  base64.replace(/[^a-z0-9+/=]+/gi, '')\n\n  const input = Buffer.from(base64, 'base64')\n  return DERDecoder.prototype.decode.call(this, input, options)\n}\n\nmodule.exports = PEMDecoder\n","/* global BigInt */\nconst { inherits } = require('util')\n\nconst Node = require('../base/node')\nconst der = require('../constants/der')\n\nfunction DEREncoder (entity) {\n  this.enc = 'der'\n  this.name = entity.name\n  this.entity = entity\n\n  // Construct base tree\n  this.tree = new DERNode()\n  this.tree._init(entity.body)\n}\n\nDEREncoder.prototype.encode = function encode (data, reporter) {\n  return this.tree._encode(data, reporter).join()\n}\n\n// Tree methods\n\nfunction DERNode (parent) {\n  Node.call(this, 'der', parent)\n}\ninherits(DERNode, Node)\n\nDERNode.prototype._encodeComposite = function encodeComposite (tag,\n  primitive,\n  cls,\n  content) {\n  const encodedTag = encodeTag(tag, primitive, cls, this.reporter)\n\n  // Short form\n  if (content.length < 0x80) {\n    const header = Buffer.alloc(2)\n    header[0] = encodedTag\n    header[1] = content.length\n    return this._createEncoderBuffer([header, content])\n  }\n\n  // Long form\n  // Count octets required to store length\n  let lenOctets = 1\n  for (let i = content.length; i >= 0x100; i >>= 8) { lenOctets++ }\n\n  const header = Buffer.alloc(1 + 1 + lenOctets)\n  header[0] = encodedTag\n  header[1] = 0x80 | lenOctets\n\n  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) { header[i] = j & 0xff }\n\n  return this._createEncoderBuffer([header, content])\n}\n\nDERNode.prototype._encodeStr = function encodeStr (str, tag) {\n  if (tag === 'bitstr') {\n    return this._createEncoderBuffer([str.unused | 0, str.data])\n  } else if (tag === 'bmpstr') {\n    const buf = Buffer.alloc(str.length * 2)\n    for (let i = 0; i < str.length; i++) {\n      buf.writeUInt16BE(str.charCodeAt(i), i * 2)\n    }\n    return this._createEncoderBuffer(buf)\n  } else if (tag === 'numstr') {\n    if (!this._isNumstr(str)) {\n      return this.reporter.error('Encoding of string type: numstr supports only digits and space')\n    }\n    return this._createEncoderBuffer(str)\n  } else if (tag === 'printstr') {\n    if (!this._isPrintstr(str)) {\n      return this.reporter.error('Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark')\n    }\n    return this._createEncoderBuffer(str)\n  } else if (/str$/.test(tag)) {\n    return this._createEncoderBuffer(str)\n  } else if (tag === 'objDesc') {\n    return this._createEncoderBuffer(str)\n  } else {\n    return this.reporter.error(`Encoding of string type: ${tag} unsupported`)\n  }\n}\n\nDERNode.prototype._encodeObjid = function encodeObjid (id, values, relative) {\n  if (typeof id === 'string') {\n    if (!values) { return this.reporter.error('string objid given, but no values map found') }\n    if (!Object.prototype.hasOwnProperty.call(values, id)) { return this.reporter.error('objid not found in values map') }\n    id = values[id].split(/[\\s.]+/g)\n    for (let i = 0; i < id.length; i++) { id[i] |= 0 }\n  } else if (Array.isArray(id)) {\n    id = id.slice()\n    for (let i = 0; i < id.length; i++) { id[i] |= 0 }\n  }\n\n  if (!Array.isArray(id)) {\n    return this.reporter.error(`objid() should be either array or string, got: ${JSON.stringify(id)}`)\n  }\n\n  if (!relative) {\n    if (id[1] >= 40) { return this.reporter.error('Second objid identifier OOB') }\n    id.splice(0, 2, id[0] * 40 + id[1])\n  }\n\n  // Count number of octets\n  let size = 0\n  for (let i = 0; i < id.length; i++) {\n    let ident = id[i]\n    for (size++; ident >= 0x80; ident >>= 7) { size++ }\n  }\n\n  const objid = Buffer.alloc(size)\n  let offset = objid.length - 1\n  for (let i = id.length - 1; i >= 0; i--) {\n    let ident = id[i]\n    objid[offset--] = ident & 0x7f\n    while ((ident >>= 7) > 0) { objid[offset--] = 0x80 | (ident & 0x7f) }\n  }\n\n  return this._createEncoderBuffer(objid)\n}\n\nfunction two (num) {\n  if (num < 10) { return `0${num}` } else { return num }\n}\n\nDERNode.prototype._encodeTime = function encodeTime (time, tag) {\n  let str\n  const date = new Date(time)\n\n  if (tag === 'gentime') {\n    str = [\n      two(date.getUTCFullYear()),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('')\n  } else if (tag === 'utctime') {\n    str = [\n      two(date.getUTCFullYear() % 100),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('')\n  } else {\n    this.reporter.error(`Encoding ${tag} time is not supported yet`)\n  }\n\n  return this._encodeStr(str, 'octstr')\n}\n\nDERNode.prototype._encodeNull = function encodeNull () {\n  return this._createEncoderBuffer('')\n}\n\nfunction bnToBuf (bn) {\n  var hex = BigInt(bn).toString(16)\n  if (hex.length % 2) { hex = '0' + hex }\n\n  var len = hex.length / 2\n  var u8 = new Uint8Array(len)\n\n  var i = 0\n  var j = 0\n  while (i < len) {\n    u8[i] = parseInt(hex.slice(j, j + 2), 16)\n    i += 1\n    j += 2\n  }\n\n  return u8\n}\n\nDERNode.prototype._encodeInt = function encodeInt (num, values) {\n  if (typeof num === 'string') {\n    if (!values) { return this.reporter.error('String int or enum given, but no values map') }\n    if (!Object.prototype.hasOwnProperty.call(values, num)) {\n      return this.reporter.error(`Values map doesn't contain: ${JSON.stringify(num)}`)\n    }\n    num = values[num]\n  }\n\n  if (typeof num === 'bigint') {\n    const numArray = [...bnToBuf(num)]\n    if (numArray[0] & 0x80) {\n      numArray.unshift(0)\n    }\n    num = Buffer.from(numArray)\n  }\n\n  if (Buffer.isBuffer(num)) {\n    let size = num.length\n    if (num.length === 0) { size++ }\n\n    const out = Buffer.alloc(size)\n    num.copy(out)\n    if (num.length === 0) { out[0] = 0 }\n    return this._createEncoderBuffer(out)\n  }\n\n  if (num < 0x80) { return this._createEncoderBuffer(num) }\n\n  if (num < 0x100) { return this._createEncoderBuffer([0, num]) }\n\n  let size = 1\n  for (let i = num; i >= 0x100; i >>= 8) { size++ }\n\n  const out = new Array(size)\n  for (let i = out.length - 1; i >= 0; i--) {\n    out[i] = num & 0xff\n    num >>= 8\n  }\n  if (out[0] & 0x80) {\n    out.unshift(0)\n  }\n\n  return this._createEncoderBuffer(Buffer.from(out))\n}\n\nDERNode.prototype._encodeBool = function encodeBool (value) {\n  return this._createEncoderBuffer(value ? 0xff : 0)\n}\n\nDERNode.prototype._use = function use (entity, obj) {\n  if (typeof entity === 'function') { entity = entity(obj) }\n  return entity._getEncoder('der').tree\n}\n\nDERNode.prototype._skipDefault = function skipDefault (dataBuffer, reporter, parent) {\n  const state = this._baseState\n  let i\n  if (state.default === null) { return false }\n\n  const data = dataBuffer.join()\n  if (state.defaultBuffer === undefined) { state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join() }\n\n  if (data.length !== state.defaultBuffer.length) { return false }\n\n  for (i = 0; i < data.length; i++) {\n    if (data[i] !== state.defaultBuffer[i]) { return false }\n  }\n\n  return true\n}\n\n// Utility methods\n\nfunction encodeTag (tag, primitive, cls, reporter) {\n  let res\n\n  if (tag === 'seqof') { tag = 'seq' } else if (tag === 'setof') { tag = 'set' }\n\n  if (Object.prototype.hasOwnProperty.call(der.tagByName, tag)) { res = der.tagByName[tag] } else if (typeof tag === 'number' && (tag | 0) === tag) { res = tag } else { return reporter.error(`Unknown tag: ${tag}`) }\n\n  if (res >= 0x1f) { return reporter.error('Multi-octet tag encoding unsupported') }\n\n  if (!primitive) { res |= 0x20 }\n\n  res |= (der.tagClassByName[cls || 'universal'] << 6)\n\n  return res\n}\n\nmodule.exports = DEREncoder\n","module.exports = {\n  der: require('./der'),\n  pem: require('./pem')\n}\n","const { inherits } = require('util')\n\nconst DEREncoder = require('./der')\n\nfunction PEMEncoder (entity) {\n  DEREncoder.call(this, entity)\n  this.enc = 'pem'\n}\ninherits(PEMEncoder, DEREncoder)\n\nPEMEncoder.prototype.encode = function encode (data, options) {\n  const buf = DEREncoder.prototype.encode.call(this, data)\n\n  const p = buf.toString('base64')\n  const out = [`-----BEGIN ${options.label}-----`]\n  for (let i = 0; i < p.length; i += 64) { out.push(p.slice(i, i + 64)) }\n  out.push(`-----END ${options.label}-----`)\n  return out.join('\\n')\n}\n\nmodule.exports = PEMEncoder\n","// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license in the root of the repo.\n/*\n    This file provides the provides functionality to get Microsoft Graph data.\n*/\nimport * as createError from \"http-errors\";\nimport * as https from \"https\";\nimport { getAccessToken, getAccessTokenSendMail } from \"./ssoauth-helper\";\n\n/* global process */\n\nconst domain: string = \"graph.microsoft.com\";\nconst version: string = \"v1.0\";\n\nexport async function addAttachmentToEmail(req: any, res: any, next: any) {\n  const messageId = req.body.messageId\n  const attachmentData = {\n    \"@odata.type\": \"#microsoft.graph.fileAttachment\",\n    \"name\": `${req.body.fileName}`,\n    \"contentBytes\": `${req.body.dataAttachment}`,\n  };\n\n  await postData(req, res, next, `/me/mailFolders/drafts/messages/${messageId}/attachments`, JSON.stringify(attachmentData))\n}\n\nexport async function createUploadSession(req: any, res: any, next: any) {\n  const messageId = req.body.messageId\n  const attachmentData = {\"AttachmentItem\": {\n    \"attachmentType\": \"file\",\n    \"name\": `${req.body.fileName}`,\n    \"size\": req.body.fileSize\n  }}\n\n  await postData(req, res, next, `/me/messages/${messageId}/attachments/createUploadSession`, JSON.stringify(attachmentData))\n}\n\nexport async function getUserData(req: any, res: any, next: any) {\n  await getData(req, res, next, \"/me\")\n}\n\nexport async function getMessageByID(req: any, res: any, next: any) {\n  const { emailId } = req.query;\n  await getData(req, res, next, \"/me/messages/\", emailId)\n}\n\nexport async function getMessageAttachmentByID(req: any, res: any, next: any) {\n  const { emailId } = req.query;\n  await getData(req, res, next, \"/me/messages/\", emailId + \"/attachments\")\n}\n\nexport async function getMessages(req: any, res: any, next: any) {\n  await getData(req, res, next, \"/me/messages?%24top=500\")\n}\n\nexport async function getNewestDraftMessage(req: any, res: any, next: any) {\n  await getData(req, res, next, \"/me/mailFolders/drafts/messages\")\n}\n\nexport async function getMessageAttachmentByDraftID(req: any, res: any, next: any) {\n  const { emailId } = req.query;\n  await getData(req, res, next, \"/me/mailFolders/drafts/messages/\", emailId + \"/attachments\")\n}\n\nexport async function deleteDraftAttachment(req: any, res: any, next: any) {\n  const { emailId } = req.query;\n  const { attachmentID } = req.query;\n  await deleteData(req, res, next, `/me/mailFolders/drafts/messages/${emailId}/attachments/${attachmentID}`)\n}\n\nexport async function sendMessages(req: any, res: any, next: any) {\n  const emailData = req.body\n  await postData(req, res, next, \"/me/sendMail\", JSON.stringify(emailData))\n}\n\nexport async function sendMessagesHasId(req: any, res: any, next: any) {\n  const { messageId }= req.query\n  await postData(req, res, next, `/me/messages/${messageId}/send`)\n}\n\nexport async function requestUploadLargeAttachment(req: any, res: any, next: any) {\n  const uploadUrl = req.body.uploadUrl\n  await putData(req, res, next, uploadUrl, req)\n}\n\nasync function getData(req: any, res: any, next: any, url: string, queryParams?: string) {\n  const authorization: string = req.get(\"Authorization\");\n\n  await getAccessToken(authorization)\n    .then(async (graphTokenResponse) => {\n      if (graphTokenResponse && (graphTokenResponse.claims || graphTokenResponse.error)) {\n        res.send(graphTokenResponse);\n      } else {\n        const graphToken: string = graphTokenResponse.access_token;\n        const graphUrlSegment: string = url;\n        const graphQueryParamSegment: string = queryParams || \"\";\n\n        const graphData = await getGraphData(graphToken, graphUrlSegment, graphQueryParamSegment);\n\n        // If Microsoft Graph returns an error, such as invalid or expired token,\n        // there will be a code property in the returned object set to a HTTP status (e.g. 401).\n        // Relay it to the client. It will caught in the fail callback of `makeGraphApiCall`.\n        if (graphData.code) {\n          next(createError(graphData.code, \"Microsoft Graph error \" + JSON.stringify(graphData)));\n        } else {\n          res.send(graphData);\n        }\n      }\n    })\n    .catch((err) => {\n      res.status(401).send(err.message);\n      return;\n    });\n}\n\nexport async function getGraphData(accessToken: string, apiUrl: string, queryParams?: string): Promise<any> {\n  return new Promise<any>((resolve, reject) => {\n    const options: https.RequestOptions = {\n      host: domain,\n      path: \"/\" + version + apiUrl + queryParams,\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        Authorization: \"Bearer \" + accessToken,\n        \"Cache-Control\": \"private, no-cache, no-store, must-revalidate\",\n        Expires: \"-1\",\n        Pragma: \"no-cache\",\n      },\n    };\n\n    https\n      .get(options, (response) => {\n        let body = \"\";\n        response.on(\"data\", (d) => {\n          body += d;\n        });\n        response.on(\"end\", () => {\n          // The response from the OData endpoint might be an error, say a\n          // 401 if the endpoint requires an access token and it was invalid\n          // or expired. But a message is not an error in the call of https.get,\n          // so the \"on('error', reject)\" line below isn't triggered.\n          // So, the code distinguishes success (200) messages from error\n          // messages and sends a JSON object to the caller with either the\n          // requested OData or error information.\n\n          let error;\n          if (response.statusCode === 200) {\n            let parsedBody = JSON.parse(body);\n            resolve(parsedBody);\n          } else {\n            error = new Error();\n            error.code = response.statusCode;\n            error.message = response.statusMessage;\n\n            // The error body sometimes includes an empty space\n            // before the first character, remove it or it causes an error.\n            body = body.trim();\n            error.bodyCode = JSON.parse(body).error.code;\n            error.bodyMessage = JSON.parse(body).error.message;\n            resolve(error);\n          }\n        });\n      })\n      .on(\"error\", reject);\n  });\n}\n\nasync function postData(req: any, res: any, next: any, url: string, data_json?: string) {\n  const authorization: string = req.get(\"Authorization\");\n\n  await getAccessTokenSendMail(authorization)\n    .then(async (graphTokenResponse) => {\n      if (graphTokenResponse && (graphTokenResponse.claims || graphTokenResponse.error)) {\n        res.send(graphTokenResponse);\n      } else {\n        const graphToken: string = graphTokenResponse.access_token;\n        const graphUrlSegment: string = url;\n        const graphQueryParamSegment = data_json;\n\n        const graphData = await postGraphData(graphToken, graphUrlSegment, graphQueryParamSegment);\n\n        // If Microsoft Graph returns an error, such as invalid or expired token,\n        // there will be a code property in the returned object set to a HTTP status (e.g. 401).\n        // Relay it to the client. It will caught in the fail callback of `makeGraphApiCall`.\n        if (graphData.code) {\n          next(createError(graphData.code, \"Microsoft Graph error \" + JSON.stringify(graphData)));\n        } else {\n          res.send(graphData);\n        }\n      }\n    })\n    .catch((err) => {\n      res.status(401).send(err.message);\n      return;\n    });\n}\n\nexport async function postGraphData(accessToken: string, apiUrl: string, data_json?: string): Promise<any> {\n  return new Promise<any>((resolve, reject) => {\n    const options: https.RequestOptions = {\n      host: domain,\n      path: \"/\" + version + apiUrl,\n      method: \"POST\",\n      headers: {\n        Accept: \"application/json\",\n        Authorization: \"Bearer \" + accessToken,\n      },\n    };\n\n    if (data_json) {\n      options.headers['Content-Type'] = 'application/json';\n      options.headers['Content-Length'] = Buffer.byteLength(data_json);\n    }\n\n    const mess = `{\n      \"message\": \"OK\"\n    }`;\n\n    const request = https\n      .request(options, (response) => {\n        let body = \"\";\n        response.on(\"data\", (d) => {\n          body += d;\n        });\n        response.on(\"end\", () => {\n          // The response from the OData endpoint might be an error, say a\n          // 401 if the endpoint requires an access token and it was invalid\n          // or expired. But a message is not an error in the call of https.get,\n          // so the \"on('error', reject)\" line below isn't triggered.\n          // So, the code distinguishes success (200) messages from error\n          // messages and sends a JSON object to the caller with either the\n          // requested OData or error information.\n\n          let error;\n            if (response.statusCode === 200 || response.statusCode === 201 || response.statusCode === 202) {\n              let parsedBody = body ? JSON.parse(body) : JSON.parse(mess);\n              resolve(parsedBody);\n            } else {\n              error = new Error();\n              error.code = response.statusCode;\n              error.message = response.statusMessage;\n\n              // The error body sometimes includes an empty space\n              // before the first character, remove it or it causes an error.\n              body = body.trim();\n              error.bodyCode = JSON.parse(body).error.code;\n              error.bodyMessage = JSON.parse(body).error.message;\n              resolve(error);\n            }\n        });\n      });\n    \n    request.on(\"error\", reject);\n    if (data_json) {\n      request.write(data_json);\n    }\n    request.end();\n  });\n}\n\nasync function deleteData(req: any, res: any, next: any, url: string) {\n  const authorization: string = req.get(\"Authorization\");\n\n  await getAccessTokenSendMail(authorization)\n    .then(async (graphTokenResponse) => {\n      if (graphTokenResponse && (graphTokenResponse.claims || graphTokenResponse.error)) {\n        res.send(graphTokenResponse);\n      } else {\n        const graphToken: string = graphTokenResponse.access_token;\n        const graphUrlSegment: string = url;\n\n        const graphData = await deleteGraphData(graphToken, graphUrlSegment);\n\n        // If Microsoft Graph returns an error, such as invalid or expired token,\n        // there will be a code property in the returned object set to a HTTP status (e.g. 401).\n        // Relay it to the client. It will caught in the fail callback of `makeGraphApiCall`.\n        if (graphData.code) {\n          next(createError(graphData.code, \"Microsoft Graph error \" + JSON.stringify(graphData)));\n        } else {\n          res.send(graphData);\n        }\n      }\n    })\n    .catch((err) => {\n      res.status(401).send(err.message);\n      return;\n    });\n}\n\nexport async function deleteGraphData(accessToken: string, apiUrl: string): Promise<any> {\n  return new Promise<any>((resolve, reject) => {\n    const options: https.RequestOptions = {\n      host: domain,\n      path: \"/\" + version + apiUrl,\n      method: \"DELETE\",\n      headers: {\n        Accept: \"application/json\",\n        Authorization: \"Bearer \" + accessToken,\n        \"Content-Type\": \"application/json\",\n      },\n    };\n\n    const request = https\n      .request(options, (response) => {\n        let body = \"\";\n        response.on(\"data\", (d) => {\n          body += d;\n        });\n        response.on(\"end\", () => {\n          // The response from the OData endpoint might be an error, say a\n          // 401 if the endpoint requires an access token and it was invalid\n          // or expired. But a message is not an error in the call of https.get,\n          // so the \"on('error', reject)\" line below isn't triggered.\n          // So, the code distinguishes success (200) messages from error\n          // messages and sends a JSON object to the caller with either the\n          // requested OData or error information.\n\n          let error;\n          if (response.statusCode === 200) {\n            let parsedBody = JSON.parse(body);\n            resolve(parsedBody);\n          } else {\n            error = new Error();\n            error.code = response.statusCode;\n            error.message = response.statusMessage;\n\n            // The error body sometimes includes an empty space\n            // before the first character, remove it or it causes an error.\n            body = body.trim();\n            error.bodyCode = JSON.parse(body).error.code;\n            error.bodyMessage = JSON.parse(body).error.message;\n            resolve(error);\n          }\n        });\n      });\n    \n    request.on(\"error\", reject);\n    request.end();\n  });\n}\n\nasync function putData(req: any, res: any, next: any, url: string, data_json?: any) {\n  const authorization: string = req.get(\"Authorization\");\n\n  await getAccessTokenSendMail(authorization)\n    .then(async (graphTokenResponse) => {\n      if (graphTokenResponse && (graphTokenResponse.claims || graphTokenResponse.error)) {\n        res.send(graphTokenResponse);\n      } else {\n        const graphToken: string = graphTokenResponse.access_token;\n        const graphUrlSegment: string = url;\n        const graphQueryParamSegment = data_json;\n\n        const graphData = await putGraphData(graphToken, graphUrlSegment, graphQueryParamSegment);\n\n        // If Microsoft Graph returns an error, such as invalid or expired token,\n        // there will be a code property in the returned object set to a HTTP status (e.g. 401).\n        // Relay it to the client. It will caught in the fail callback of `makeGraphApiCall`.\n        if (graphData.code) {\n          next(createError(graphData.code, \"Microsoft Graph error \" + JSON.stringify(graphData)));\n        } else {\n          res.send(graphData);\n        }\n      }\n    })\n    .catch((err) => {\n      res.status(401).send(err.message);\n      return;\n    });\n}\n\nexport async function putGraphData(accessToken: string, apiUrl: string, data_json: any ): Promise<any> {\n  const url = new URL(apiUrl)\n  const token = url.searchParams.get(\"authtoken\")\n  const from = data_json.body.from\n  const to = data_json.body.to\n  const size = data_json.body.fileSize\n  return new Promise<any>((resolve, reject) => {\n    const options: https.RequestOptions = {\n      host: url.hostname,\n      path: url.pathname + url.search,\n      method: \"PUT\",\n      headers: {\n        Accept: \"application/json\",\n        Authorization: \"Bearer \" + token,\n      },\n    };\n\n    options.headers['Content-Type'] = 'application/octet-stream';\n    options.headers['Content-Length'] = `${to - from + 1}`;\n    options.headers['Content-Range']= `bytes ${from}-${to}/${size}`;\n\n    const mess = `{\n          \"message\": \"OK\"\n        }`;\n\n    const request = https\n      .request(options, (response) => {\n        let body = \"\";\n        response.on(\"data\", (d) => {\n          body += d;\n        });\n        response.on(\"end\", () => {\n          // The response from the OData endpoint might be an error, say a\n          // 401 if the endpoint requires an access token and it was invalid\n          // or expired. But a message is not an error in the call of https.get,\n          // so the \"on('error', reject)\" line below isn't triggered.\n          // So, the code distinguishes success (200) messages from error\n          // messages and sends a JSON object to the caller with either the\n          // requested OData or error information.\n\n          let error;\n          if (response) {\n            if (response.statusCode === 200 || response.statusCode === 201 || response.statusCode === 202) {\n              let parsedBody = body ? JSON.parse(body) : JSON.parse(mess);\n              resolve(parsedBody);\n            } else {\n              error = new Error();\n              error.code = response.statusCode;\n              error.message = response.statusMessage;\n\n              // The error body sometimes includes an empty space\n              // before the first character, remove it or it causes an error.\n              body = body.trim();\n              error.bodyCode = JSON.parse(body).error.code;\n              error.bodyMessage = JSON.parse(body).error.message;\n              resolve(error);\n            }\n          } else {\n            response.statusCode = 200;\n            response.statusMessage = \"OK\";\n            resolve(JSON.parse(mess));\n          }\n        });\n      });\n    \n    request.on(\"error\", reject);\n    request.write(data_json.body.attachment)\n    // if (data_json) {\n    //   request.write(data_json);\n    // }\n    request.end();\n  });\n}","/*\n * Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license in root of repo. -->\n *\n * This file defines the routes within the authRoute router.\n */\n\nimport fetch from \"node-fetch\";\nimport form from \"form-urlencoded\";\nimport jwt from \"jsonwebtoken\";\nimport { JwksClient } from \"jwks-rsa\";\n\n/* global process, console */\n\nconst DISCOVERY_KEYS_ENDPOINT = \"https://login.microsoftonline.com/common/discovery/v2.0/keys\";\n\nexport async function getAccessToken(authorization: string): Promise<any> {\n  if (!authorization) {\n    let error = new Error(\"No Authorization header was found.\");\n    return Promise.reject(error);\n  } else {\n    const scopeName: string[] = [\"User.Read\"];\n    const [, /* schema */ assertion] = authorization.split(\" \");\n\n    const tokenScopes = (jwt.decode(assertion) as jwt.JwtPayload).scp.split(\" \");\n    const accessAsUserScope = tokenScopes.find((scope) => scope === \"access_as_user\");\n    if (!accessAsUserScope) {\n      throw new Error(\"Missing access_as_user\");\n    }\n\n    const formParams = {\n      client_id: process.env.CLIENT_ID,\n      client_secret: process.env.CLIENT_SECRET,\n      grant_type: \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n      assertion: assertion,\n      requested_token_use: \"on_behalf_of\",\n      scope: scopeName.join(\" \"),\n    };\n\n    const stsDomain: string = \"https://login.microsoftonline.com\";\n    const tenant: string = \"common\";\n    const tokenURLSegment: string = \"oauth2/v2.0/token\";\n    const encodedForm = form(formParams);\n\n    const tokenResponse = await fetch(`${stsDomain}/${tenant}/${tokenURLSegment}`, {\n      method: \"POST\",\n      body: encodedForm,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n    });\n    const json = await tokenResponse.json();\n    return json;\n  }\n}\n\nexport async function getAccessTokenSendMail(authorization: string): Promise<any> {\n  if (!authorization) {\n    let error = new Error(\"No Authorization header was found.\");\n    return Promise.reject(error);\n  } else {\n    const scopeName: string[] = [\"Mail.Send\"];\n    const [, /* schema */ assertion] = authorization.split(\" \");\n\n    const tokenScopes = (jwt.decode(assertion) as jwt.JwtPayload).scp.split(\" \");\n    const accessAsUserScope = tokenScopes.find((scope) => scope === \"access_as_user\");\n    if (!accessAsUserScope) {\n      throw new Error(\"Missing access_as_user\");\n    }\n\n    const formParams = {\n      client_id: process.env.CLIENT_ID,\n      client_secret: process.env.CLIENT_SECRET,\n      grant_type: \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n      assertion: assertion,\n      requested_token_use: \"on_behalf_of\",\n      scope: scopeName.join(\" \"),\n    };\n\n    const stsDomain: string = \"https://login.microsoftonline.com\";\n    const tenant: string = \"common\";\n    const tokenURLSegment: string = \"oauth2/v2.0/token\";\n    const encodedForm = form(formParams);\n\n    const tokenResponse = await fetch(`${stsDomain}/${tenant}/${tokenURLSegment}`, {\n      method: \"POST\",\n      body: encodedForm,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n    });\n    const json = await tokenResponse.json();\n    return json;\n  }\n}\n\nexport function validateJwt(req, res, next): void {\n  const authHeader = req.headers.authorization;\n  if (authHeader) {\n    const token = authHeader.split(\" \")[1];\n\n    const validationOptions = {\n      audience: process.env.CLIENT_ID,\n    };\n\n    jwt.verify(token, getSigningKeys, validationOptions, (err) => {\n      if (err) {\n        console.log(err);\n        return res.sendStatus(403);\n      }\n\n      next();\n    });\n  }\n}\n\nfunction getSigningKeys(header: any, callback: any) {\n  var client: JwksClient = new JwksClient({\n    jwksUri: DISCOVERY_KEYS_ENDPOINT,\n  });\n\n  client.getSigningKey(header.kid, function (err, key) {\n    callback(null, key.getPublicKey());\n  });\n}\n","/*!\n * basic-auth\n * Copyright(c) 2013 TJ Holowaychuk\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Buffer = require('safe-buffer').Buffer\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = auth\nmodule.exports.parse = parse\n\n/**\n * RegExp for basic auth credentials\n *\n * credentials = auth-scheme 1*SP token68\n * auth-scheme = \"Basic\" ; case insensitive\n * token68     = 1*( ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\n * @private\n */\n\nvar CREDENTIALS_REGEXP = /^ *(?:[Bb][Aa][Ss][Ii][Cc]) +([A-Za-z0-9._~+/-]+=*) *$/\n\n/**\n * RegExp for basic auth user/pass\n *\n * user-pass   = userid \":\" password\n * userid      = *<TEXT excluding \":\">\n * password    = *TEXT\n * @private\n */\n\nvar USER_PASS_REGEXP = /^([^:]*):(.*)$/\n\n/**\n * Parse the Authorization header field of a request.\n *\n * @param {object} req\n * @return {object} with .name and .pass\n * @public\n */\n\nfunction auth (req) {\n  if (!req) {\n    throw new TypeError('argument req is required')\n  }\n\n  if (typeof req !== 'object') {\n    throw new TypeError('argument req is required to be an object')\n  }\n\n  // get header\n  var header = getAuthorization(req)\n\n  // parse header\n  return parse(header)\n}\n\n/**\n * Decode base64 string.\n * @private\n */\n\nfunction decodeBase64 (str) {\n  return Buffer.from(str, 'base64').toString()\n}\n\n/**\n * Get the Authorization header from request object.\n * @private\n */\n\nfunction getAuthorization (req) {\n  if (!req.headers || typeof req.headers !== 'object') {\n    throw new TypeError('argument req is required to have headers property')\n  }\n\n  return req.headers.authorization\n}\n\n/**\n * Parse basic auth to object.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction parse (string) {\n  if (typeof string !== 'string') {\n    return undefined\n  }\n\n  // parse header\n  var match = CREDENTIALS_REGEXP.exec(string)\n\n  if (!match) {\n    return undefined\n  }\n\n  // decode user pass\n  var userPass = USER_PASS_REGEXP.exec(decodeBase64(match[1]))\n\n  if (!userPass) {\n    return undefined\n  }\n\n  // return credentials object\n  return new Credentials(userPass[1], userPass[2])\n}\n\n/**\n * Object to represent user credentials.\n * @private\n */\n\nfunction Credentials (name, pass) {\n  this.name = name\n  this.pass = pass\n}\n","/*!\n * cookie-parser\n * Copyright(c) 2014 TJ Holowaychuk\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar cookie = require('cookie')\nvar signature = require('cookie-signature')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = cookieParser\nmodule.exports.JSONCookie = JSONCookie\nmodule.exports.JSONCookies = JSONCookies\nmodule.exports.signedCookie = signedCookie\nmodule.exports.signedCookies = signedCookies\n\n/**\n * Parse Cookie header and populate `req.cookies`\n * with an object keyed by the cookie names.\n *\n * @param {string|array} [secret] A string (or array of strings) representing cookie signing secret(s).\n * @param {Object} [options]\n * @return {Function}\n * @public\n */\n\nfunction cookieParser (secret, options) {\n  var secrets = !secret || Array.isArray(secret)\n    ? (secret || [])\n    : [secret]\n\n  return function cookieParser (req, res, next) {\n    if (req.cookies) {\n      return next()\n    }\n\n    var cookies = req.headers.cookie\n\n    req.secret = secrets[0]\n    req.cookies = Object.create(null)\n    req.signedCookies = Object.create(null)\n\n    // no cookies\n    if (!cookies) {\n      return next()\n    }\n\n    req.cookies = cookie.parse(cookies, options)\n\n    // parse signed cookies\n    if (secrets.length !== 0) {\n      req.signedCookies = signedCookies(req.cookies, secrets)\n      req.signedCookies = JSONCookies(req.signedCookies)\n    }\n\n    // parse JSON cookies\n    req.cookies = JSONCookies(req.cookies)\n\n    next()\n  }\n}\n\n/**\n * Parse JSON cookie string.\n *\n * @param {String} str\n * @return {Object} Parsed object or undefined if not json cookie\n * @public\n */\n\nfunction JSONCookie (str) {\n  if (typeof str !== 'string' || str.substr(0, 2) !== 'j:') {\n    return undefined\n  }\n\n  try {\n    return JSON.parse(str.slice(2))\n  } catch (err) {\n    return undefined\n  }\n}\n\n/**\n * Parse JSON cookies.\n *\n * @param {Object} obj\n * @return {Object}\n * @public\n */\n\nfunction JSONCookies (obj) {\n  var cookies = Object.keys(obj)\n  var key\n  var val\n\n  for (var i = 0; i < cookies.length; i++) {\n    key = cookies[i]\n    val = JSONCookie(obj[key])\n\n    if (val) {\n      obj[key] = val\n    }\n  }\n\n  return obj\n}\n\n/**\n * Parse a signed cookie string, return the decoded value.\n *\n * @param {String} str signed cookie string\n * @param {string|array} secret\n * @return {String} decoded value\n * @public\n */\n\nfunction signedCookie (str, secret) {\n  if (typeof str !== 'string') {\n    return undefined\n  }\n\n  if (str.substr(0, 2) !== 's:') {\n    return str\n  }\n\n  var secrets = !secret || Array.isArray(secret)\n    ? (secret || [])\n    : [secret]\n\n  for (var i = 0; i < secrets.length; i++) {\n    var val = signature.unsign(str.slice(2), secrets[i])\n\n    if (val !== false) {\n      return val\n    }\n  }\n\n  return false\n}\n\n/**\n * Parse signed cookies, returning an object containing the decoded key/value\n * pairs, while removing the signed key from obj.\n *\n * @param {Object} obj\n * @param {string|array} secret\n * @return {Object}\n * @public\n */\n\nfunction signedCookies (obj, secret) {\n  var cookies = Object.keys(obj)\n  var dec\n  var key\n  var ret = Object.create(null)\n  var val\n\n  for (var i = 0; i < cookies.length; i++) {\n    key = cookies[i]\n    val = obj[key]\n    dec = signedCookie(val, secret)\n\n    if (val !== dec) {\n      ret[key] = dec\n      delete obj[key]\n    }\n  }\n\n  return ret\n}\n","(function () {\n\n  'use strict';\n\n  var assign = require('object-assign');\n  var vary = require('vary');\n\n  var defaults = {\n    origin: '*',\n    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n    preflightContinue: false,\n    optionsSuccessStatus: 204\n  };\n\n  function isString(s) {\n    return typeof s === 'string' || s instanceof String;\n  }\n\n  function isOriginAllowed(origin, allowedOrigin) {\n    if (Array.isArray(allowedOrigin)) {\n      for (var i = 0; i < allowedOrigin.length; ++i) {\n        if (isOriginAllowed(origin, allowedOrigin[i])) {\n          return true;\n        }\n      }\n      return false;\n    } else if (isString(allowedOrigin)) {\n      return origin === allowedOrigin;\n    } else if (allowedOrigin instanceof RegExp) {\n      return allowedOrigin.test(origin);\n    } else {\n      return !!allowedOrigin;\n    }\n  }\n\n  function configureOrigin(options, req) {\n    var requestOrigin = req.headers.origin,\n      headers = [],\n      isAllowed;\n\n    if (!options.origin || options.origin === '*') {\n      // allow any origin\n      headers.push([{\n        key: 'Access-Control-Allow-Origin',\n        value: '*'\n      }]);\n    } else if (isString(options.origin)) {\n      // fixed origin\n      headers.push([{\n        key: 'Access-Control-Allow-Origin',\n        value: options.origin\n      }]);\n      headers.push([{\n        key: 'Vary',\n        value: 'Origin'\n      }]);\n    } else {\n      isAllowed = isOriginAllowed(requestOrigin, options.origin);\n      // reflect origin\n      headers.push([{\n        key: 'Access-Control-Allow-Origin',\n        value: isAllowed ? requestOrigin : false\n      }]);\n      headers.push([{\n        key: 'Vary',\n        value: 'Origin'\n      }]);\n    }\n\n    return headers;\n  }\n\n  function configureMethods(options) {\n    var methods = options.methods;\n    if (methods.join) {\n      methods = options.methods.join(','); // .methods is an array, so turn it into a string\n    }\n    return {\n      key: 'Access-Control-Allow-Methods',\n      value: methods\n    };\n  }\n\n  function configureCredentials(options) {\n    if (options.credentials === true) {\n      return {\n        key: 'Access-Control-Allow-Credentials',\n        value: 'true'\n      };\n    }\n    return null;\n  }\n\n  function configureAllowedHeaders(options, req) {\n    var allowedHeaders = options.allowedHeaders || options.headers;\n    var headers = [];\n\n    if (!allowedHeaders) {\n      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers\n      headers.push([{\n        key: 'Vary',\n        value: 'Access-Control-Request-Headers'\n      }]);\n    } else if (allowedHeaders.join) {\n      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string\n    }\n    if (allowedHeaders && allowedHeaders.length) {\n      headers.push([{\n        key: 'Access-Control-Allow-Headers',\n        value: allowedHeaders\n      }]);\n    }\n\n    return headers;\n  }\n\n  function configureExposedHeaders(options) {\n    var headers = options.exposedHeaders;\n    if (!headers) {\n      return null;\n    } else if (headers.join) {\n      headers = headers.join(','); // .headers is an array, so turn it into a string\n    }\n    if (headers && headers.length) {\n      return {\n        key: 'Access-Control-Expose-Headers',\n        value: headers\n      };\n    }\n    return null;\n  }\n\n  function configureMaxAge(options) {\n    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString()\n    if (maxAge && maxAge.length) {\n      return {\n        key: 'Access-Control-Max-Age',\n        value: maxAge\n      };\n    }\n    return null;\n  }\n\n  function applyHeaders(headers, res) {\n    for (var i = 0, n = headers.length; i < n; i++) {\n      var header = headers[i];\n      if (header) {\n        if (Array.isArray(header)) {\n          applyHeaders(header, res);\n        } else if (header.key === 'Vary' && header.value) {\n          vary(res, header.value);\n        } else if (header.value) {\n          res.setHeader(header.key, header.value);\n        }\n      }\n    }\n  }\n\n  function cors(options, req, res, next) {\n    var headers = [],\n      method = req.method && req.method.toUpperCase && req.method.toUpperCase();\n\n    if (method === 'OPTIONS') {\n      // preflight\n      headers.push(configureOrigin(options, req));\n      headers.push(configureCredentials(options, req));\n      headers.push(configureMethods(options, req));\n      headers.push(configureAllowedHeaders(options, req));\n      headers.push(configureMaxAge(options, req));\n      headers.push(configureExposedHeaders(options, req));\n      applyHeaders(headers, res);\n\n      if (options.preflightContinue) {\n        next();\n      } else {\n        // Safari (and potentially other browsers) need content-length 0,\n        //   for 204 or they just hang waiting for a body\n        res.statusCode = options.optionsSuccessStatus;\n        res.setHeader('Content-Length', '0');\n        res.end();\n      }\n    } else {\n      // actual response\n      headers.push(configureOrigin(options, req));\n      headers.push(configureCredentials(options, req));\n      headers.push(configureExposedHeaders(options, req));\n      applyHeaders(headers, res);\n      next();\n    }\n  }\n\n  function middlewareWrapper(o) {\n    // if options are static (either via defaults or custom options passed in), wrap in a function\n    var optionsCallback = null;\n    if (typeof o === 'function') {\n      optionsCallback = o;\n    } else {\n      optionsCallback = function (req, cb) {\n        cb(null, o);\n      };\n    }\n\n    return function corsMiddleware(req, res, next) {\n      optionsCallback(req, function (err, options) {\n        if (err) {\n          next(err);\n        } else {\n          var corsOptions = assign({}, defaults, options);\n          var originCallback = null;\n          if (corsOptions.origin && typeof corsOptions.origin === 'function') {\n            originCallback = corsOptions.origin;\n          } else if (corsOptions.origin) {\n            originCallback = function (origin, cb) {\n              cb(null, corsOptions.origin);\n            };\n          }\n\n          if (originCallback) {\n            originCallback(req.headers.origin, function (err2, origin) {\n              if (err2 || !origin) {\n                next(err2);\n              } else {\n                corsOptions.origin = origin;\n                cors(corsOptions, req, res, next);\n              }\n            });\n          } else {\n            next();\n          }\n        }\n      });\n    };\n  }\n\n  // can pass either an options hash, an options delegate, or nothing\n  module.exports = middlewareWrapper;\n\n}());\n","/*!\n * depd\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar callSiteToString = require('./lib/compat').callSiteToString\nvar eventListenerCount = require('./lib/compat').eventListenerCount\nvar relative = require('path').relative\n\n/**\n * Module exports.\n */\n\nmodule.exports = depd\n\n/**\n * Get the path to base files on.\n */\n\nvar basePath = process.cwd()\n\n/**\n * Determine if namespace is contained in the string.\n */\n\nfunction containsNamespace (str, namespace) {\n  var vals = str.split(/[ ,]+/)\n  var ns = String(namespace).toLowerCase()\n\n  for (var i = 0; i < vals.length; i++) {\n    var val = vals[i]\n\n    // namespace contained\n    if (val && (val === '*' || val.toLowerCase() === ns)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Convert a data descriptor to accessor descriptor.\n */\n\nfunction convertDataDescriptorToAccessor (obj, prop, message) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n  var value = descriptor.value\n\n  descriptor.get = function getter () { return value }\n\n  if (descriptor.writable) {\n    descriptor.set = function setter (val) { return (value = val) }\n  }\n\n  delete descriptor.value\n  delete descriptor.writable\n\n  Object.defineProperty(obj, prop, descriptor)\n\n  return descriptor\n}\n\n/**\n * Create arguments string to keep arity.\n */\n\nfunction createArgumentsString (arity) {\n  var str = ''\n\n  for (var i = 0; i < arity; i++) {\n    str += ', arg' + i\n  }\n\n  return str.substr(2)\n}\n\n/**\n * Create stack string from stack.\n */\n\nfunction createStackString (stack) {\n  var str = this.name + ': ' + this.namespace\n\n  if (this.message) {\n    str += ' deprecated ' + this.message\n  }\n\n  for (var i = 0; i < stack.length; i++) {\n    str += '\\n    at ' + callSiteToString(stack[i])\n  }\n\n  return str\n}\n\n/**\n * Create deprecate for namespace in caller.\n */\n\nfunction depd (namespace) {\n  if (!namespace) {\n    throw new TypeError('argument namespace is required')\n  }\n\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n  var file = site[0]\n\n  function deprecate (message) {\n    // call to self as log\n    log.call(deprecate, message)\n  }\n\n  deprecate._file = file\n  deprecate._ignored = isignored(namespace)\n  deprecate._namespace = namespace\n  deprecate._traced = istraced(namespace)\n  deprecate._warned = Object.create(null)\n\n  deprecate.function = wrapfunction\n  deprecate.property = wrapproperty\n\n  return deprecate\n}\n\n/**\n * Determine if namespace is ignored.\n */\n\nfunction isignored (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.noDeprecation) {\n    // --no-deprecation support\n    return true\n  }\n\n  var str = process.env.NO_DEPRECATION || ''\n\n  // namespace ignored\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Determine if namespace is traced.\n */\n\nfunction istraced (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.traceDeprecation) {\n    // --trace-deprecation support\n    return true\n  }\n\n  var str = process.env.TRACE_DEPRECATION || ''\n\n  // namespace traced\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Display deprecation message.\n */\n\nfunction log (message, site) {\n  var haslisteners = eventListenerCount(process, 'deprecation') !== 0\n\n  // abort early if no destination\n  if (!haslisteners && this._ignored) {\n    return\n  }\n\n  var caller\n  var callFile\n  var callSite\n  var depSite\n  var i = 0\n  var seen = false\n  var stack = getStack()\n  var file = this._file\n\n  if (site) {\n    // provided site\n    depSite = site\n    callSite = callSiteLocation(stack[1])\n    callSite.name = depSite.name\n    file = callSite[0]\n  } else {\n    // get call site\n    i = 2\n    depSite = callSiteLocation(stack[i])\n    callSite = depSite\n  }\n\n  // get caller of deprecated thing in relation to file\n  for (; i < stack.length; i++) {\n    caller = callSiteLocation(stack[i])\n    callFile = caller[0]\n\n    if (callFile === file) {\n      seen = true\n    } else if (callFile === this._file) {\n      file = this._file\n    } else if (seen) {\n      break\n    }\n  }\n\n  var key = caller\n    ? depSite.join(':') + '__' + caller.join(':')\n    : undefined\n\n  if (key !== undefined && key in this._warned) {\n    // already warned\n    return\n  }\n\n  this._warned[key] = true\n\n  // generate automatic message from call site\n  var msg = message\n  if (!msg) {\n    msg = callSite === depSite || !callSite.name\n      ? defaultMessage(depSite)\n      : defaultMessage(callSite)\n  }\n\n  // emit deprecation if listeners exist\n  if (haslisteners) {\n    var err = DeprecationError(this._namespace, msg, stack.slice(i))\n    process.emit('deprecation', err)\n    return\n  }\n\n  // format and write message\n  var format = process.stderr.isTTY\n    ? formatColor\n    : formatPlain\n  var output = format.call(this, msg, caller, stack.slice(i))\n  process.stderr.write(output + '\\n', 'utf8')\n}\n\n/**\n * Get call site location as array.\n */\n\nfunction callSiteLocation (callSite) {\n  var file = callSite.getFileName() || '<anonymous>'\n  var line = callSite.getLineNumber()\n  var colm = callSite.getColumnNumber()\n\n  if (callSite.isEval()) {\n    file = callSite.getEvalOrigin() + ', ' + file\n  }\n\n  var site = [file, line, colm]\n\n  site.callSite = callSite\n  site.name = callSite.getFunctionName()\n\n  return site\n}\n\n/**\n * Generate a default message from the site.\n */\n\nfunction defaultMessage (site) {\n  var callSite = site.callSite\n  var funcName = site.name\n\n  // make useful anonymous name\n  if (!funcName) {\n    funcName = '<anonymous@' + formatLocation(site) + '>'\n  }\n\n  var context = callSite.getThis()\n  var typeName = context && callSite.getTypeName()\n\n  // ignore useless type name\n  if (typeName === 'Object') {\n    typeName = undefined\n  }\n\n  // make useful type name\n  if (typeName === 'Function') {\n    typeName = context.name || typeName\n  }\n\n  return typeName && callSite.getMethodName()\n    ? typeName + '.' + funcName\n    : funcName\n}\n\n/**\n * Format deprecation message without color.\n */\n\nfunction formatPlain (msg, caller, stack) {\n  var timestamp = new Date().toUTCString()\n\n  var formatted = timestamp +\n    ' ' + this._namespace +\n    ' deprecated ' + msg\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    at ' + callSiteToString(stack[i])\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' at ' + formatLocation(caller)\n  }\n\n  return formatted\n}\n\n/**\n * Format deprecation message with color.\n */\n\nfunction formatColor (msg, caller, stack) {\n  var formatted = '\\x1b[36;1m' + this._namespace + '\\x1b[22;39m' + // bold cyan\n    ' \\x1b[33;1mdeprecated\\x1b[22;39m' + // bold yellow\n    ' \\x1b[0m' + msg + '\\x1b[39m' // reset\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    \\x1b[36mat ' + callSiteToString(stack[i]) + '\\x1b[39m' // cyan\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' \\x1b[36m' + formatLocation(caller) + '\\x1b[39m' // cyan\n  }\n\n  return formatted\n}\n\n/**\n * Format call site location.\n */\n\nfunction formatLocation (callSite) {\n  return relative(basePath, callSite[0]) +\n    ':' + callSite[1] +\n    ':' + callSite[2]\n}\n\n/**\n * Get the stack as array of call sites.\n */\n\nfunction getStack () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = Math.max(10, limit)\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice this function off the top\n  var stack = obj.stack.slice(1)\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack\n}\n\n/**\n * Capture call site stack from v8.\n */\n\nfunction prepareObjectStackTrace (obj, stack) {\n  return stack\n}\n\n/**\n * Return a wrapped function in a deprecation message.\n */\n\nfunction wrapfunction (fn, message) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function')\n  }\n\n  var args = createArgumentsString(fn.length)\n  var deprecate = this // eslint-disable-line no-unused-vars\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  site.name = fn.name\n\n   // eslint-disable-next-line no-eval\n  var deprecatedfn = eval('(function (' + args + ') {\\n' +\n    '\"use strict\"\\n' +\n    'log.call(deprecate, message, site)\\n' +\n    'return fn.apply(this, arguments)\\n' +\n    '})')\n\n  return deprecatedfn\n}\n\n/**\n * Wrap property in a deprecation message.\n */\n\nfunction wrapproperty (obj, prop, message) {\n  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    throw new TypeError('argument obj must be object')\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n\n  if (!descriptor) {\n    throw new TypeError('must call property on owner object')\n  }\n\n  if (!descriptor.configurable) {\n    throw new TypeError('property must be configurable')\n  }\n\n  var deprecate = this\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  // set site name\n  site.name = prop\n\n  // convert data descriptor\n  if ('value' in descriptor) {\n    descriptor = convertDataDescriptorToAccessor(obj, prop, message)\n  }\n\n  var get = descriptor.get\n  var set = descriptor.set\n\n  // wrap getter\n  if (typeof get === 'function') {\n    descriptor.get = function getter () {\n      log.call(deprecate, message, site)\n      return get.apply(this, arguments)\n    }\n  }\n\n  // wrap setter\n  if (typeof set === 'function') {\n    descriptor.set = function setter () {\n      log.call(deprecate, message, site)\n      return set.apply(this, arguments)\n    }\n  }\n\n  Object.defineProperty(obj, prop, descriptor)\n}\n\n/**\n * Create DeprecationError for deprecation\n */\n\nfunction DeprecationError (namespace, message, stack) {\n  var error = new Error()\n  var stackString\n\n  Object.defineProperty(error, 'constructor', {\n    value: DeprecationError\n  })\n\n  Object.defineProperty(error, 'message', {\n    configurable: true,\n    enumerable: false,\n    value: message,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'name', {\n    enumerable: false,\n    configurable: true,\n    value: 'DeprecationError',\n    writable: true\n  })\n\n  Object.defineProperty(error, 'namespace', {\n    configurable: true,\n    enumerable: false,\n    value: namespace,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'stack', {\n    configurable: true,\n    enumerable: false,\n    get: function () {\n      if (stackString !== undefined) {\n        return stackString\n      }\n\n      // prepare stack trace\n      return (stackString = createStackString.call(this, stack))\n    },\n    set: function setter (val) {\n      stackString = val\n    }\n  })\n\n  return error\n}\n","/*!\n * depd\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = callSiteToString\n\n/**\n * Format a CallSite file location to a string.\n */\n\nfunction callSiteFileLocation (callSite) {\n  var fileName\n  var fileLocation = ''\n\n  if (callSite.isNative()) {\n    fileLocation = 'native'\n  } else if (callSite.isEval()) {\n    fileName = callSite.getScriptNameOrSourceURL()\n    if (!fileName) {\n      fileLocation = callSite.getEvalOrigin()\n    }\n  } else {\n    fileName = callSite.getFileName()\n  }\n\n  if (fileName) {\n    fileLocation += fileName\n\n    var lineNumber = callSite.getLineNumber()\n    if (lineNumber != null) {\n      fileLocation += ':' + lineNumber\n\n      var columnNumber = callSite.getColumnNumber()\n      if (columnNumber) {\n        fileLocation += ':' + columnNumber\n      }\n    }\n  }\n\n  return fileLocation || 'unknown source'\n}\n\n/**\n * Format a CallSite to a string.\n */\n\nfunction callSiteToString (callSite) {\n  var addSuffix = true\n  var fileLocation = callSiteFileLocation(callSite)\n  var functionName = callSite.getFunctionName()\n  var isConstructor = callSite.isConstructor()\n  var isMethodCall = !(callSite.isToplevel() || isConstructor)\n  var line = ''\n\n  if (isMethodCall) {\n    var methodName = callSite.getMethodName()\n    var typeName = getConstructorName(callSite)\n\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) !== 0) {\n        line += typeName + '.'\n      }\n\n      line += functionName\n\n      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {\n        line += ' [as ' + methodName + ']'\n      }\n    } else {\n      line += typeName + '.' + (methodName || '<anonymous>')\n    }\n  } else if (isConstructor) {\n    line += 'new ' + (functionName || '<anonymous>')\n  } else if (functionName) {\n    line += functionName\n  } else {\n    addSuffix = false\n    line += fileLocation\n  }\n\n  if (addSuffix) {\n    line += ' (' + fileLocation + ')'\n  }\n\n  return line\n}\n\n/**\n * Get constructor name of reviver.\n */\n\nfunction getConstructorName (obj) {\n  var receiver = obj.receiver\n  return (receiver.constructor && receiver.constructor.name) || null\n}\n","/*!\n * depd\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = eventListenerCount\n\n/**\n * Get the count of listeners on an event emitter of a specific type.\n */\n\nfunction eventListenerCount (emitter, type) {\n  return emitter.listeners(type).length\n}\n","/*!\n * depd\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar EventEmitter = require('events').EventEmitter\n\n/**\n * Module exports.\n * @public\n */\n\nlazyProperty(module.exports, 'callSiteToString', function callSiteToString () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  function prepareObjectStackTrace (obj, stack) {\n    return stack\n  }\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = 2\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice the stack\n  var stack = obj.stack.slice()\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack[0].toString ? toString : require('./callsite-tostring')\n})\n\nlazyProperty(module.exports, 'eventListenerCount', function eventListenerCount () {\n  return EventEmitter.listenerCount || require('./event-listener-count')\n})\n\n/**\n * Define a lazy property.\n */\n\nfunction lazyProperty (obj, prop, getter) {\n  function get () {\n    var val = getter()\n\n    Object.defineProperty(obj, prop, {\n      configurable: true,\n      enumerable: true,\n      value: val\n    })\n\n    return val\n  }\n\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: true,\n    get: get\n  })\n}\n\n/**\n * Call toString() on the obj\n */\n\nfunction toString (obj) {\n  return obj.toString()\n}\n","/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// Filename: formurlencoded.js\n// Timestamp: 2017.07.04-19:19:11 (last modified)\n// Author(s): Bumblehead (www.bumblehead.com), JBlashill (james@blashill.com), Jumper423 (jump.e.r@yandex.ru)\n\nexports.default = function (data) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var sorted = Boolean(opts.sorted),\n        skipIndex = Boolean(opts.skipIndex),\n        ignorenull = Boolean(opts.ignorenull),\n        encode = function encode(value) {\n        return String(value).replace(/(?:[\\0-\\x1F\"-&\\+-\\}\\x7F-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g, encodeURIComponent).replace(/ /g, '+').replace(/[!'()~\\*]/g, function (ch) {\n            return '%' + ch.charCodeAt().toString(16).slice(-2).toUpperCase();\n        });\n    },\n        keys = function keys(obj) {\n        var keyarr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.keys(obj);\n        return sorted ? keyarr.sort() : keyarr;\n    },\n        filterjoin = function filterjoin(arr) {\n        return arr.filter(function (e) {\n            return e;\n        }).join('&');\n    },\n        objnest = function objnest(name, obj) {\n        return filterjoin(keys(obj).map(function (key) {\n            return nest(name + '[' + key + ']', obj[key]);\n        }));\n    },\n        arrnest = function arrnest(name, arr) {\n        return arr.length ? filterjoin(arr.map(function (elem, index) {\n            return skipIndex ? nest(name + '[]', elem) : nest(name + '[' + index + ']', elem);\n        })) : encode(name + '[]');\n    },\n        nest = function nest(name, value) {\n        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : typeof value === 'undefined' ? 'undefined' : _typeof(value);\n        var f = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n        if (value === f) f = ignorenull ? f : encode(name) + '=' + f;else if (/string|number|boolean/.test(type)) f = encode(name) + '=' + encode(value);else if (Array.isArray(value)) f = arrnest(name, value);else if (type === 'object') f = objnest(name, value);\n\n        return f;\n    };\n\n    return data && filterjoin(keys(data).map(function (key) {\n        return nest(key, data[key]);\n    }));\n};","const CODES = {\n  JOSEAlgNotWhitelisted: 'ERR_JOSE_ALG_NOT_WHITELISTED',\n  JOSECritNotUnderstood: 'ERR_JOSE_CRIT_NOT_UNDERSTOOD',\n  JOSEInvalidEncoding: 'ERR_JOSE_INVALID_ENCODING',\n  JOSEMultiError: 'ERR_JOSE_MULTIPLE_ERRORS',\n  JOSENotSupported: 'ERR_JOSE_NOT_SUPPORTED',\n  JWEDecryptionFailed: 'ERR_JWE_DECRYPTION_FAILED',\n  JWEInvalid: 'ERR_JWE_INVALID',\n  JWKImportFailed: 'ERR_JWK_IMPORT_FAILED',\n  JWKInvalid: 'ERR_JWK_INVALID',\n  JWKKeySupport: 'ERR_JWK_KEY_SUPPORT',\n  JWKSNoMatchingKey: 'ERR_JWKS_NO_MATCHING_KEY',\n  JWSInvalid: 'ERR_JWS_INVALID',\n  JWSVerificationFailed: 'ERR_JWS_VERIFICATION_FAILED',\n  JWTClaimInvalid: 'ERR_JWT_CLAIM_INVALID',\n  JWTExpired: 'ERR_JWT_EXPIRED',\n  JWTMalformed: 'ERR_JWT_MALFORMED'\n}\n\nconst DEFAULT_MESSAGES = {\n  JWEDecryptionFailed: 'decryption operation failed',\n  JWEInvalid: 'JWE invalid',\n  JWKSNoMatchingKey: 'no matching key found in the KeyStore',\n  JWSInvalid: 'JWS invalid',\n  JWSVerificationFailed: 'signature verification failed'\n}\n\nclass JOSEError extends Error {\n  constructor (message) {\n    super(message)\n    if (message === undefined) {\n      this.message = DEFAULT_MESSAGES[this.constructor.name]\n    }\n    this.name = this.constructor.name\n    this.code = CODES[this.constructor.name]\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nconst isMulti = e => e instanceof JOSEMultiError\nclass JOSEMultiError extends JOSEError {\n  constructor (errors) {\n    super()\n    let i\n    while ((i = errors.findIndex(isMulti)) && i !== -1) {\n      errors.splice(i, 1, ...errors[i])\n    }\n    Object.defineProperty(this, 'errors', { value: errors })\n  }\n\n  * [Symbol.iterator] () {\n    for (const error of this.errors) {\n      yield error\n    }\n  }\n}\nmodule.exports.JOSEError = JOSEError\n\nmodule.exports.JOSEAlgNotWhitelisted = class JOSEAlgNotWhitelisted extends JOSEError {}\nmodule.exports.JOSECritNotUnderstood = class JOSECritNotUnderstood extends JOSEError {}\nmodule.exports.JOSEInvalidEncoding = class JOSEInvalidEncoding extends JOSEError {}\nmodule.exports.JOSEMultiError = JOSEMultiError\nmodule.exports.JOSENotSupported = class JOSENotSupported extends JOSEError {}\n\nmodule.exports.JWEDecryptionFailed = class JWEDecryptionFailed extends JOSEError {}\nmodule.exports.JWEInvalid = class JWEInvalid extends JOSEError {}\n\nmodule.exports.JWKImportFailed = class JWKImportFailed extends JOSEError {}\nmodule.exports.JWKInvalid = class JWKInvalid extends JOSEError {}\nmodule.exports.JWKKeySupport = class JWKKeySupport extends JOSEError {}\n\nmodule.exports.JWKSNoMatchingKey = class JWKSNoMatchingKey extends JOSEError {}\n\nmodule.exports.JWSInvalid = class JWSInvalid extends JOSEError {}\nmodule.exports.JWSVerificationFailed = class JWSVerificationFailed extends JOSEError {}\n\nclass JWTClaimInvalid extends JOSEError {\n  constructor (message, claim = 'unspecified', reason = 'unspecified') {\n    super(message)\n    this.claim = claim\n    this.reason = reason\n  }\n}\nmodule.exports.JWTClaimInvalid = JWTClaimInvalid\nmodule.exports.JWTExpired = class JWTExpired extends JWTClaimInvalid {}\nmodule.exports.JWTMalformed = class JWTMalformed extends JOSEError {}\n","const oids = require('./oids')\n\nmodule.exports = function () {\n  this.seq().obj(\n    this.key('algorithm').objid(oids),\n    this.key('parameters').optional().choice({ namedCurve: this.objid(oids), null: this.null_() })\n  )\n}\n","const oids = require('./oids')\n\nmodule.exports = function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).optional().choice({ namedCurve: this.objid(oids) }),\n    this.key('publicKey').explicit(1).optional().bitstr()\n  )\n}\n","const asn1 = require('@panva/asn1.js')\n\nconst types = new Map()\n\nconst AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', require('./algorithm_identifier'))\ntypes.set('AlgorithmIdentifier', AlgorithmIdentifier)\n\nconst ECPrivateKey = asn1.define('ECPrivateKey', require('./ec_private_key'))\ntypes.set('ECPrivateKey', ECPrivateKey)\n\nconst PrivateKeyInfo = asn1.define('PrivateKeyInfo', require('./private_key_info')(AlgorithmIdentifier))\ntypes.set('PrivateKeyInfo', PrivateKeyInfo)\n\nconst PublicKeyInfo = asn1.define('PublicKeyInfo', require('./public_key_info')(AlgorithmIdentifier))\ntypes.set('PublicKeyInfo', PublicKeyInfo)\n\nconst PrivateKey = asn1.define('PrivateKey', require('./private_key'))\ntypes.set('PrivateKey', PrivateKey)\n\nconst OneAsymmetricKey = asn1.define('OneAsymmetricKey', require('./one_asymmetric_key')(AlgorithmIdentifier, PrivateKey))\ntypes.set('OneAsymmetricKey', OneAsymmetricKey)\n\nconst RSAPrivateKey = asn1.define('RSAPrivateKey', require('./rsa_private_key'))\ntypes.set('RSAPrivateKey', RSAPrivateKey)\n\nconst RSAPublicKey = asn1.define('RSAPublicKey', require('./rsa_public_key'))\ntypes.set('RSAPublicKey', RSAPublicKey)\n\nmodule.exports = types\n","const oids = {\n  '1 2 840 10045 3 1 7': 'P-256',\n  '1 3 132 0 10': 'secp256k1',\n  '1 3 132 0 34': 'P-384',\n  '1 3 132 0 35': 'P-521',\n  '1 2 840 10045 2 1': 'ecPublicKey',\n  '1 2 840 113549 1 1 1': 'rsaEncryption',\n  '1 3 101 110': 'X25519',\n  '1 3 101 111': 'X448',\n  '1 3 101 112': 'Ed25519',\n  '1 3 101 113': 'Ed448'\n}\n\nmodule.exports = oids\n","module.exports = (AlgorithmIdentifier, PrivateKey) => function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('privateKey').use(PrivateKey)\n  )\n}\n","module.exports = function () {\n  this.octstr().contains().obj(\n    this.key('privateKey').octstr()\n  )\n}\n","module.exports = (AlgorithmIdentifier) => function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('privateKey').octstr()\n  )\n}\n","module.exports = AlgorithmIdentifier => function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('publicKey').bitstr()\n  )\n}\n","module.exports = function () {\n  this.seq().obj(\n    this.key('version').int({ 0: 'two-prime', 1: 'multi' }),\n    this.key('n').int(),\n    this.key('e').int(),\n    this.key('d').int(),\n    this.key('p').int(),\n    this.key('q').int(),\n    this.key('dp').int(),\n    this.key('dq').int(),\n    this.key('qi').int()\n  )\n}\n","module.exports = function () {\n  this.seq().obj(\n    this.key('n').int(),\n    this.key('e').int()\n  )\n}\n","let encode\nlet encodeBuffer\nif (Buffer.isEncoding('base64url')) {\n  encode = (input, encoding = 'utf8') => Buffer.from(input, encoding).toString('base64url')\n  encodeBuffer = (buf) => buf.toString('base64url')\n} else {\n  const fromBase64 = (base64) => base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_')\n  encode = (input, encoding = 'utf8') => fromBase64(Buffer.from(input, encoding).toString('base64'))\n  encodeBuffer = (buf) => fromBase64(buf.toString('base64'))\n}\n\nconst decodeToBuffer = (input) => {\n  return Buffer.from(input, 'base64')\n}\n\nconst decode = (input, encoding = 'utf8') => {\n  return decodeToBuffer(input).toString(encoding)\n}\n\nconst b64uJSON = {\n  encode: (input) => {\n    return encode(JSON.stringify(input))\n  },\n  decode: (input, encoding = 'utf8') => {\n    return JSON.parse(decode(input, encoding))\n  }\n}\n\nb64uJSON.decode.try = (input, encoding = 'utf8') => {\n  try {\n    return b64uJSON.decode(input, encoding)\n  } catch (err) {\n    return decode(input, encoding)\n  }\n}\n\nconst bnToBuf = (bn) => {\n  let hex = BigInt(bn).toString(16)\n  if (hex.length % 2) {\n    hex = `0${hex}`\n  }\n\n  const len = hex.length / 2\n  const u8 = new Uint8Array(len)\n\n  let i = 0\n  let j = 0\n  while (i < len) {\n    u8[i] = parseInt(hex.slice(j, j + 2), 16)\n    i += 1\n    j += 2\n  }\n\n  return u8\n}\n\nconst encodeBigInt = (bn) => encodeBuffer(Buffer.from(bnToBuf(bn)))\n\nmodule.exports.decode = decode\nmodule.exports.decodeToBuffer = decodeToBuffer\nmodule.exports.encode = encode\nmodule.exports.encodeBuffer = encodeBuffer\nmodule.exports.JSON = b64uJSON\nmodule.exports.encodeBigInt = encodeBigInt\n","module.exports.KEYOBJECT = Symbol('KEYOBJECT')\nmodule.exports.PRIVATE_MEMBERS = Symbol('PRIVATE_MEMBERS')\nmodule.exports.PUBLIC_MEMBERS = Symbol('PUBLIC_MEMBERS')\nmodule.exports.THUMBPRINT_MATERIAL = Symbol('THUMBPRINT_MATERIAL')\nmodule.exports.JWK_MEMBERS = Symbol('JWK_MEMBERS')\nmodule.exports.KEY_MANAGEMENT_ENCRYPT = Symbol('KEY_MANAGEMENT_ENCRYPT')\nmodule.exports.KEY_MANAGEMENT_DECRYPT = Symbol('KEY_MANAGEMENT_DECRYPT')\n\nconst USES_MAPPING = {\n  sig: new Set(['sign', 'verify']),\n  enc: new Set(['encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey'])\n}\nconst OPS = new Set([...USES_MAPPING.sig, ...USES_MAPPING.enc])\nconst USES = new Set(Object.keys(USES_MAPPING))\n\nmodule.exports.USES_MAPPING = USES_MAPPING\nmodule.exports.OPS = OPS\nmodule.exports.USES = USES\n","module.exports = obj => JSON.parse(JSON.stringify(obj))\n","const MAX_OCTET = 0x80\nconst CLASS_UNIVERSAL = 0\nconst PRIMITIVE_BIT = 0x20\nconst TAG_SEQ = 0x10\nconst TAG_INT = 0x02\nconst ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6)\nconst ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6)\n\nconst getParamSize = keySize => ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1)\n\nconst paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n}\n\nconst countPadding = (buf, start, stop) => {\n  let padding = 0\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding\n  }\n\n  const needsSign = buf[start + padding] >= MAX_OCTET\n  if (needsSign) {\n    --padding\n  }\n\n  return padding\n}\n\nmodule.exports.derToJose = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n  const maxEncodedParamLength = paramBytes + 1\n\n  const inputLength = signature.length\n\n  let offset = 0\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"')\n  }\n\n  let seqLength = signature[offset++]\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++]\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error(`\"seq\" specified length of ${seqLength}\", only ${inputLength - offset}\" remaining`)\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"')\n  }\n\n  const rLength = signature[offset++]\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`)\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const rOffset = offset\n  offset += rLength\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"')\n  }\n\n  const sLength = signature[offset++]\n\n  if (inputLength - offset !== sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`)\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const sOffset = offset\n  offset += sLength\n\n  if (offset !== inputLength) {\n    throw new Error(`Expected to consume entire buffer, but \"${inputLength - offset}\" bytes remain`)\n  }\n\n  const rPadding = paramBytes - rLength\n\n  const sPadding = paramBytes - sLength\n\n  const dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength)\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength)\n\n  offset = paramBytes\n\n  for (const o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength)\n\n  return dst\n}\n\nmodule.exports.joseToDer = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  const signatureBytes = signature.length\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`)\n  }\n\n  const rPadding = countPadding(signature, 0, paramBytes)\n  const sPadding = countPadding(signature, paramBytes, signature.length)\n  const rLength = paramBytes - rPadding\n  const sLength = paramBytes - sPadding\n\n  const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength\n\n  const shortLength = rsBytes < MAX_OCTET\n\n  const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes)\n\n  let offset = 0\n  dst[offset++] = ENCODED_TAG_SEQ\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET\t| 1 // eslint-disable-line no-tabs\n    // length, base 256\n    dst[offset++] = rsBytes & 0xff\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = rLength\n  if (rPadding < 0) {\n    dst[offset++] = 0\n    offset += signature.copy(dst, offset, 0, paramBytes)\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes)\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = sLength\n  if (sPadding < 0) {\n    dst[offset++] = 0\n    signature.copy(dst, offset, paramBytes)\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding)\n  }\n\n  return dst\n}\n","module.exports = (date) => Math.floor(date.getTime() / 1000)\n","const { randomBytes } = require('crypto')\n\nconst { IVLENGTHS } = require('../registry')\n\nmodule.exports = alg => randomBytes(IVLENGTHS.get(alg) / 8)\n","const errors = require('../errors')\nconst Key = require('../jwk/key/base')\nconst importKey = require('../jwk/import')\nconst { KeyStore } = require('../jwks/keystore')\n\nmodule.exports = (input, keyStoreAllowed = false) => {\n  if (input instanceof Key) {\n    return input\n  }\n\n  if (input instanceof KeyStore) {\n    if (!keyStoreAllowed) {\n      throw new TypeError('key argument for this operation must not be a JWKS.KeyStore instance')\n    }\n\n    return input\n  }\n\n  try {\n    return importKey(input)\n  } catch (err) {\n    if (err instanceof errors.JOSEError && !(err instanceof errors.JWKImportFailed)) {\n      throw err\n    }\n\n    let msg\n    if (keyStoreAllowed) {\n      msg = 'key must be an instance of a key instantiated by JWK.asKey, a valid JWK.asKey input, or a JWKS.KeyStore instance'\n    } else {\n      msg = 'key must be an instance of a key instantiated by JWK.asKey, or a valid JWK.asKey input'\n    }\n\n    throw new TypeError(msg)\n  }\n}\n","module.exports = (a = {}, b = {}) => {\n  const keysA = Object.keys(a)\n  const keysB = new Set(Object.keys(b))\n  return !keysA.some((ka) => keysB.has(ka))\n}\n","module.exports = a => !!a && a.constructor === Object\n","const { keyObjectSupported } = require('./runtime_support')\n\nlet createPublicKey\nlet createPrivateKey\nlet createSecretKey\nlet KeyObject\nlet asInput\n\nif (keyObjectSupported) {\n  ({ createPublicKey, createPrivateKey, createSecretKey, KeyObject } = require('crypto'))\n  asInput = (input) => input\n} else {\n  const { EOL } = require('os')\n\n  const errors = require('../errors')\n  const isObject = require('./is_object')\n  const asn1 = require('./asn1')\n  const toInput = Symbol('toInput')\n\n  const namedCurve = Symbol('namedCurve')\n\n  asInput = (keyObject, needsPublic) => {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic)\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic)\n  }\n\n  const pemToDer = pem => Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64')\n  const derToPem = (der, label) => `-----BEGIN ${label}-----${EOL}${(der.toString('base64').match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END ${label}-----`\n  const unsupported = (input) => {\n    const label = typeof input === 'string' ? input : `OID ${input.join('.')}`\n    throw new errors.JOSENotSupported(`${label} is not supported in your Node.js runtime version`)\n  }\n\n  KeyObject = class KeyObject {\n    export ({ cipher, passphrase, type, format } = {}) {\n      if (this._type === 'secret') {\n        return this._buffer\n      }\n\n      if (this._type === 'public') {\n        if (this.asymmetricKeyType === 'rsa') {\n          switch (type) {\n            case 'pkcs1':\n              if (format === 'pem') {\n                return this._pem\n              }\n\n              return pemToDer(this._pem)\n            case 'spki': {\n              const PublicKeyInfo = asn1.get('PublicKeyInfo')\n              const pem = PublicKeyInfo.encode({\n                algorithm: {\n                  algorithm: 'rsaEncryption',\n                  parameters: { type: 'null' }\n                },\n                publicKey: {\n                  unused: 0,\n                  data: pemToDer(this._pem)\n                }\n              }, 'pem', { label: 'PUBLIC KEY' })\n\n              return format === 'pem' ? pem : pemToDer(pem)\n            }\n            default:\n              throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n        }\n\n        if (this.asymmetricKeyType === 'ec') {\n          if (type !== 'spki') {\n            throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        }\n      }\n\n      if (this._type === 'private') {\n        if (passphrase !== undefined || cipher !== undefined) {\n          throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n        }\n\n        if (type === 'pkcs8') {\n          if (this._pkcs8) {\n            if (format === 'der' && typeof this._pkcs8 === 'string') {\n              return pemToDer(this._pkcs8)\n            }\n\n            if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n              return derToPem(this._pkcs8, 'PRIVATE KEY')\n            }\n\n            return this._pkcs8\n          }\n\n          if (this.asymmetricKeyType === 'rsa') {\n            const parsed = this._asn1\n            const RSAPrivateKey = asn1.get('RSAPrivateKey')\n            const privateKey = RSAPrivateKey.encode(parsed)\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'rsaEncryption',\n                parameters: { type: 'null' }\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            const parsed = this._asn1\n            const ECPrivateKey = asn1.get('ECPrivateKey')\n            const privateKey = ECPrivateKey.encode({\n              version: parsed.version,\n              privateKey: parsed.privateKey,\n              publicKey: parsed.publicKey\n            })\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: this._asn1.parameters\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n        }\n\n        if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else {\n          throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n        }\n      }\n    }\n\n    get type () {\n      return this._type\n    }\n\n    get asymmetricKeyType () {\n      return this._asymmetricKeyType\n    }\n\n    get symmetricKeySize () {\n      return this._symmetricKeySize\n    }\n\n    [toInput] (needsPublic) {\n      switch (this._type) {\n        case 'secret':\n          return this._buffer\n        case 'public':\n          return this._pem\n        default:\n          if (needsPublic) {\n            if (!('_pub' in this)) {\n              this._pub = createPublicKey(this)\n            }\n\n            return this._pub[toInput](false)\n          }\n\n          return this._pem\n      }\n    }\n  }\n\n  createSecretKey = (buffer) => {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance')\n    }\n\n    const keyObject = new KeyObject()\n    keyObject._buffer = Buffer.from(buffer)\n    keyObject._symmetricKeySize = buffer.length\n    keyObject._type = 'secret'\n\n    return keyObject\n  }\n\n  createPublicKey = (input) => {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(`Invalid key object type ${input.type}, expected private.`)\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec': {\n          const PublicKeyInfo = asn1.get('PublicKeyInfo')\n          const key = PublicKeyInfo.encode({\n            algorithm: {\n              algorithm: 'ecPublicKey',\n              parameters: input._asn1.parameters\n            },\n            publicKey: input._asn1.publicKey\n          })\n\n          return createPublicKey({ key, format: 'der', type: 'spki' })\n        }\n        case 'rsa': {\n          const RSAPublicKey = asn1.get('RSAPublicKey')\n          const key = RSAPublicKey.encode(input._asn1)\n          return createPublicKey({ key, format: 'der', type: 'pkcs1' })\n        }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki'\n          label = 'PUBLIC KEY'\n          break\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PUBLIC KEY'\n          break\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version')\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return createPublicKey(createPrivateKey(key))\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'spki': {\n        const PublicKeyInfo = asn1.get('PublicKeyInfo')\n        const parsed = PublicKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            keyObject = new KeyObject()\n            keyObject._asn1 = parsed\n            keyObject._asymmetricKeyType = 'ec'\n            keyObject._type = 'public'\n            keyObject._pem = PublicKeyInfo.encode(parsed, 'pem', { label: 'PUBLIC KEY' })\n\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPublicKey({ type, key: parsed.publicKey.data, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPublicKey = asn1.get('RSAPublicKey')\n        const parsed = RSAPublicKey.decode(key, format, { label })\n\n        // special case when private pkcs1 PEM / DER is used with createPublicKey\n        if (parsed.n === BigInt(0)) {\n          return createPublicKey(createPrivateKey({ key, format, type, passphrase }))\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'public'\n        keyObject._pem = RSAPublicKey.encode(parsed, 'pem', { label: 'RSA PUBLIC KEY' })\n\n        return keyObject\n      }\n      case 'pkcs8':\n      case 'sec1':\n        return createPublicKey(createPrivateKey({ format, key, type, passphrase }))\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n\n  createPrivateKey = (input, hints) => {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8'\n          label = 'PRIVATE KEY'\n          break\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1'\n          label = 'EC PRIVATE KEY'\n          break\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PRIVATE KEY'\n          break\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8': {\n        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n        const parsed = PrivateKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            type = 'sec1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' }, { [namedCurve]: parsed.algorithm.parameters.value })\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        keyObject._pkcs8 = key\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPrivateKey = asn1.get('RSAPrivateKey')\n        const parsed = RSAPrivateKey.decode(key, format, { label })\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'private'\n        keyObject._pem = RSAPrivateKey.encode(parsed, 'pem', { label: 'RSA PRIVATE KEY' })\n\n        return keyObject\n      }\n      case 'sec1': {\n        const ECPrivateKey = asn1.get('ECPrivateKey')\n        let parsed = ECPrivateKey.decode(key, format, { label })\n\n        if (!('parameters' in parsed) && !hints[namedCurve]) {\n          throw new Error('invalid sec1')\n        } else if (!('parameters' in parsed)) {\n          parsed = { ...parsed, parameters: { type: 'namedCurve', value: hints[namedCurve] } }\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'ec'\n        keyObject._type = 'private'\n        keyObject._pem = ECPrivateKey.encode(parsed, 'pem', { label: 'EC PRIVATE KEY' })\n\n        return keyObject\n      }\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n}\n\nmodule.exports = { createPublicKey, createPrivateKey, createSecretKey, KeyObject, asInput }\n","const { EOL } = require('os')\n\nconst errors = require('../errors')\n\nconst { keyObjectSupported } = require('./runtime_support')\nconst { createPublicKey } = require('./key_object')\nconst base64url = require('./base64url')\nconst asn1 = require('./asn1')\nconst computePrimes = require('./rsa_primes')\nconst { OKP_CURVES, EC_CURVES } = require('../registry')\n\nconst formatPem = (base64pem, descriptor) => `-----BEGIN ${descriptor} KEY-----${EOL}${(base64pem.match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END ${descriptor} KEY-----`\n\nconst okpToJWK = {\n  private (crv, keyObject) {\n    const der = keyObject.export({ type: 'pkcs8', format: 'der' })\n    const OneAsymmetricKey = asn1.get('OneAsymmetricKey')\n    const { privateKey: { privateKey: d } } = OneAsymmetricKey.decode(der)\n\n    return {\n      ...okpToJWK.public(crv, createPublicKey(keyObject)),\n      d: base64url.encodeBuffer(d)\n    }\n  },\n  public (crv, keyObject) {\n    const der = keyObject.export({ type: 'spki', format: 'der' })\n\n    const PublicKeyInfo = asn1.get('PublicKeyInfo')\n\n    const { publicKey: { data: x } } = PublicKeyInfo.decode(der)\n\n    return {\n      kty: 'OKP',\n      crv,\n      x: base64url.encodeBuffer(x)\n    }\n  }\n}\n\nconst keyObjectToJWK = {\n  rsa: {\n    private (keyObject) {\n      const der = keyObject.export({ type: 'pkcs8', format: 'der' })\n\n      const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n      const RSAPrivateKey = asn1.get('RSAPrivateKey')\n\n      const { privateKey } = PrivateKeyInfo.decode(der)\n      const { version, n, e, d, p, q, dp, dq, qi } = RSAPrivateKey.decode(privateKey)\n\n      if (version !== 'two-prime') {\n        throw new errors.JOSENotSupported('Private RSA keys with more than two primes are not supported')\n      }\n\n      return {\n        kty: 'RSA',\n        n: base64url.encodeBigInt(n),\n        e: base64url.encodeBigInt(e),\n        d: base64url.encodeBigInt(d),\n        p: base64url.encodeBigInt(p),\n        q: base64url.encodeBigInt(q),\n        dp: base64url.encodeBigInt(dp),\n        dq: base64url.encodeBigInt(dq),\n        qi: base64url.encodeBigInt(qi)\n      }\n    },\n    public (keyObject) {\n      const der = keyObject.export({ type: 'spki', format: 'der' })\n\n      const PublicKeyInfo = asn1.get('PublicKeyInfo')\n      const RSAPublicKey = asn1.get('RSAPublicKey')\n\n      const { publicKey: { data: publicKey } } = PublicKeyInfo.decode(der)\n      const { n, e } = RSAPublicKey.decode(publicKey)\n\n      return {\n        kty: 'RSA',\n        n: base64url.encodeBigInt(n),\n        e: base64url.encodeBigInt(e)\n      }\n    }\n  },\n  ec: {\n    private (keyObject) {\n      const der = keyObject.export({ type: 'pkcs8', format: 'der' })\n\n      const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n      const ECPrivateKey = asn1.get('ECPrivateKey')\n\n      const { privateKey, algorithm: { parameters: { value: crv } } } = PrivateKeyInfo.decode(der)\n      const { privateKey: d, publicKey } = ECPrivateKey.decode(privateKey)\n\n      if (typeof publicKey === 'undefined') {\n        if (keyObjectSupported) {\n          return {\n            ...keyObjectToJWK.ec.public(createPublicKey(keyObject)),\n            d: base64url.encodeBuffer(d)\n          }\n        }\n\n        throw new errors.JOSENotSupported('Private EC keys without the public key embedded are not supported in your Node.js runtime version')\n      }\n\n      const x = publicKey.data.slice(1, ((publicKey.data.length - 1) / 2) + 1)\n      const y = publicKey.data.slice(((publicKey.data.length - 1) / 2) + 1)\n\n      return {\n        kty: 'EC',\n        crv,\n        d: base64url.encodeBuffer(d),\n        x: base64url.encodeBuffer(x),\n        y: base64url.encodeBuffer(y)\n      }\n    },\n    public (keyObject) {\n      const der = keyObject.export({ type: 'spki', format: 'der' })\n\n      const PublicKeyInfo = asn1.get('PublicKeyInfo')\n\n      const { publicKey: { data: publicKey }, algorithm: { parameters: { value: crv } } } = PublicKeyInfo.decode(der)\n\n      const x = publicKey.slice(1, ((publicKey.length - 1) / 2) + 1)\n      const y = publicKey.slice(((publicKey.length - 1) / 2) + 1)\n\n      return {\n        kty: 'EC',\n        crv,\n        x: base64url.encodeBuffer(x),\n        y: base64url.encodeBuffer(y)\n      }\n    }\n  },\n  ed25519: {\n    private (keyObject) {\n      return okpToJWK.private('Ed25519', keyObject)\n    },\n    public (keyObject) {\n      return okpToJWK.public('Ed25519', keyObject)\n    }\n  },\n  ed448: {\n    private (keyObject) {\n      return okpToJWK.private('Ed448', keyObject)\n    },\n    public (keyObject) {\n      return okpToJWK.public('Ed448', keyObject)\n    }\n  },\n  x25519: {\n    private (keyObject) {\n      return okpToJWK.private('X25519', keyObject)\n    },\n    public (keyObject) {\n      return okpToJWK.public('X25519', keyObject)\n    }\n  },\n  x448: {\n    private (keyObject) {\n      return okpToJWK.private('X448', keyObject)\n    },\n    public (keyObject) {\n      return okpToJWK.public('X448', keyObject)\n    }\n  }\n}\n\nmodule.exports.keyObjectToJWK = (keyObject) => {\n  if (keyObject.type === 'private') {\n    return keyObjectToJWK[keyObject.asymmetricKeyType].private(keyObject)\n  }\n\n  return keyObjectToJWK[keyObject.asymmetricKeyType].public(keyObject)\n}\n\nconst concatEcPublicKey = (x, y) => ({\n  unused: 0,\n  data: Buffer.concat([\n    Buffer.alloc(1, 4),\n    base64url.decodeToBuffer(x),\n    base64url.decodeToBuffer(y)\n  ])\n})\n\nconst jwkToPem = {\n  RSA: {\n    private (jwk, { calculateMissingRSAPrimes }) {\n      const RSAPrivateKey = asn1.get('RSAPrivateKey')\n\n      if ('oth' in jwk) {\n        throw new errors.JOSENotSupported('Private RSA keys with more than two primes are not supported')\n      }\n\n      if (jwk.p || jwk.q || jwk.dp || jwk.dq || jwk.qi) {\n        if (!(jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi)) {\n          throw new errors.JWKInvalid('all other private key parameters must be present when any one of them is present')\n        }\n      } else if (calculateMissingRSAPrimes) {\n        jwk = computePrimes(jwk)\n      } else if (!calculateMissingRSAPrimes) {\n        throw new errors.JOSENotSupported('importing private RSA keys without all other private key parameters is not enabled, see documentation and its advisory on how and when its ok to enable it')\n      }\n\n      return RSAPrivateKey.encode({\n        version: 0,\n        n: BigInt(`0x${base64url.decodeToBuffer(jwk.n).toString('hex')}`),\n        e: BigInt(`0x${base64url.decodeToBuffer(jwk.e).toString('hex')}`),\n        d: BigInt(`0x${base64url.decodeToBuffer(jwk.d).toString('hex')}`),\n        p: BigInt(`0x${base64url.decodeToBuffer(jwk.p).toString('hex')}`),\n        q: BigInt(`0x${base64url.decodeToBuffer(jwk.q).toString('hex')}`),\n        dp: BigInt(`0x${base64url.decodeToBuffer(jwk.dp).toString('hex')}`),\n        dq: BigInt(`0x${base64url.decodeToBuffer(jwk.dq).toString('hex')}`),\n        qi: BigInt(`0x${base64url.decodeToBuffer(jwk.qi).toString('hex')}`)\n      }, 'pem', { label: 'RSA PRIVATE KEY' })\n    },\n    public (jwk) {\n      const RSAPublicKey = asn1.get('RSAPublicKey')\n\n      return RSAPublicKey.encode({\n        version: 0,\n        n: BigInt(`0x${base64url.decodeToBuffer(jwk.n).toString('hex')}`),\n        e: BigInt(`0x${base64url.decodeToBuffer(jwk.e).toString('hex')}`)\n      }, 'pem', { label: 'RSA PUBLIC KEY' })\n    }\n  },\n  EC: {\n    private (jwk) {\n      const ECPrivateKey = asn1.get('ECPrivateKey')\n\n      return ECPrivateKey.encode({\n        version: 1,\n        privateKey: base64url.decodeToBuffer(jwk.d),\n        parameters: { type: 'namedCurve', value: jwk.crv },\n        publicKey: concatEcPublicKey(jwk.x, jwk.y)\n      }, 'pem', { label: 'EC PRIVATE KEY' })\n    },\n    public (jwk) {\n      const PublicKeyInfo = asn1.get('PublicKeyInfo')\n\n      return PublicKeyInfo.encode({\n        algorithm: {\n          algorithm: 'ecPublicKey',\n          parameters: { type: 'namedCurve', value: jwk.crv }\n        },\n        publicKey: concatEcPublicKey(jwk.x, jwk.y)\n      }, 'pem', { label: 'PUBLIC KEY' })\n    }\n  },\n  OKP: {\n    private (jwk) {\n      const OneAsymmetricKey = asn1.get('OneAsymmetricKey')\n\n      const b64 = OneAsymmetricKey.encode({\n        version: 0,\n        privateKey: { privateKey: base64url.decodeToBuffer(jwk.d) },\n        algorithm: { algorithm: jwk.crv }\n      }, 'der')\n\n      // TODO: WHYYY? https://github.com/indutny/asn1.js/issues/110\n      b64.write('04', 12, 1, 'hex')\n\n      return formatPem(b64.toString('base64'), 'PRIVATE')\n    },\n    public (jwk) {\n      const PublicKeyInfo = asn1.get('PublicKeyInfo')\n\n      return PublicKeyInfo.encode({\n        algorithm: { algorithm: jwk.crv },\n        publicKey: {\n          unused: 0,\n          data: base64url.decodeToBuffer(jwk.x)\n        }\n      }, 'pem', { label: 'PUBLIC KEY' })\n    }\n  }\n}\n\nmodule.exports.jwkToPem = (jwk, { calculateMissingRSAPrimes = false } = {}) => {\n  switch (jwk.kty) {\n    case 'EC':\n      if (!EC_CURVES.has(jwk.crv)) {\n        throw new errors.JOSENotSupported(`unsupported EC key curve: ${jwk.crv}`)\n      }\n      break\n    case 'OKP':\n      if (!OKP_CURVES.has(jwk.crv)) {\n        throw new errors.JOSENotSupported(`unsupported OKP key curve: ${jwk.crv}`)\n      }\n      break\n    case 'RSA':\n      break\n    default:\n      throw new errors.JOSENotSupported(`unsupported key type: ${jwk.kty}`)\n  }\n\n  if (jwk.d) {\n    return jwkToPem[jwk.kty].private(jwk, { calculateMissingRSAPrimes })\n  }\n\n  return jwkToPem[jwk.kty].public(jwk)\n}\n","module.exports = alg => `sha${alg.substr(2, 3)}`\n","const { randomBytes } = require('crypto')\n\nconst base64url = require('./base64url')\nconst errors = require('../errors')\n\nconst ZERO = BigInt(0)\nconst ONE = BigInt(1)\nconst TWO = BigInt(2)\n\nconst toJWKParameter = (n) => {\n  const hex = n.toString(16)\n  return base64url.encodeBuffer(Buffer.from(hex.length % 2 ? `0${hex}` : hex, 'hex'))\n}\nconst fromBuffer = buf => BigInt(`0x${buf.toString('hex')}`)\nconst bitLength = n => n.toString(2).length\n\nconst eGcdX = (a, b) => {\n  let x = ZERO\n  let y = ONE\n  let u = ONE\n  let v = ZERO\n\n  while (a !== ZERO) {\n    const q = b / a\n    const r = b % a\n    const m = x - (u * q)\n    const n = y - (v * q)\n    b = a\n    a = r\n    x = u\n    y = v\n    u = m\n    v = n\n  }\n  return x\n}\n\nconst gcd = (a, b) => {\n  let shift = ZERO\n  while (!((a | b) & ONE)) {\n    a >>= ONE\n    b >>= ONE\n    shift++\n  }\n  while (!(a & ONE)) {\n    a >>= ONE\n  }\n  do {\n    while (!(b & ONE)) {\n      b >>= ONE\n    }\n    if (a > b) {\n      const x = a\n      a = b\n      b = x\n    }\n    b -= a\n  } while (b)\n\n  return a << shift\n}\n\nconst modPow = (a, b, n) => {\n  a = toZn(a, n)\n  let result = ONE\n  let x = a\n  while (b > 0) {\n    const leastSignificantBit = b % TWO\n    b = b / TWO\n    if (leastSignificantBit === ONE) {\n      result = result * x\n      result = result % n\n    }\n    x = x * x\n    x = x % n\n  }\n  return result\n}\n\nconst randBetween = (min, max) => {\n  const interval = max - min\n  const bitLen = bitLength(interval)\n  let rnd\n  do {\n    rnd = fromBuffer(randBits(bitLen))\n  } while (rnd > interval)\n  return rnd + min\n}\n\nconst randBits = (bitLength) => {\n  const byteLength = Math.ceil(bitLength / 8)\n  const rndBytes = randomBytes(byteLength)\n  // Fill with 0's the extra bits\n  rndBytes[0] = rndBytes[0] & (2 ** (bitLength % 8) - 1)\n  return rndBytes\n}\n\nconst toZn = (a, n) => {\n  a = a % n\n  return (a < 0) ? a + n : a\n}\n\nconst odd = (n) => {\n  let r = n\n  while (r % TWO === ZERO) {\n    r = r / TWO\n  }\n  return r\n}\n\n// not sold on these values\nconst maxCountWhileNoY = 30\nconst maxCountWhileInot0 = 22\n\nconst getPrimeFactors = (e, d, n) => {\n  const r = odd(e * d - ONE)\n\n  let countWhileNoY = 0\n  let y\n  do {\n    countWhileNoY++\n    if (countWhileNoY === maxCountWhileNoY) {\n      throw new errors.JWKImportFailed('failed to calculate missing primes')\n    }\n\n    let countWhileInot0 = 0\n    let i = modPow(randBetween(TWO, n), r, n)\n    let o = ZERO\n    while (i !== ONE) {\n      countWhileInot0++\n      if (countWhileInot0 === maxCountWhileInot0) {\n        throw new errors.JWKImportFailed('failed to calculate missing primes')\n      }\n      o = i\n      i = (i * i) % n\n    }\n    if (o !== (n - ONE)) {\n      y = o\n    }\n  } while (!y)\n\n  const p = gcd(y - ONE, n)\n  const q = n / p\n\n  return p > q ? { p, q } : { p: q, q: p }\n}\n\nmodule.exports = (jwk) => {\n  const e = fromBuffer(base64url.decodeToBuffer(jwk.e))\n  const d = fromBuffer(base64url.decodeToBuffer(jwk.d))\n  const n = fromBuffer(base64url.decodeToBuffer(jwk.n))\n\n  if (d >= n) {\n    throw new errors.JWKInvalid('invalid RSA private exponent')\n  }\n\n  const { p, q } = getPrimeFactors(e, d, n)\n  const dp = d % (p - ONE)\n  const dq = d % (q - ONE)\n  const qi = toZn(eGcdX(toZn(q, p), p), p)\n\n  return {\n    ...jwk,\n    p: toJWKParameter(p),\n    q: toJWKParameter(q),\n    dp: toJWKParameter(dp),\n    dq: toJWKParameter(dq),\n    qi: toJWKParameter(qi)\n  }\n}\n","const { diffieHellman, KeyObject, sign, verify } = require('crypto')\n\nconst [major, minor] = process.version.substr(1).split('.').map(x => parseInt(x, 10))\n\nmodule.exports = {\n  oaepHashSupported: major > 12 || (major === 12 && minor >= 9),\n  keyObjectSupported: !!KeyObject && major >= 12,\n  edDSASupported: !!sign && !!verify,\n  dsaEncodingSupported: major > 13 || (major === 13 && minor >= 2) || (major === 12 && minor >= 16),\n  improvedDH: !!diffieHellman\n}\n","const minute = 60\nconst hour = minute * 60\nconst day = hour * 24\nconst week = day * 7\nconst year = day * 365.25\n\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i\n\nmodule.exports = (str) => {\n  const matched = REGEX.exec(str)\n\n  if (!matched) {\n    throw new TypeError(`invalid time period format (\"${str}\")`)\n  }\n\n  const value = parseFloat(matched[1])\n  const unit = matched[2].toLowerCase()\n\n  switch (unit) {\n    case 'sec':\n    case 'secs':\n    case 'second':\n    case 'seconds':\n    case 's':\n      return Math.round(value)\n    case 'minute':\n    case 'minutes':\n    case 'min':\n    case 'mins':\n    case 'm':\n      return Math.round(value * minute)\n    case 'hour':\n    case 'hours':\n    case 'hr':\n    case 'hrs':\n    case 'h':\n      return Math.round(value * hour)\n    case 'day':\n    case 'days':\n    case 'd':\n      return Math.round(value * day)\n    case 'week':\n    case 'weeks':\n    case 'w':\n      return Math.round(value * week)\n    case 'year':\n    case 'years':\n    case 'yr':\n    case 'yrs':\n    case 'y':\n      return Math.round(value * year)\n  }\n}\n","const { timingSafeEqual: TSE } = require('crypto')\n\nconst paddedBuffer = (input, length) => {\n  if (input.length === length) {\n    return input\n  }\n\n  const buffer = Buffer.alloc(length)\n  input.copy(buffer)\n  return buffer\n}\n\nconst timingSafeEqual = (a, b) => {\n  const length = Math.max(a.length, b.length)\n  return TSE(paddedBuffer(a, length), paddedBuffer(b, length))\n}\n\nmodule.exports = timingSafeEqual\n","const MAX_INT32 = Math.pow(2, 32)\n\nmodule.exports = (value, buf = Buffer.allocUnsafe(8)) => {\n  const high = Math.floor(value / MAX_INT32)\n  const low = value % MAX_INT32\n\n  buf.writeUInt32BE(high, 0)\n  buf.writeUInt32BE(low, 4)\n  return buf\n}\n","const { JOSECritNotUnderstood, JWSInvalid } = require('../errors')\n\nconst DEFINED = new Set([\n  'alg', 'jku', 'jwk', 'kid', 'x5u', 'x5c', 'x5t', 'x5t#S256', 'typ', 'cty',\n  'crit', 'enc', 'zip', 'epk', 'apu', 'apv', 'iv', 'tag', 'p2s', 'p2c'\n])\n\nmodule.exports = function validateCrit (Err, protectedHeader, unprotectedHeader, understood) {\n  if (protectedHeader && 'crit' in protectedHeader) {\n    if (\n      !Array.isArray(protectedHeader.crit) ||\n      protectedHeader.crit.length === 0 ||\n      protectedHeader.crit.some(s => typeof s !== 'string' || !s)\n    ) {\n      throw new Err('\"crit\" Header Parameter MUST be an array of non-empty strings when present')\n    }\n    const whitelisted = new Set(understood)\n    const combined = { ...protectedHeader, ...unprotectedHeader }\n    protectedHeader.crit.forEach((parameter) => {\n      if (DEFINED.has(parameter)) {\n        throw new Err(`The critical list contains a non-extension Header Parameter ${parameter}`)\n      }\n      if (!whitelisted.has(parameter)) {\n        throw new JOSECritNotUnderstood(`critical \"${parameter}\" is not understood`)\n      }\n      if (parameter === 'b64') {\n        if (!('b64' in protectedHeader)) {\n          throw new JWSInvalid('\"b64\" critical parameter must be integrity protected')\n        }\n        if (typeof protectedHeader.b64 !== 'boolean') {\n          throw new JWSInvalid('\"b64\" critical parameter must be a boolean')\n        }\n      } else if (!(parameter in combined)) {\n        throw new Err(`critical parameter \"${parameter}\" is missing`)\n      }\n    })\n  }\n  if (unprotectedHeader && 'crit' in unprotectedHeader) {\n    throw new Err('\"crit\" Header Parameter MUST be integrity protected when present')\n  }\n}\n","module.exports = {\n  JWE: require('./jwe'),\n  JWK: require('./jwk'),\n  JWKS: require('./jwks'),\n  JWS: require('./jws'),\n  JWT: require('./jwt'),\n  errors: require('./errors')\n}\n","const { createCipheriv, createDecipheriv, getCiphers } = require('crypto')\n\nconst uint64be = require('../help/uint64be')\nconst timingSafeEqual = require('../help/timing_safe_equal')\nconst { KEYOBJECT } = require('../help/consts')\nconst { JWEInvalid, JWEDecryptionFailed } = require('../errors')\n\nconst checkInput = function (size, iv, tag) {\n  if (iv.length !== 16) {\n    throw new JWEInvalid('invalid iv')\n  }\n  if (arguments.length === 3) {\n    if (tag.length !== size / 8) {\n      throw new JWEInvalid('invalid tag')\n    }\n  }\n}\n\nconst encrypt = (size, sign, { [KEYOBJECT]: keyObject }, cleartext, { iv, aad = Buffer.alloc(0) }) => {\n  const key = keyObject.export()\n  checkInput(size, iv)\n\n  const keySize = size / 8\n  const encKey = key.slice(keySize)\n  const cipher = createCipheriv(`aes-${size}-cbc`, encKey, iv)\n  const ciphertext = Buffer.concat([cipher.update(cleartext), cipher.final()])\n  const macData = Buffer.concat([aad, iv, ciphertext, uint64be(aad.length * 8)])\n\n  const macKey = key.slice(0, keySize)\n  const tag = sign({ [KEYOBJECT]: macKey }, macData).slice(0, keySize)\n\n  return { ciphertext, tag }\n}\n\nconst decrypt = (size, sign, { [KEYOBJECT]: keyObject }, ciphertext, { iv, tag = Buffer.alloc(0), aad = Buffer.alloc(0) }) => {\n  checkInput(size, iv, tag)\n\n  const keySize = size / 8\n  const key = keyObject.export()\n  const encKey = key.slice(keySize)\n  const macKey = key.slice(0, keySize)\n\n  const macData = Buffer.concat([aad, iv, ciphertext, uint64be(aad.length * 8)])\n  const expectedTag = sign({ [KEYOBJECT]: macKey }, macData, tag).slice(0, keySize)\n  const macCheckPassed = timingSafeEqual(tag, expectedTag)\n\n  if (!macCheckPassed) {\n    throw new JWEDecryptionFailed()\n  }\n\n  let cleartext\n  try {\n    const cipher = createDecipheriv(`aes-${size}-cbc`, encKey, iv)\n    cleartext = Buffer.concat([cipher.update(ciphertext), cipher.final()])\n  } catch (err) {}\n\n  if (!cleartext) {\n    throw new JWEDecryptionFailed()\n  }\n\n  return cleartext\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['A128CBC-HS256', 'A192CBC-HS384', 'A256CBC-HS512'].forEach((jwaAlg) => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10)\n    const sign = JWA.sign.get(`HS${size * 2}`)\n    if (getCiphers().includes(`aes-${size}-cbc`)) {\n      JWA.encrypt.set(jwaAlg, encrypt.bind(undefined, size, sign))\n      JWA.decrypt.set(jwaAlg, decrypt.bind(undefined, size, sign))\n      JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length / 2 === size\n    }\n  })\n}\n","const { createCipheriv, createDecipheriv, getCiphers } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst { JWEInvalid, JWEDecryptionFailed } = require('../errors')\nconst { asInput } = require('../help/key_object')\n\nconst checkInput = function (size, iv, tag) {\n  if (iv.length !== 12) {\n    throw new JWEInvalid('invalid iv')\n  }\n  if (arguments.length === 3) {\n    if (tag.length !== 16) {\n      throw new JWEInvalid('invalid tag')\n    }\n  }\n}\n\nconst encrypt = (size, { [KEYOBJECT]: keyObject }, cleartext, { iv, aad = Buffer.alloc(0) }) => {\n  const key = asInput(keyObject, false)\n  checkInput(size, iv)\n\n  const cipher = createCipheriv(`aes-${size}-gcm`, key, iv, { authTagLength: 16 })\n  cipher.setAAD(aad)\n\n  const ciphertext = Buffer.concat([cipher.update(cleartext), cipher.final()])\n  const tag = cipher.getAuthTag()\n\n  return { ciphertext, tag }\n}\n\nconst decrypt = (size, { [KEYOBJECT]: keyObject }, ciphertext, { iv, tag = Buffer.alloc(0), aad = Buffer.alloc(0) }) => {\n  const key = asInput(keyObject, false)\n  checkInput(size, iv, tag)\n\n  try {\n    const cipher = createDecipheriv(`aes-${size}-gcm`, key, iv, { authTagLength: 16 })\n    cipher.setAuthTag(tag)\n    cipher.setAAD(aad)\n\n    return Buffer.concat([cipher.update(ciphertext), cipher.final()])\n  } catch (err) {\n    throw new JWEDecryptionFailed()\n  }\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['A128GCM', 'A192GCM', 'A256GCM'].forEach((jwaAlg) => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10)\n    if (getCiphers().includes(`aes-${size}-gcm`)) {\n      JWA.encrypt.set(jwaAlg, encrypt.bind(undefined, size))\n      JWA.decrypt.set(jwaAlg, decrypt.bind(undefined, size))\n      JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length === size\n    }\n  })\n}\n","const generateIV = require('../help/generate_iv')\nconst base64url = require('../help/base64url')\n\nmodule.exports = (JWA, JWK) => {\n  ['A128GCMKW', 'A192GCMKW', 'A256GCMKW'].forEach((jwaAlg) => {\n    const encAlg = jwaAlg.substr(0, 7)\n    const size = parseInt(jwaAlg.substr(1, 3), 10)\n    const encrypt = JWA.encrypt.get(encAlg)\n    const decrypt = JWA.decrypt.get(encAlg)\n\n    if (encrypt && decrypt) {\n      JWA.keyManagementEncrypt.set(jwaAlg, (key, payload) => {\n        const iv = generateIV(jwaAlg)\n        const { ciphertext, tag } = encrypt(key, payload, { iv })\n        return {\n          wrapped: ciphertext,\n          header: { tag: base64url.encodeBuffer(tag), iv: base64url.encodeBuffer(iv) }\n        }\n      })\n      JWA.keyManagementDecrypt.set(jwaAlg, decrypt)\n      JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length === size\n    }\n  })\n}\n","const { createCipheriv, createDecipheriv, getCiphers } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst { asInput } = require('../help/key_object')\n\nconst checkInput = (data) => {\n  if (data !== undefined && data.length % 8 !== 0) {\n    throw new Error('invalid data length')\n  }\n}\n\nconst wrapKey = (alg, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, false)\n  const cipher = createCipheriv(alg, key, Buffer.alloc(8, 'a6', 'hex'))\n\n  return { wrapped: Buffer.concat([cipher.update(payload), cipher.final()]) }\n}\n\nconst unwrapKey = (alg, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, false)\n  checkInput(payload)\n  const cipher = createDecipheriv(alg, key, Buffer.alloc(8, 'a6', 'hex'))\n\n  return Buffer.concat([cipher.update(payload), cipher.final()])\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['A128KW', 'A192KW', 'A256KW'].forEach((jwaAlg) => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10)\n    const alg = `aes${size}-wrap`\n    if (getCiphers().includes(alg)) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, alg))\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, alg))\n      JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length === size\n    }\n  })\n}\n","const { improvedDH } = require('../../help/runtime_support')\n\nif (improvedDH) {\n  const { diffieHellman } = require('crypto')\n\n  const { KeyObject } = require('../../help/key_object')\n  const importKey = require('../../jwk/import')\n\n  module.exports = ({ keyObject: privateKey }, publicKey) => {\n    if (!(publicKey instanceof KeyObject)) {\n      ({ keyObject: publicKey } = importKey(publicKey))\n    }\n\n    return diffieHellman({ privateKey, publicKey })\n  }\n} else {\n  const { createECDH, constants: { POINT_CONVERSION_UNCOMPRESSED } } = require('crypto')\n\n  const base64url = require('../../help/base64url')\n\n  const crvToCurve = (crv) => {\n    switch (crv) {\n      case 'P-256':\n        return 'prime256v1'\n      case 'P-384':\n        return 'secp384r1'\n      case 'P-521':\n        return 'secp521r1'\n    }\n  }\n\n  const UNCOMPRESSED = Buffer.alloc(1, POINT_CONVERSION_UNCOMPRESSED)\n  const pubToBuffer = (x, y) => Buffer.concat([UNCOMPRESSED, base64url.decodeToBuffer(x), base64url.decodeToBuffer(y)])\n\n  module.exports = ({ crv, d }, { x, y }) => {\n    const curve = crvToCurve(crv)\n    const exchange = createECDH(curve)\n\n    exchange.setPrivateKey(base64url.decodeToBuffer(d))\n\n    return exchange.computeSecret(pubToBuffer(x, y))\n  }\n}\n","const { createHash } = require('crypto')\nconst ecdhComputeSecret = require('./compute_secret')\n\nconst concat = (key, length, value) => {\n  const iterations = Math.ceil(length / 32)\n  let res\n\n  for (let iter = 1; iter <= iterations; iter++) {\n    const buf = Buffer.allocUnsafe(4 + key.length + value.length)\n    buf.writeUInt32BE(iter, 0)\n    key.copy(buf, 4)\n    value.copy(buf, 4 + key.length)\n    if (!res) {\n      res = createHash('sha256').update(buf).digest()\n    } else {\n      res = Buffer.concat([res, createHash('sha256').update(buf).digest()])\n    }\n  }\n\n  return res.slice(0, length)\n}\n\nconst uint32be = (value, buf = Buffer.allocUnsafe(4)) => {\n  buf.writeUInt32BE(value)\n  return buf\n}\n\nconst lengthAndInput = input => Buffer.concat([uint32be(input.length), input])\n\nmodule.exports = (alg, keyLen, privKey, pubKey, { apu = Buffer.alloc(0), apv = Buffer.alloc(0) } = {}, computeSecret = ecdhComputeSecret) => {\n  const value = Buffer.concat([\n    lengthAndInput(Buffer.from(alg)),\n    lengthAndInput(apu),\n    lengthAndInput(apv),\n    uint32be(keyLen)\n  ])\n\n  const sharedSecret = computeSecret(privKey, pubKey)\n  return concat(sharedSecret, keyLen / 8, value)\n}\n","const { improvedDH } = require('../../help/runtime_support')\nconst { KEYLENGTHS } = require('../../registry')\nconst { generateSync } = require('../../jwk/generate')\n\nconst derive = require('./derive')\n\nconst wrapKey = (key, payload, { enc }) => {\n  const epk = generateSync(key.kty, key.crv)\n\n  const derivedKey = derive(enc, KEYLENGTHS.get(enc), epk, key)\n\n  return {\n    wrapped: derivedKey,\n    header: { epk: { kty: key.kty, crv: key.crv, x: epk.x, y: epk.y } }\n  }\n}\n\nconst unwrapKey = (key, payload, header) => {\n  const { enc, epk } = header\n  return derive(enc, KEYLENGTHS.get(enc), key, epk, header)\n}\n\nmodule.exports = (JWA, JWK) => {\n  JWA.keyManagementEncrypt.set('ECDH-ES', wrapKey)\n  JWA.keyManagementDecrypt.set('ECDH-ES', unwrapKey)\n  JWK.EC.deriveKey['ECDH-ES'] = key => (key.use === 'enc' || key.use === undefined) && key.crv !== 'secp256k1'\n\n  if (improvedDH) {\n    JWK.OKP.deriveKey['ECDH-ES'] = key => (key.use === 'enc' || key.use === undefined) && key.keyObject.asymmetricKeyType.startsWith('x')\n  }\n}\n","const { improvedDH } = require('../../help/runtime_support')\nconst { KEYOBJECT } = require('../../help/consts')\nconst { generateSync } = require('../../jwk/generate')\nconst { ECDH_DERIVE_LENGTHS } = require('../../registry')\n\nconst derive = require('./derive')\n\nconst wrapKey = (wrap, derive, key, payload) => {\n  const epk = generateSync(key.kty, key.crv)\n\n  const derivedKey = derive(epk, key, payload)\n\n  const result = wrap({ [KEYOBJECT]: derivedKey }, payload)\n  result.header = result.header || {}\n  Object.assign(result.header, { epk: { kty: key.kty, crv: key.crv, x: epk.x, y: epk.y } })\n\n  return result\n}\n\nconst unwrapKey = (unwrap, derive, key, payload, header) => {\n  const { epk } = header\n  const derivedKey = derive(key, epk, header)\n\n  return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW'].forEach((jwaAlg) => {\n    const kw = jwaAlg.substr(-6)\n    const kwWrap = JWA.keyManagementEncrypt.get(kw)\n    const kwUnwrap = JWA.keyManagementDecrypt.get(kw)\n    const keylen = parseInt(jwaAlg.substr(9, 3), 10)\n    ECDH_DERIVE_LENGTHS.set(jwaAlg, keylen)\n\n    if (kwWrap && kwUnwrap) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, kwWrap, derive.bind(undefined, jwaAlg, keylen)))\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, kwUnwrap, derive.bind(undefined, jwaAlg, keylen)))\n      JWK.EC.deriveKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.crv !== 'secp256k1'\n\n      if (improvedDH) {\n        JWK.OKP.deriveKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.keyObject.asymmetricKeyType.startsWith('x')\n      }\n    }\n  })\n}\nmodule.exports.wrapKey = wrapKey\nmodule.exports.unwrapKey = unwrapKey\n","const { sign: signOneShot, verify: verifyOneShot, createSign, createVerify, getCurves } = require('crypto')\n\nconst { derToJose, joseToDer } = require('../help/ecdsa_signatures')\nconst { KEYOBJECT } = require('../help/consts')\nconst resolveNodeAlg = require('../help/node_alg')\nconst { asInput } = require('../help/key_object')\nconst { dsaEncodingSupported } = require('../help/runtime_support')\n\nlet sign, verify\n\nif (dsaEncodingSupported) {\n  sign = (jwaAlg, nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {\n    if (typeof payload === 'string') {\n      payload = Buffer.from(payload)\n    }\n    return signOneShot(nodeAlg, payload, { key: asInput(keyObject, false), dsaEncoding: 'ieee-p1363' })\n  }\n  verify = (jwaAlg, nodeAlg, { [KEYOBJECT]: keyObject }, payload, signature) => {\n    try {\n      return verifyOneShot(nodeAlg, payload, { key: asInput(keyObject, true), dsaEncoding: 'ieee-p1363' }, signature)\n    } catch (err) {\n      return false\n    }\n  }\n} else {\n  sign = (jwaAlg, nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {\n    return derToJose(createSign(nodeAlg).update(payload).sign(asInput(keyObject, false)), jwaAlg)\n  }\n  verify = (jwaAlg, nodeAlg, { [KEYOBJECT]: keyObject }, payload, signature) => {\n    try {\n      return createVerify(nodeAlg).update(payload).verify(asInput(keyObject, true), joseToDer(signature, jwaAlg))\n    } catch (err) {\n      return false\n    }\n  }\n}\n\nconst crvToAlg = (crv) => {\n  switch (crv) {\n    case 'P-256':\n      return 'ES256'\n    case 'secp256k1':\n      return 'ES256K'\n    case 'P-384':\n      return 'ES384'\n    case 'P-521':\n      return 'ES512'\n  }\n}\n\nmodule.exports = (JWA, JWK) => {\n  const algs = []\n\n  if (getCurves().includes('prime256v1')) {\n    algs.push('ES256')\n  }\n\n  if (getCurves().includes('secp256k1')) {\n    algs.push('ES256K')\n  }\n\n  if (getCurves().includes('secp384r1')) {\n    algs.push('ES384')\n  }\n\n  if (getCurves().includes('secp521r1')) {\n    algs.push('ES512')\n  }\n\n  algs.forEach((jwaAlg) => {\n    const nodeAlg = resolveNodeAlg(jwaAlg)\n    JWA.sign.set(jwaAlg, sign.bind(undefined, jwaAlg, nodeAlg))\n    JWA.verify.set(jwaAlg, verify.bind(undefined, jwaAlg, nodeAlg))\n    JWK.EC.sign[jwaAlg] = key => key.private && JWK.EC.verify[jwaAlg](key)\n    JWK.EC.verify[jwaAlg] = key => (key.use === 'sig' || key.use === undefined) && crvToAlg(key.crv) === jwaAlg\n  })\n}\n","const { sign: signOneShot, verify: verifyOneShot } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst { edDSASupported } = require('../help/runtime_support')\n\nconst sign = ({ [KEYOBJECT]: keyObject }, payload) => {\n  if (typeof payload === 'string') {\n    payload = Buffer.from(payload)\n  }\n  return signOneShot(undefined, payload, keyObject)\n}\n\nconst verify = ({ [KEYOBJECT]: keyObject }, payload, signature) => {\n  return verifyOneShot(undefined, payload, keyObject, signature)\n}\n\nmodule.exports = (JWA, JWK) => {\n  if (edDSASupported) {\n    JWA.sign.set('EdDSA', sign)\n    JWA.verify.set('EdDSA', verify)\n    JWK.OKP.sign.EdDSA = key => key.private && JWK.OKP.verify.EdDSA(key)\n    JWK.OKP.verify.EdDSA = key => (key.use === 'sig' || key.use === undefined) && key.keyObject.asymmetricKeyType.startsWith('ed')\n  }\n}\n","const { createHmac } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst timingSafeEqual = require('../help/timing_safe_equal')\nconst resolveNodeAlg = require('../help/node_alg')\nconst { asInput } = require('../help/key_object')\n\nconst sign = (jwaAlg, hmacAlg, { [KEYOBJECT]: keyObject }, payload) => {\n  const hmac = createHmac(hmacAlg, asInput(keyObject, false))\n  hmac.update(payload)\n  return hmac.digest()\n}\n\nconst verify = (jwaAlg, hmacAlg, key, payload, signature) => {\n  const expected = sign(jwaAlg, hmacAlg, key, payload)\n  const actual = signature\n\n  return timingSafeEqual(actual, expected)\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['HS256', 'HS384', 'HS512'].forEach((jwaAlg) => {\n    const hmacAlg = resolveNodeAlg(jwaAlg)\n    JWA.sign.set(jwaAlg, sign.bind(undefined, jwaAlg, hmacAlg))\n    JWA.verify.set(jwaAlg, verify.bind(undefined, jwaAlg, hmacAlg))\n    JWK.oct.sign[jwaAlg] = JWK.oct.verify[jwaAlg] = key => key.use === 'sig' || key.use === undefined\n  })\n}\n","const { JWKKeySupport, JOSENotSupported } = require('../errors')\nconst { KEY_MANAGEMENT_ENCRYPT, KEY_MANAGEMENT_DECRYPT } = require('../help/consts')\n\nconst { JWA, JWK } = require('../registry')\n\n// sign, verify\nrequire('./hmac')(JWA, JWK)\nrequire('./ecdsa')(JWA, JWK)\nrequire('./eddsa')(JWA, JWK)\nrequire('./rsassa_pss')(JWA, JWK)\nrequire('./rsassa')(JWA, JWK)\nrequire('./none')(JWA)\n\n// encrypt, decrypt\nrequire('./aes_cbc_hmac_sha2')(JWA, JWK)\nrequire('./aes_gcm')(JWA, JWK)\n\n// wrapKey, unwrapKey\nrequire('./rsaes')(JWA, JWK)\nrequire('./aes_kw')(JWA, JWK)\nrequire('./aes_gcm_kw')(JWA, JWK)\n\n// deriveKey\nrequire('./pbes2')(JWA, JWK)\nrequire('./ecdh/dir')(JWA, JWK)\nrequire('./ecdh/kw')(JWA, JWK)\n\nconst check = (key, op, alg) => {\n  const cache = `_${op}_${alg}`\n\n  let label\n  let keyOp\n  if (op === 'keyManagementEncrypt') {\n    label = 'key management (encryption)'\n    keyOp = KEY_MANAGEMENT_ENCRYPT\n  } else if (op === 'keyManagementDecrypt') {\n    label = 'key management (decryption)'\n    keyOp = KEY_MANAGEMENT_DECRYPT\n  }\n\n  if (cache in key) {\n    if (key[cache]) {\n      return\n    }\n    throw new JWKKeySupport(`the key does not support ${alg} ${label || op} algorithm`)\n  }\n\n  let value = true\n  if (!JWA[op].has(alg)) {\n    throw new JOSENotSupported(`unsupported ${label || op} alg: ${alg}`)\n  } else if (!key.algorithms(keyOp).has(alg)) {\n    value = false\n  }\n\n  Object.defineProperty(key, cache, { value, enumerable: false })\n\n  if (!value) {\n    return check(key, op, alg)\n  }\n}\n\nmodule.exports = {\n  check,\n  sign: (alg, key, payload) => {\n    check(key, 'sign', alg)\n    return JWA.sign.get(alg)(key, payload)\n  },\n  verify: (alg, key, payload, signature) => {\n    check(key, 'verify', alg)\n    return JWA.verify.get(alg)(key, payload, signature)\n  },\n  keyManagementEncrypt: (alg, key, payload, opts) => {\n    check(key, 'keyManagementEncrypt', alg)\n    return JWA.keyManagementEncrypt.get(alg)(key, payload, opts)\n  },\n  keyManagementDecrypt: (alg, key, payload, opts) => {\n    check(key, 'keyManagementDecrypt', alg)\n    return JWA.keyManagementDecrypt.get(alg)(key, payload, opts)\n  },\n  encrypt: (alg, key, cleartext, opts) => {\n    check(key, 'encrypt', alg)\n    return JWA.encrypt.get(alg)(key, cleartext, opts)\n  },\n  decrypt: (alg, key, ciphertext, opts) => {\n    check(key, 'decrypt', alg)\n    return JWA.decrypt.get(alg)(key, ciphertext, opts)\n  }\n}\n","const sign = () => Buffer.from('')\nconst verify = (key, payload, signature) => !signature.length\n\nmodule.exports = (JWA, JWK) => {\n  JWA.sign.set('none', sign)\n  JWA.verify.set('none', verify)\n}\n","const { pbkdf2Sync: pbkdf2, randomBytes } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst base64url = require('../help/base64url')\n\nconst SALT_LENGTH = 16\nconst NULL_BUFFER = Buffer.alloc(1, 0)\n\nconst concatSalt = (alg, p2s) => {\n  return Buffer.concat([\n    Buffer.from(alg, 'utf8'),\n    NULL_BUFFER,\n    p2s\n  ])\n}\n\nconst wrapKey = (keylen, sha, concat, wrap, { [KEYOBJECT]: keyObject }, payload) => {\n  // Note that if password-based encryption is used for multiple\n  // recipients, it is expected that each recipient use different values\n  // for the PBES2 parameters \"p2s\" and \"p2c\".\n  // here we generate p2c between 2048 and 4096 and random p2s\n  const p2c = Math.floor((Math.random() * 2049) + 2048)\n  const p2s = randomBytes(SALT_LENGTH)\n  const salt = concat(p2s)\n\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha)\n\n  const result = wrap({ [KEYOBJECT]: derivedKey }, payload)\n  result.header = result.header || {}\n  Object.assign(result.header, { p2c, p2s: base64url.encodeBuffer(p2s) })\n\n  return result\n}\n\nconst unwrapKey = (keylen, sha, concat, unwrap, { [KEYOBJECT]: keyObject }, payload, header) => {\n  const { p2s, p2c } = header\n  const salt = concat(p2s)\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha)\n  return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['PBES2-HS256+A128KW', 'PBES2-HS384+A192KW', 'PBES2-HS512+A256KW'].forEach((jwaAlg) => {\n    const kw = jwaAlg.substr(-6)\n    const kwWrap = JWA.keyManagementEncrypt.get(kw)\n    const kwUnwrap = JWA.keyManagementDecrypt.get(kw)\n    const keylen = parseInt(jwaAlg.substr(13, 3), 10) / 8\n    const sha = `sha${jwaAlg.substr(8, 3)}`\n\n    if (kwWrap && kwUnwrap) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwWrap))\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwUnwrap))\n      JWK.oct.deriveKey[jwaAlg] = key => key.use === 'enc' || key.use === undefined\n    }\n  })\n}\n","const { publicEncrypt, privateDecrypt, constants } = require('crypto')\n\nconst { oaepHashSupported } = require('../help/runtime_support')\nconst { KEYOBJECT } = require('../help/consts')\nconst { asInput } = require('../help/key_object')\n\nconst resolvePadding = (alg) => {\n  switch (alg) {\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      return constants.RSA_PKCS1_OAEP_PADDING\n    case 'RSA1_5':\n      return constants.RSA_PKCS1_PADDING\n  }\n}\n\nconst resolveOaepHash = (alg) => {\n  switch (alg) {\n    case 'RSA-OAEP':\n      return 'sha1'\n    case 'RSA-OAEP-256':\n      return 'sha256'\n    case 'RSA-OAEP-384':\n      return 'sha384'\n    case 'RSA-OAEP-512':\n      return 'sha512'\n    default:\n      return undefined\n  }\n}\n\nconst wrapKey = (padding, oaepHash, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, true)\n  return { wrapped: publicEncrypt({ key, oaepHash, padding }, payload) }\n}\n\nconst unwrapKey = (padding, oaepHash, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, false)\n  return privateDecrypt({ key, oaepHash, padding }, payload)\n}\n\nconst LENGTHS = {\n  RSA1_5: 0,\n  'RSA-OAEP': 592,\n  'RSA-OAEP-256': 784,\n  'RSA-OAEP-384': 1040,\n  'RSA-OAEP-512': 1296\n}\n\nmodule.exports = (JWA, JWK) => {\n  const algs = ['RSA-OAEP', 'RSA1_5']\n\n  if (oaepHashSupported) {\n    algs.splice(1, 0, 'RSA-OAEP-256', 'RSA-OAEP-384', 'RSA-OAEP-512')\n  }\n\n  algs.forEach((jwaAlg) => {\n    const padding = resolvePadding(jwaAlg)\n    const oaepHash = resolveOaepHash(jwaAlg)\n    JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, padding, oaepHash))\n    JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, padding, oaepHash))\n    JWK.RSA.wrapKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length >= LENGTHS[jwaAlg]\n    JWK.RSA.unwrapKey[jwaAlg] = key => key.private && (key.use === 'enc' || key.use === undefined) && key.length >= LENGTHS[jwaAlg]\n  })\n}\n","const { createSign, createVerify } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst resolveNodeAlg = require('../help/node_alg')\nconst { asInput } = require('../help/key_object')\n\nconst sign = (nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {\n  return createSign(nodeAlg).update(payload).sign(asInput(keyObject, false))\n}\n\nconst verify = (nodeAlg, { [KEYOBJECT]: keyObject }, payload, signature) => {\n  return createVerify(nodeAlg).update(payload).verify(asInput(keyObject, true), signature)\n}\n\nconst LENGTHS = {\n  RS256: 0,\n  RS384: 624,\n  RS512: 752\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['RS256', 'RS384', 'RS512'].forEach((jwaAlg) => {\n    const nodeAlg = resolveNodeAlg(jwaAlg)\n    JWA.sign.set(jwaAlg, sign.bind(undefined, nodeAlg))\n    JWA.verify.set(jwaAlg, verify.bind(undefined, nodeAlg))\n    JWK.RSA.sign[jwaAlg] = key => key.private && JWK.RSA.verify[jwaAlg](key)\n    JWK.RSA.verify[jwaAlg] = key => (key.use === 'sig' || key.use === undefined) && key.length >= LENGTHS[jwaAlg]\n  })\n}\n","const {\n  createSign,\n  createVerify,\n  constants\n} = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst resolveNodeAlg = require('../help/node_alg')\nconst { asInput } = require('../help/key_object')\n\nconst sign = (nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, false)\n  return createSign(nodeAlg).update(payload).sign({\n    key,\n    padding: constants.RSA_PKCS1_PSS_PADDING,\n    saltLength: constants.RSA_PSS_SALTLEN_DIGEST\n  })\n}\n\nconst verify = (nodeAlg, { [KEYOBJECT]: keyObject }, payload, signature) => {\n  const key = asInput(keyObject, true)\n  return createVerify(nodeAlg).update(payload).verify({\n    key,\n    padding: constants.RSA_PKCS1_PSS_PADDING,\n    saltLength: constants.RSA_PSS_SALTLEN_DIGEST\n  }, signature)\n}\n\nconst LENGTHS = {\n  PS256: 528,\n  PS384: 784,\n  PS512: 1040\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['PS256', 'PS384', 'PS512'].forEach((jwaAlg) => {\n    const nodeAlg = resolveNodeAlg(jwaAlg)\n    JWA.sign.set(jwaAlg, sign.bind(undefined, nodeAlg))\n    JWA.verify.set(jwaAlg, verify.bind(undefined, nodeAlg))\n    JWK.RSA.sign[jwaAlg] = key => key.private && JWK.RSA.verify[jwaAlg](key)\n    JWK.RSA.verify[jwaAlg] = key => (key.use === 'sig' || key.use === undefined) && key.length >= LENGTHS[jwaAlg]\n  })\n}\n","const { inflateRawSync } = require('zlib')\n\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, decrypt, keyManagementDecrypt } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { createSecretKey } = require('../help/key_object')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\nconst { detect: resolveSerialization } = require('./serializers')\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened'])\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot)\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s\n  const apu = prot.apu || unprotected.apu || header.apu\n  const apv = prot.apv || unprotected.apv || header.apv\n  const iv = prot.iv || unprotected.iv || header.iv\n  const tag = prot.tag || unprotected.tag || header.tag\n\n  return {\n    ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? { p2s: base64url.decodeToBuffer(p2s) } : undefined),\n    ...(typeof apu === 'string' ? { apu: base64url.decodeToBuffer(apu) } : undefined),\n    ...(typeof apv === 'string' ? { apv: base64url.decodeToBuffer(apv) } : undefined),\n    ...(typeof iv === 'string' ? { iv: base64url.decodeToBuffer(iv) } : undefined),\n    ...(typeof tag === 'string' ? { tag: base64url.decodeToBuffer(tag) } : undefined)\n  }\n}\n\nconst validateAlgorithms = (algorithms, option) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError(`\"${option}\" option must be an array of non-empty strings`)\n  }\n\n  if (!algorithms) {\n    return undefined\n  }\n\n  return new Set(algorithms)\n}\n\n/*\n * @public\n */\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, { crit = [], complete = false, keyManagementAlgorithms, contentEncryptionAlgorithms, maxPBES2Count = 10000 } = {}) => {\n  key = getKey(key, true)\n\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms')\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms')\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe)\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened'\n    const { recipients, ...root } = jwe\n    jwe = { ...root, ...recipients[0] }\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') { // compact serialization format\n      ([prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.'))\n    } else { // flattened serialization format\n      ({ protected: prot, encrypted_key: encryptedKey, iv, ciphertext, tag, unprotected, aad, header } = jwe)\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{ header }], true, crit)\n    }\n\n    opts = combineHeader(prot, unprotected, header)\n\n    ;({ alg, enc } = opts)\n\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted')\n    }\n\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      let keys\n      if (opts.alg === 'dir') {\n        keys = keystore.all({ kid: opts.kid, alg: opts.enc, key_ops: ['decrypt'] })\n      } else {\n        keys = keystore.all({ kid: opts.kid, alg: opts.alg, key_ops: ['unwrapKey'] })\n      }\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jweDecrypt(true, serialization, jwe, key, {\n                crit,\n                complete,\n                contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n                keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n              })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n            throw new errors.JWEDecryptionFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]))\n\n    if (alg.startsWith('PBES2')) {\n      if (opts && opts.p2c > maxPBES2Count) {\n        throw new errors.JWEInvalid('JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds')\n      }\n    }\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, { alg: enc, use: 'enc' })\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc)\n    }\n\n    let adata\n    if (aad) {\n      adata = Buffer.concat([\n        Buffer.from(prot || ''),\n        Buffer.from('.'),\n        Buffer.from(aad)\n      ])\n    } else {\n      adata = Buffer.from(prot || '')\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv)\n    } catch (err) {}\n    try {\n      tag = base64url.decodeToBuffer(tag)\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), { iv, tag, aad: adata })\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext)\n    }\n\n    if (complete) {\n      const result = { cleartext, key, cek }\n      if (aad) result.aad = aad\n      if (header) result.header = header\n      if (unprotected) result.unprotected = unprotected\n      if (prot) result.protected = base64url.JSON.decode(prot)\n      return result\n    }\n\n    return cleartext\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({ header }) => ({ header })), true, crit)\n\n  // general serialization format\n  const { recipients, ...root } = jwe\n  const errs = []\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root, ...recipient }, key, {\n        crit,\n        complete,\n        contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n        keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n      })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined)\n","const { deflateRawSync } = require('zlib')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst generateIV = require('../help/generate_iv')\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst isObject = require('../help/is_object')\nconst { createSecretKey } = require('../help/key_object')\nconst deepClone = require('../help/deep_clone')\nconst importKey = require('../jwk/import')\nconst { JWEInvalid } = require('../errors')\nconst { check, keyManagementEncrypt, encrypt } = require('../jwa')\n\nconst serializers = require('./serializers')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')\n\nclass Encrypt {\n  constructor (cleartext, protectedHeader, aad, unprotectedHeader) {\n    if (!Buffer.isBuffer(cleartext) && typeof cleartext !== 'string') {\n      throw new TypeError('cleartext argument must be a Buffer or a string')\n    }\n    cleartext = Buffer.from(cleartext)\n\n    if (aad !== undefined && !Buffer.isBuffer(aad) && typeof aad !== 'string') {\n      throw new TypeError('aad argument must be a Buffer or a string when provided')\n    }\n    aad = aad ? Buffer.from(aad) : undefined\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided')\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided')\n    }\n\n    this._recipients = []\n    this._cleartext = cleartext\n    this._aad = aad\n    this._unprotected = unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    this._protected = protectedHeader ? deepClone(protectedHeader) : undefined\n  }\n\n  /*\n   * @public\n   */\n  recipient (key, header) {\n    key = getKey(key)\n\n    if (header !== undefined && !isObject(header)) {\n      throw new TypeError('header argument must be a plain object when provided')\n    }\n\n    this._recipients.push({\n      key,\n      header: header ? deepClone(header) : undefined\n    })\n\n    return this\n  }\n\n  /*\n   * @private\n   */\n  [PROCESS_RECIPIENT] (recipient) {\n    const unprotectedHeader = this._unprotected\n    const protectedHeader = this._protected\n    const { length: recipientCount } = this._recipients\n\n    const jweHeader = {\n      ...protectedHeader,\n      ...unprotectedHeader,\n      ...recipient.header\n    }\n    const { key } = recipient\n\n    const enc = jweHeader.enc\n    let alg = jweHeader.alg\n\n    if (key.use === 'sig') {\n      throw new TypeError('a key with \"use\":\"sig\" is not usable for encryption')\n    }\n\n    if (alg === 'dir') {\n      check(key, 'encrypt', enc)\n    } else if (alg) {\n      check(key, 'keyManagementEncrypt', alg)\n    } else {\n      alg = key.alg || [...key.algorithms('wrapKey')][0] || [...key.algorithms('deriveKey')][0]\n\n      if (alg === 'ECDH-ES' && recipientCount !== 1) {\n        alg = [...key.algorithms('deriveKey')][1]\n      }\n\n      if (!alg) {\n        throw new JWEInvalid('could not resolve a usable \"alg\" for a recipient')\n      }\n\n      if (recipientCount === 1) {\n        if (protectedHeader) {\n          protectedHeader.alg = alg\n        } else {\n          this._protected = { alg }\n        }\n      } else {\n        if (recipient.header) {\n          recipient.header.alg = alg\n        } else {\n          recipient.header = { alg }\n        }\n      }\n    }\n\n    let wrapped\n    let generatedHeader\n\n    if (key.kty === 'oct' && alg === 'dir') {\n      this._cek = importKey(key[KEYOBJECT], { use: 'enc', alg: enc })\n    } else {\n      check(this._cek, 'encrypt', enc)\n      ;({ wrapped, header: generatedHeader } = keyManagementEncrypt(alg, key, this._cek[KEYOBJECT].export(), { enc, alg }))\n      if (alg === 'ECDH-ES') {\n        this._cek = importKey(createSecretKey(wrapped), { use: 'enc', alg: enc })\n      }\n    }\n\n    if (alg === 'dir' || alg === 'ECDH-ES') {\n      recipient.encrypted_key = ''\n    } else {\n      recipient.encrypted_key = base64url.encodeBuffer(wrapped)\n    }\n\n    if (generatedHeader) {\n      recipient.generatedHeader = generatedHeader\n    }\n  }\n\n  /*\n   * @public\n   */\n  encrypt (serialization) {\n    const serializer = serializers[serialization]\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"')\n    }\n\n    if (!this._recipients.length) {\n      throw new JWEInvalid('missing recipients')\n    }\n\n    serializer.validate(this._protected, this._unprotected, this._aad, this._recipients)\n\n    let enc = validateHeaders(this._protected, this._unprotected, this._recipients, false, this._protected ? this._protected.crit : undefined)\n    if (!enc) {\n      enc = 'A128CBC-HS256'\n      if (this._protected) {\n        this._protected.enc = enc\n      } else {\n        this._protected = { enc }\n      }\n    }\n    const final = {}\n    this._cek = generateCEK(enc)\n\n    for (const recipient of this._recipients) {\n      this[PROCESS_RECIPIENT](recipient)\n    }\n\n    const iv = generateIV(enc)\n    final.iv = base64url.encodeBuffer(iv)\n\n    if (this._recipients.length === 1 && this._recipients[0].generatedHeader) {\n      const [{ generatedHeader }] = this._recipients\n      delete this._recipients[0].generatedHeader\n      this._protected = {\n        ...this._protected,\n        ...generatedHeader\n      }\n    }\n\n    if (this._protected) {\n      final.protected = base64url.JSON.encode(this._protected)\n    }\n    final.unprotected = this._unprotected\n\n    let aad\n    if (this._aad) {\n      final.aad = base64url.encode(this._aad)\n      aad = Buffer.concat([\n        Buffer.from(final.protected || ''),\n        Buffer.from('.'),\n        Buffer.from(final.aad)\n      ])\n    } else {\n      aad = Buffer.from(final.protected || '')\n    }\n\n    let cleartext = this._cleartext\n    if (this._protected && 'zip' in this._protected) {\n      cleartext = deflateRawSync(cleartext)\n    }\n\n    const { ciphertext, tag } = encrypt(enc, this._cek, cleartext, { iv, aad })\n    final.tag = base64url.encodeBuffer(tag)\n    final.ciphertext = base64url.encodeBuffer(ciphertext)\n\n    return serializer(final, this._recipients)\n  }\n}\n\nmodule.exports = Encrypt\n","const { randomBytes } = require('crypto')\n\nconst { createSecretKey } = require('../help/key_object')\nconst { KEYLENGTHS } = require('../registry')\nconst Key = require('../jwk/key/oct')\n\nmodule.exports = (alg) => {\n  const keyLength = KEYLENGTHS.get(alg)\n\n  if (!keyLength) {\n    return new Key({ type: 'secret' })\n  }\n\n  return new Key(createSecretKey(randomBytes(keyLength / 8)), { use: 'enc', alg })\n}\n","const Encrypt = require('./encrypt')\nconst decrypt = require('./decrypt')\n\nconst single = (serialization, cleartext, key, protectedHeader, aad, unprotectedHeader) => {\n  return new Encrypt(cleartext, protectedHeader, aad, unprotectedHeader)\n    .recipient(key)\n    .encrypt(serialization)\n}\n\nmodule.exports.Encrypt = Encrypt\nmodule.exports.encrypt = single.bind(undefined, 'compact')\nmodule.exports.encrypt.flattened = single.bind(undefined, 'flattened')\nmodule.exports.encrypt.general = single.bind(undefined, 'general')\n\nmodule.exports.decrypt = decrypt\n","const isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\n\nconst { JWEInvalid } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid)\n\nconst compactSerializer = (final, [recipient]) => {\n  return `${final.protected}.${recipient.encrypted_key}.${final.iv}.${final.ciphertext}.${final.tag}`\n}\ncompactSerializer.validate = (protectedHeader, unprotectedHeader, aad, { 0: { header }, length }) => {\n  if (length !== 1 || aad || unprotectedHeader || header) {\n    throw new JWEInvalid('JWE Compact Serialization doesn\\'t support multiple recipients, JWE unprotected headers or AAD')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst flattenedSerializer = (final, [recipient]) => {\n  const { header, encrypted_key: encryptedKey } = recipient\n\n  return {\n    ...(final.protected ? { protected: final.protected } : undefined),\n    ...(final.unprotected ? { unprotected: final.unprotected } : undefined),\n    ...(header ? { header } : undefined),\n    ...(encryptedKey ? { encrypted_key: encryptedKey } : undefined),\n    ...(final.aad ? { aad: final.aad } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  }\n}\nflattenedSerializer.validate = (protectedHeader, unprotectedHeader, aad, { 0: { header }, length }) => {\n  if (length !== 1) {\n    throw new JWEInvalid('Flattened JWE JSON Serialization doesn\\'t support multiple recipients')\n  }\n  validateCrit(protectedHeader, { ...unprotectedHeader, ...header }, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst generalSerializer = (final, recipients) => {\n  const result = {\n    ...(final.protected ? { protected: final.protected } : undefined),\n    ...(final.unprotected ? { unprotected: final.unprotected } : undefined),\n    recipients: recipients.map(({ header, encrypted_key: encryptedKey, generatedHeader }) => {\n      if (!header && !encryptedKey && !generatedHeader) {\n        return false\n      }\n\n      return {\n        ...(header || generatedHeader ? { header: { ...header, ...generatedHeader } } : undefined),\n        ...(encryptedKey ? { encrypted_key: encryptedKey } : undefined)\n      }\n    }).filter(Boolean),\n    ...(final.aad ? { aad: final.aad } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  }\n\n  if (!result.recipients.length) {\n    delete result.recipients\n  }\n\n  return result\n}\ngeneralSerializer.validate = (protectedHeader, unprotectedHeader, aad, recipients) => {\n  recipients.forEach(({ header }) => {\n    validateCrit(protectedHeader, { ...header, ...unprotectedHeader }, protectedHeader ? protectedHeader.crit : undefined)\n  })\n}\n\nconst isJSON = (input) => {\n  return isObject(input) &&\n    typeof input.ciphertext === 'string' &&\n    typeof input.iv === 'string' &&\n    typeof input.tag === 'string' &&\n    (input.unprotected === undefined || isObject(input.unprotected)) &&\n    (input.protected === undefined || typeof input.protected === 'string') &&\n    (input.aad === undefined || typeof input.aad === 'string')\n}\n\nconst isSingleRecipient = (input) => {\n  return (input.encrypted_key === undefined || typeof input.encrypted_key === 'string') &&\n    (input.header === undefined || isObject(input.header))\n}\n\nconst isValidRecipient = (recipient) => {\n  return isObject(recipient) && typeof recipient.encrypted_key === 'string' && (recipient.header === undefined || isObject(recipient.header))\n}\n\nconst isMultiRecipient = (input) => {\n  if (Array.isArray(input.recipients) && input.recipients.every(isValidRecipient)) {\n    return true\n  }\n\n  return false\n}\n\nconst detect = (input) => {\n  if (typeof input === 'string' && input.split('.').length === 5) {\n    return 'compact'\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general'\n    }\n\n    if (isSingleRecipient(input)) {\n      return 'flattened'\n    }\n  }\n\n  throw new JWEInvalid('JWE malformed or invalid serialization')\n}\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n}\n","const isDisjoint = require('../help/is_disjoint')\nconst base64url = require('../help/base64url')\nlet validateCrit = require('../help/validate_crit')\nconst { JWEInvalid, JOSENotSupported } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid)\n\nmodule.exports = (prot, unprotected, recipients, checkAlgorithms, crit) => {\n  if (typeof prot === 'string') {\n    try {\n      prot = base64url.JSON.decode(prot)\n    } catch (err) {\n      throw new JWEInvalid('could not parse JWE protected header')\n    }\n  }\n\n  let alg = []\n  const enc = new Set()\n  if (!isDisjoint(prot, unprotected) || !recipients.every(({ header }) => {\n    if (typeof header === 'object') {\n      alg.push(header.alg)\n      enc.add(header.enc)\n    }\n    const combined = { ...unprotected, ...header }\n    validateCrit(prot, combined, crit)\n    if ('zip' in combined) {\n      throw new JWEInvalid('\"zip\" Header Parameter MUST be integrity protected')\n    } else if (prot && 'zip' in prot && prot.zip !== 'DEF') {\n      throw new JOSENotSupported('only \"DEF\" compression algorithm is supported')\n    }\n    return isDisjoint(header, prot) && isDisjoint(header, unprotected)\n  })) {\n    throw new JWEInvalid('JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint')\n  }\n\n  if (typeof prot === 'object') {\n    alg.push(prot.alg)\n    enc.add(prot.enc)\n  }\n  if (typeof unprotected === 'object') {\n    alg.push(unprotected.alg)\n    enc.add(unprotected.enc)\n  }\n\n  alg = alg.filter(Boolean)\n  enc.delete(undefined)\n\n  if (recipients.length !== 1) {\n    if (alg.includes('dir') || alg.includes('ECDH-ES')) {\n      throw new JWEInvalid('dir and ECDH-ES alg may only be used with a single recipient')\n    }\n  }\n\n  if (checkAlgorithms) {\n    if (alg.length !== recipients.length) {\n      throw new JWEInvalid('missing Key Management algorithm')\n    }\n    if (enc.size === 0) {\n      throw new JWEInvalid('missing Content Encryption algorithm')\n    } else if (enc.size !== 1) {\n      throw new JWEInvalid('there must only be one Content Encryption algorithm')\n    }\n  } else {\n    if (enc.size > 1) {\n      throw new JWEInvalid('there must only be one Content Encryption algorithm')\n    }\n  }\n\n  return [...enc][0]\n}\n","const errors = require('../errors')\n\nconst importKey = require('./import')\n\nconst RSAKey = require('./key/rsa')\nconst ECKey = require('./key/ec')\nconst OKPKey = require('./key/okp')\nconst OctKey = require('./key/oct')\n\nconst generate = async (kty, crvOrSize, params, generatePrivate = true) => {\n  switch (kty) {\n    case 'RSA':\n      return importKey(\n        await RSAKey.generate(crvOrSize, generatePrivate),\n        params\n      )\n    case 'EC':\n      return importKey(\n        await ECKey.generate(crvOrSize, generatePrivate),\n        params\n      )\n    case 'OKP':\n      return importKey(\n        await OKPKey.generate(crvOrSize, generatePrivate),\n        params\n      )\n    case 'oct':\n      return importKey(\n        await OctKey.generate(crvOrSize, generatePrivate),\n        params\n      )\n    default:\n      throw new errors.JOSENotSupported(`unsupported key type: ${kty}`)\n  }\n}\n\nconst generateSync = (kty, crvOrSize, params, generatePrivate = true) => {\n  switch (kty) {\n    case 'RSA':\n      return importKey(RSAKey.generateSync(crvOrSize, generatePrivate), params)\n    case 'EC':\n      return importKey(ECKey.generateSync(crvOrSize, generatePrivate), params)\n    case 'OKP':\n      return importKey(OKPKey.generateSync(crvOrSize, generatePrivate), params)\n    case 'oct':\n      return importKey(OctKey.generateSync(crvOrSize, generatePrivate), params)\n    default:\n      throw new errors.JOSENotSupported(`unsupported key type: ${kty}`)\n  }\n}\n\nmodule.exports.generate = generate\nmodule.exports.generateSync = generateSync\n","const { createPublicKey, createPrivateKey, createSecretKey, KeyObject } = require('../help/key_object')\nconst base64url = require('../help/base64url')\nconst isObject = require('../help/is_object')\nconst { jwkToPem } = require('../help/key_utils')\nconst errors = require('../errors')\n\nconst RSAKey = require('./key/rsa')\nconst ECKey = require('./key/ec')\nconst OKPKey = require('./key/okp')\nconst OctKey = require('./key/oct')\n\nconst importable = new Set(['string', 'buffer', 'object'])\n\nconst mergedParameters = (target = {}, source = {}) => {\n  return {\n    alg: source.alg,\n    key_ops: source.key_ops,\n    kid: source.kid,\n    use: source.use,\n    x5c: source.x5c,\n    x5t: source.x5t,\n    'x5t#S256': source['x5t#S256'],\n    ...target\n  }\n}\n\nconst openSSHpublicKey = /^[a-zA-Z0-9-]+ AAAA(?:[0-9A-Za-z+/])+(?:==|=)?(?: .*)?$/\n\nconst asKey = (key, parameters, { calculateMissingRSAPrimes = false } = {}) => {\n  let privateKey, publicKey, secret\n\n  if (!importable.has(typeof key)) {\n    throw new TypeError('key argument must be a string, buffer or an object')\n  }\n\n  if (parameters !== undefined && !isObject(parameters)) {\n    throw new TypeError('parameters argument must be a plain object when provided')\n  }\n\n  if (key instanceof KeyObject) {\n    switch (key.type) {\n      case 'private':\n        privateKey = key\n        break\n      case 'public':\n        publicKey = key\n        break\n      case 'secret':\n        secret = key\n        break\n    }\n  } else if (typeof key === 'object' && key && 'kty' in key && key.kty === 'oct') { // symmetric key <Object>\n    try {\n      secret = createSecretKey(base64url.decodeToBuffer(key.k))\n    } catch (err) {\n      if (!('k' in key)) {\n        secret = { type: 'secret' }\n      }\n    }\n    parameters = mergedParameters(parameters, key)\n  } else if (typeof key === 'object' && key && 'kty' in key) { // assume JWK formatted asymmetric key <Object>\n    ({ calculateMissingRSAPrimes = false } = parameters || { calculateMissingRSAPrimes })\n    let pem\n\n    try {\n      pem = jwkToPem(key, { calculateMissingRSAPrimes })\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    if (pem && key.d) {\n      privateKey = createPrivateKey(pem)\n    } else if (pem) {\n      publicKey = createPublicKey(pem)\n    }\n\n    parameters = mergedParameters({}, key)\n  } else if (key && (typeof key === 'object' || typeof key === 'string')) { // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey\n    try {\n      privateKey = createPrivateKey(key)\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    try {\n      publicKey = createPublicKey(key)\n      if (key.startsWith('-----BEGIN CERTIFICATE-----') && (!parameters || !('x5c' in parameters))) {\n        parameters = mergedParameters(parameters, {\n          x5c: [key.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '')]\n        })\n      }\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    try {\n      // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then\n      // have them imported as symmetric \"oct\" keys\n      if (!key.includes('-----BEGIN') && !openSSHpublicKey.test(key.toString('ascii').replace(/[\\r\\n]/g, ''))) {\n        secret = createSecretKey(Buffer.isBuffer(key) ? key : Buffer.from(key))\n      }\n    } catch (err) {}\n  }\n\n  const keyObject = privateKey || publicKey || secret\n\n  if (privateKey || publicKey) {\n    switch (keyObject.asymmetricKeyType) {\n      case 'rsa':\n        return new RSAKey(keyObject, parameters)\n      case 'ec':\n        return new ECKey(keyObject, parameters)\n      case 'ed25519':\n      case 'ed448':\n      case 'x25519':\n      case 'x448':\n        return new OKPKey(keyObject, parameters)\n      default:\n        throw new errors.JOSENotSupported('only RSA, EC and OKP asymmetric keys are supported')\n    }\n  } else if (secret) {\n    return new OctKey(keyObject, parameters)\n  }\n\n  throw new errors.JWKImportFailed('key import failed')\n}\n\nmodule.exports = asKey\n","const Key = require('./key/base')\nconst None = require('./key/none')\nconst EmbeddedJWK = require('./key/embedded.jwk')\nconst EmbeddedX5C = require('./key/embedded.x5c')\nconst importKey = require('./import')\nconst generate = require('./generate')\n\nmodule.exports = {\n  ...generate,\n  asKey: importKey,\n  isKey: input => input instanceof Key,\n  None,\n  EmbeddedJWK,\n  EmbeddedX5C\n}\n","const { strict: assert } = require('assert')\nconst { inspect } = require('util')\nconst { EOL } = require('os')\n\nconst { keyObjectSupported } = require('../../help/runtime_support')\nconst { createPublicKey } = require('../../help/key_object')\nconst { keyObjectToJWK } = require('../../help/key_utils')\nconst {\n  THUMBPRINT_MATERIAL, PUBLIC_MEMBERS, PRIVATE_MEMBERS, JWK_MEMBERS, KEYOBJECT,\n  USES_MAPPING, OPS, USES\n} = require('../../help/consts')\nconst isObject = require('../../help/is_object')\nconst thumbprint = require('../thumbprint')\nconst errors = require('../../errors')\n\nconst privateApi = Symbol('privateApi')\nconst { JWK } = require('../../registry')\n\nclass Key {\n  constructor (keyObject, { alg, use, kid, key_ops: ops, x5c, x5t, 'x5t#S256': x5t256 } = {}) {\n    if (use !== undefined) {\n      if (typeof use !== 'string' || !USES.has(use)) {\n        throw new TypeError('`use` must be either \"sig\" or \"enc\" string when provided')\n      }\n    }\n\n    if (alg !== undefined) {\n      if (typeof alg !== 'string' || !alg) {\n        throw new TypeError('`alg` must be a non-empty string when provided')\n      }\n    }\n\n    if (kid !== undefined) {\n      if (typeof kid !== 'string' || !kid) {\n        throw new TypeError('`kid` must be a non-empty string when provided')\n      }\n    }\n\n    if (ops !== undefined) {\n      if (!Array.isArray(ops) || !ops.length || ops.some(o => typeof o !== 'string')) {\n        throw new TypeError('`key_ops` must be a non-empty array of strings when provided')\n      }\n      ops = Array.from(new Set(ops)).filter(x => OPS.has(x))\n    }\n\n    if (ops && use) {\n      if (\n        (use === 'enc' && ops.some(x => USES_MAPPING.sig.has(x))) ||\n        (use === 'sig' && ops.some(x => USES_MAPPING.enc.has(x)))\n      ) {\n        throw new errors.JWKInvalid('inconsistent JWK \"use\" and \"key_ops\"')\n      }\n    }\n\n    if (keyObjectSupported && x5c !== undefined) {\n      if (!Array.isArray(x5c) || !x5c.length || x5c.some(c => typeof c !== 'string')) {\n        throw new TypeError('`x5c` must be an array of one or more PKIX certificates when provided')\n      }\n\n      x5c.forEach((cert, i) => {\n        let publicKey\n        try {\n          publicKey = createPublicKey({\n            key: `-----BEGIN CERTIFICATE-----${EOL}${(cert.match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END CERTIFICATE-----`, format: 'pem'\n          })\n        } catch (err) {\n          throw new errors.JWKInvalid(`\\`x5c\\` member at index ${i} is not a valid base64-encoded DER PKIX certificate`)\n        }\n        if (i === 0) {\n          try {\n            assert.deepEqual(\n              publicKey.export({ type: 'spki', format: 'der' }),\n              (keyObject.type === 'public' ? keyObject : createPublicKey(keyObject)).export({ type: 'spki', format: 'der' })\n            )\n          } catch (err) {\n            throw new errors.JWKInvalid('The key in the first `x5c` certificate MUST match the public key represented by the JWK')\n          }\n        }\n      })\n    }\n\n    Object.defineProperties(this, {\n      [KEYOBJECT]: { value: isObject(keyObject) ? undefined : keyObject },\n      keyObject: {\n        get () {\n          if (!keyObjectSupported) {\n            throw new errors.JOSENotSupported('KeyObject class is not supported in your Node.js runtime version')\n          }\n\n          return this[KEYOBJECT]\n        }\n      },\n      type: { value: keyObject.type },\n      private: { value: keyObject.type === 'private' },\n      public: { value: keyObject.type === 'public' },\n      secret: { value: keyObject.type === 'secret' },\n      alg: { value: alg, enumerable: alg !== undefined },\n      use: { value: use, enumerable: use !== undefined },\n      x5c: {\n        enumerable: x5c !== undefined,\n        ...(x5c ? { get () { return [...x5c] } } : { value: undefined })\n      },\n      key_ops: {\n        enumerable: ops !== undefined,\n        ...(ops ? { get () { return [...ops] } } : { value: undefined })\n      },\n      kid: {\n        enumerable: true,\n        ...(kid\n          ? { value: kid }\n          : {\n              get () {\n                Object.defineProperty(this, 'kid', { value: this.thumbprint, configurable: false })\n                return this.kid\n              },\n              configurable: true\n            })\n      },\n      ...(x5c\n        ? {\n            x5t: {\n              enumerable: true,\n              ...(x5t\n                ? { value: x5t }\n                : {\n                    get () {\n                      Object.defineProperty(this, 'x5t', { value: thumbprint.x5t(this.x5c[0]), configurable: false })\n                      return this.x5t\n                    },\n                    configurable: true\n                  })\n            }\n          }\n        : undefined),\n      ...(x5c\n        ? {\n            'x5t#S256': {\n              enumerable: true,\n              ...(x5t256\n                ? { value: x5t256 }\n                : {\n                    get () {\n                      Object.defineProperty(this, 'x5t#S256', { value: thumbprint['x5t#S256'](this.x5c[0]), configurable: false })\n                      return this['x5t#S256']\n                    },\n                    configurable: true\n                  })\n            }\n          }\n        : undefined),\n      thumbprint: {\n        get () {\n          Object.defineProperty(this, 'thumbprint', { value: thumbprint.kid(this[THUMBPRINT_MATERIAL]()), configurable: false })\n          return this.thumbprint\n        },\n        configurable: true\n      }\n    })\n  }\n\n  toPEM (priv = false, encoding = {}) {\n    if (this.secret) {\n      throw new TypeError('symmetric keys cannot be exported as PEM')\n    }\n\n    if (priv && this.public === true) {\n      throw new TypeError('public key cannot be exported as private')\n    }\n\n    const { type = priv ? 'pkcs8' : 'spki', cipher, passphrase } = encoding\n\n    let keyObject = this[KEYOBJECT]\n\n    if (!priv) {\n      if (this.private) {\n        keyObject = createPublicKey(keyObject)\n      }\n      if (cipher || passphrase) {\n        throw new TypeError('cipher and passphrase can only be applied when exporting private keys')\n      }\n    }\n\n    if (priv) {\n      return keyObject.export({ format: 'pem', type, cipher, passphrase })\n    }\n\n    return keyObject.export({ format: 'pem', type })\n  }\n\n  toJWK (priv = false) {\n    if (priv && this.public === true) {\n      throw new TypeError('public key cannot be exported as private')\n    }\n\n    const components = [...this.constructor[priv ? PRIVATE_MEMBERS : PUBLIC_MEMBERS]]\n      .map(k => [k, this[k]])\n\n    const result = {}\n\n    Object.keys(components).forEach((key) => {\n      const [k, v] = components[key]\n\n      result[k] = v\n    })\n\n    result.kty = this.kty\n    result.kid = this.kid\n\n    if (this.alg) {\n      result.alg = this.alg\n    }\n\n    if (this.key_ops && this.key_ops.length) {\n      result.key_ops = this.key_ops\n    }\n\n    if (this.use) {\n      result.use = this.use\n    }\n\n    if (this.x5c) {\n      result.x5c = this.x5c\n    }\n\n    if (this.x5t) {\n      result.x5t = this.x5t\n    }\n\n    if (this['x5t#S256']) {\n      result['x5t#S256'] = this['x5t#S256']\n    }\n\n    return result\n  }\n\n  [JWK_MEMBERS] () {\n    const props = this[KEYOBJECT].type === 'private' ? this.constructor[PRIVATE_MEMBERS] : this.constructor[PUBLIC_MEMBERS]\n    Object.defineProperties(this, [...props].reduce((acc, component) => {\n      acc[component] = {\n        get () {\n          const jwk = keyObjectToJWK(this[KEYOBJECT])\n          Object.defineProperties(\n            this,\n            Object.entries(jwk)\n              .filter(([key]) => props.has(key))\n              .reduce((acc, [key, value]) => {\n                acc[key] = { value, enumerable: this.constructor[PUBLIC_MEMBERS].has(key), configurable: false }\n                return acc\n              }, {})\n          )\n\n          return this[component]\n        },\n        enumerable: this.constructor[PUBLIC_MEMBERS].has(component),\n        configurable: true\n      }\n      return acc\n    }, {}))\n  }\n\n  /* c8 ignore next 8 */\n  [inspect.custom] () {\n    return `${this.constructor.name} ${inspect(this.toJWK(false), {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`\n  }\n\n  /* c8 ignore next 3 */\n  [THUMBPRINT_MATERIAL] () {\n    throw new Error(`\"[THUMBPRINT_MATERIAL]()\" is not implemented on ${this.constructor.name}`)\n  }\n\n  algorithms (operation, /* the rest is private API */ int, opts) {\n    const { use = this.use, alg = this.alg, key_ops: ops = this.key_ops } = int === privateApi ? opts : {}\n    if (alg) {\n      return new Set(this.algorithms(operation, privateApi, { alg: null, use, key_ops: ops }).has(alg) ? [alg] : undefined)\n    }\n\n    if (typeof operation === 'symbol') {\n      try {\n        return this[operation]()\n      } catch (err) {\n        return new Set()\n      }\n    }\n\n    if (operation && ops && !ops.includes(operation)) {\n      return new Set()\n    }\n\n    switch (operation) {\n      case 'decrypt':\n      case 'deriveKey':\n      case 'encrypt':\n      case 'sign':\n      case 'unwrapKey':\n      case 'verify':\n      case 'wrapKey':\n        return new Set(Object.entries(JWK[this.kty][operation]).map(([alg, fn]) => fn(this) ? alg : undefined).filter(Boolean))\n      case undefined:\n        return new Set([\n          ...this.algorithms('sign'),\n          ...this.algorithms('verify'),\n          ...this.algorithms('decrypt'),\n          ...this.algorithms('encrypt'),\n          ...this.algorithms('unwrapKey'),\n          ...this.algorithms('wrapKey'),\n          ...this.algorithms('deriveKey')\n        ])\n      default:\n        throw new TypeError('invalid key operation')\n    }\n  }\n\n  /* c8 ignore next 3 */\n  static async generate () {\n    throw new Error(`\"static async generate()\" is not implemented on ${this.name}`)\n  }\n\n  /* c8 ignore next 3 */\n  static generateSync () {\n    throw new Error(`\"static generateSync()\" is not implemented on ${this.name}`)\n  }\n\n  /* c8 ignore next 3 */\n  static get [PUBLIC_MEMBERS] () {\n    throw new Error(`\"static get [PUBLIC_MEMBERS]()\" is not implemented on ${this.name}`)\n  }\n\n  /* c8 ignore next 3 */\n  static get [PRIVATE_MEMBERS] () {\n    throw new Error(`\"static get [PRIVATE_MEMBERS]()\" is not implemented on ${this.name}`)\n  }\n}\n\nmodule.exports = Key\n","const { generateKeyPairSync, generateKeyPair: async } = require('crypto')\nconst { promisify } = require('util')\n\nconst {\n  THUMBPRINT_MATERIAL, JWK_MEMBERS, PUBLIC_MEMBERS,\n  PRIVATE_MEMBERS, KEY_MANAGEMENT_DECRYPT, KEY_MANAGEMENT_ENCRYPT\n} = require('../../help/consts')\nconst { EC_CURVES } = require('../../registry')\nconst { keyObjectSupported } = require('../../help/runtime_support')\nconst { createPublicKey, createPrivateKey } = require('../../help/key_object')\n\nconst errors = require('../../errors')\n\nconst Key = require('./base')\n\nconst generateKeyPair = promisify(async)\n\nconst EC_PUBLIC = new Set(['crv', 'x', 'y'])\nObject.freeze(EC_PUBLIC)\nconst EC_PRIVATE = new Set([...EC_PUBLIC, 'd'])\nObject.freeze(EC_PRIVATE)\n\n// Elliptic Curve Key Type\nclass ECKey extends Key {\n  constructor (...args) {\n    super(...args)\n    this[JWK_MEMBERS]()\n    Object.defineProperty(this, 'kty', { value: 'EC', enumerable: true })\n    if (!EC_CURVES.has(this.crv)) {\n      throw new errors.JOSENotSupported('unsupported EC key curve')\n    }\n  }\n\n  static get [PUBLIC_MEMBERS] () {\n    return EC_PUBLIC\n  }\n\n  static get [PRIVATE_MEMBERS] () {\n    return EC_PRIVATE\n  }\n\n  // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special\n  // JSON.stringify handling in V8\n  [THUMBPRINT_MATERIAL] () {\n    return { crv: this.crv, kty: 'EC', x: this.x, y: this.y }\n  }\n\n  [KEY_MANAGEMENT_ENCRYPT] () {\n    return this.algorithms('deriveKey')\n  }\n\n  [KEY_MANAGEMENT_DECRYPT] () {\n    if (this.public) {\n      return new Set()\n    }\n    return this.algorithms('deriveKey')\n  }\n\n  static async generate (crv = 'P-256', privat = true) {\n    if (!EC_CURVES.has(crv)) {\n      throw new errors.JOSENotSupported(`unsupported EC key curve: ${crv}`)\n    }\n\n    let privateKey, publicKey\n\n    if (keyObjectSupported) {\n      ({ privateKey, publicKey } = await generateKeyPair('ec', { namedCurve: crv }))\n      return privat ? privateKey : publicKey\n    }\n\n    ({ privateKey, publicKey } = await generateKeyPair('ec', {\n      namedCurve: crv,\n      publicKeyEncoding: { type: 'spki', format: 'pem' },\n      privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n    }))\n\n    if (privat) {\n      return createPrivateKey(privateKey)\n    } else {\n      return createPublicKey(publicKey)\n    }\n  }\n\n  static generateSync (crv = 'P-256', privat = true) {\n    if (!EC_CURVES.has(crv)) {\n      throw new errors.JOSENotSupported(`unsupported EC key curve: ${crv}`)\n    }\n\n    let privateKey, publicKey\n\n    if (keyObjectSupported) {\n      ({ privateKey, publicKey } = generateKeyPairSync('ec', { namedCurve: crv }))\n      return privat ? privateKey : publicKey\n    }\n\n    ({ privateKey, publicKey } = generateKeyPairSync('ec', {\n      namedCurve: crv,\n      publicKeyEncoding: { type: 'spki', format: 'pem' },\n      privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n    }))\n\n    if (privat) {\n      return createPrivateKey(privateKey)\n    } else {\n      return createPublicKey(publicKey)\n    }\n  }\n}\n\nmodule.exports = ECKey\n","const { inspect } = require('util')\n\nconst Key = require('./base')\n\nclass EmbeddedJWK extends Key {\n  constructor () {\n    super({ type: 'embedded' })\n    Object.defineProperties(this, {\n      kid: { value: undefined },\n      kty: { value: undefined },\n      thumbprint: { value: undefined },\n      toJWK: { value: undefined },\n      toPEM: { value: undefined }\n    })\n  }\n\n  /* c8 ignore next 3 */\n  [inspect.custom] () {\n    return 'Embedded.JWK {}'\n  }\n\n  algorithms () {\n    return new Set()\n  }\n}\n\nmodule.exports = new EmbeddedJWK()\n","const { inspect } = require('util')\n\nconst Key = require('./base')\n\nclass EmbeddedX5C extends Key {\n  constructor () {\n    super({ type: 'embedded' })\n    Object.defineProperties(this, {\n      kid: { value: undefined },\n      kty: { value: undefined },\n      thumbprint: { value: undefined },\n      toJWK: { value: undefined },\n      toPEM: { value: undefined }\n    })\n  }\n\n  /* c8 ignore next 3 */\n  [inspect.custom] () {\n    return 'Embedded.X5C {}'\n  }\n\n  algorithms () {\n    return new Set()\n  }\n}\n\nmodule.exports = new EmbeddedX5C()\n","const { inspect } = require('util')\n\nconst Key = require('./base')\n\nclass NoneKey extends Key {\n  constructor () {\n    super({ type: 'unsecured' }, { alg: 'none' })\n    Object.defineProperties(this, {\n      kid: { value: undefined },\n      kty: { value: undefined },\n      thumbprint: { value: undefined },\n      toJWK: { value: undefined },\n      toPEM: { value: undefined }\n    })\n  }\n\n  /* c8 ignore next 3 */\n  [inspect.custom] () {\n    return 'None {}'\n  }\n\n  algorithms (operation) {\n    switch (operation) {\n      case 'sign':\n      case 'verify':\n      case undefined:\n        return new Set(['none'])\n      default:\n        return new Set()\n    }\n  }\n}\n\nmodule.exports = new NoneKey()\n","const { randomBytes } = require('crypto')\n\nconst { createSecretKey } = require('../../help/key_object')\nconst base64url = require('../../help/base64url')\nconst {\n  THUMBPRINT_MATERIAL, PUBLIC_MEMBERS, PRIVATE_MEMBERS,\n  KEY_MANAGEMENT_DECRYPT, KEY_MANAGEMENT_ENCRYPT, KEYOBJECT\n} = require('../../help/consts')\n\nconst Key = require('./base')\n\nconst OCT_PUBLIC = new Set()\nObject.freeze(OCT_PUBLIC)\nconst OCT_PRIVATE = new Set(['k'])\nObject.freeze(OCT_PRIVATE)\n\n// Octet sequence Key Type\nclass OctKey extends Key {\n  constructor (...args) {\n    super(...args)\n    Object.defineProperties(this, {\n      kty: {\n        value: 'oct',\n        enumerable: true\n      },\n      length: {\n        value: this[KEYOBJECT] ? this[KEYOBJECT].symmetricKeySize * 8 : undefined\n      },\n      k: {\n        enumerable: false,\n        get () {\n          if (this[KEYOBJECT]) {\n            Object.defineProperty(this, 'k', {\n              value: base64url.encodeBuffer(this[KEYOBJECT].export()),\n              configurable: false\n            })\n          } else {\n            Object.defineProperty(this, 'k', {\n              value: undefined,\n              configurable: false\n            })\n          }\n\n          return this.k\n        },\n        configurable: true\n      }\n    })\n  }\n\n  static get [PUBLIC_MEMBERS] () {\n    return OCT_PUBLIC\n  }\n\n  static get [PRIVATE_MEMBERS] () {\n    return OCT_PRIVATE\n  }\n\n  // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special\n  // JSON.stringify handling in V8\n  [THUMBPRINT_MATERIAL] () {\n    if (!this[KEYOBJECT]) {\n      throw new TypeError('reference \"oct\" keys without \"k\" cannot have their thumbprint calculated')\n    }\n    return { k: this.k, kty: 'oct' }\n  }\n\n  [KEY_MANAGEMENT_ENCRYPT] () {\n    return new Set([\n      ...this.algorithms('wrapKey'),\n      ...this.algorithms('deriveKey')\n    ])\n  }\n\n  [KEY_MANAGEMENT_DECRYPT] () {\n    return this[KEY_MANAGEMENT_ENCRYPT]()\n  }\n\n  algorithms (...args) {\n    if (!this[KEYOBJECT]) {\n      return new Set()\n    }\n\n    return Key.prototype.algorithms.call(this, ...args)\n  }\n\n  static async generate (...args) {\n    return this.generateSync(...args)\n  }\n\n  static generateSync (len = 256, privat = true) {\n    if (!privat) {\n      throw new TypeError('\"oct\" keys cannot be generated as public')\n    }\n    if (!Number.isSafeInteger(len) || !len || len % 8 !== 0) {\n      throw new TypeError('invalid bit length')\n    }\n\n    return createSecretKey(randomBytes(len / 8))\n  }\n}\n\nmodule.exports = OctKey\n","const { generateKeyPairSync, generateKeyPair: async } = require('crypto')\nconst { promisify } = require('util')\n\nconst {\n  THUMBPRINT_MATERIAL, JWK_MEMBERS, PUBLIC_MEMBERS,\n  PRIVATE_MEMBERS, KEY_MANAGEMENT_DECRYPT, KEY_MANAGEMENT_ENCRYPT\n} = require('../../help/consts')\nconst { OKP_CURVES } = require('../../registry')\nconst { edDSASupported } = require('../../help/runtime_support')\nconst errors = require('../../errors')\n\nconst Key = require('./base')\n\nconst generateKeyPair = promisify(async)\n\nconst OKP_PUBLIC = new Set(['crv', 'x'])\nObject.freeze(OKP_PUBLIC)\nconst OKP_PRIVATE = new Set([...OKP_PUBLIC, 'd'])\nObject.freeze(OKP_PRIVATE)\n\n// Octet string key pairs Key Type\nclass OKPKey extends Key {\n  constructor (...args) {\n    super(...args)\n    this[JWK_MEMBERS]()\n    Object.defineProperty(this, 'kty', { value: 'OKP', enumerable: true })\n    if (!OKP_CURVES.has(this.crv)) {\n      throw new errors.JOSENotSupported('unsupported OKP key curve')\n    }\n  }\n\n  static get [PUBLIC_MEMBERS] () {\n    return OKP_PUBLIC\n  }\n\n  static get [PRIVATE_MEMBERS] () {\n    return OKP_PRIVATE\n  }\n\n  // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special\n  // JSON.stringify handling in V8\n  [THUMBPRINT_MATERIAL] () {\n    return { crv: this.crv, kty: 'OKP', x: this.x }\n  }\n\n  [KEY_MANAGEMENT_ENCRYPT] () {\n    return this.algorithms('deriveKey')\n  }\n\n  [KEY_MANAGEMENT_DECRYPT] () {\n    if (this.public) {\n      return new Set()\n    }\n    return this.algorithms('deriveKey')\n  }\n\n  static async generate (crv = 'Ed25519', privat = true) {\n    if (!edDSASupported) {\n      throw new errors.JOSENotSupported('OKP keys are not supported in your Node.js runtime version')\n    }\n\n    if (!OKP_CURVES.has(crv)) {\n      throw new errors.JOSENotSupported(`unsupported OKP key curve: ${crv}`)\n    }\n\n    const { privateKey, publicKey } = await generateKeyPair(crv.toLowerCase())\n\n    return privat ? privateKey : publicKey\n  }\n\n  static generateSync (crv = 'Ed25519', privat = true) {\n    if (!edDSASupported) {\n      throw new errors.JOSENotSupported('OKP keys are not supported in your Node.js runtime version')\n    }\n\n    if (!OKP_CURVES.has(crv)) {\n      throw new errors.JOSENotSupported(`unsupported OKP key curve: ${crv}`)\n    }\n\n    const { privateKey, publicKey } = generateKeyPairSync(crv.toLowerCase())\n\n    return privat ? privateKey : publicKey\n  }\n}\n\nmodule.exports = OKPKey\n","const { generateKeyPairSync, generateKeyPair: async } = require('crypto')\nconst { promisify } = require('util')\n\nconst {\n  THUMBPRINT_MATERIAL, JWK_MEMBERS, PUBLIC_MEMBERS,\n  PRIVATE_MEMBERS, KEY_MANAGEMENT_DECRYPT, KEY_MANAGEMENT_ENCRYPT\n} = require('../../help/consts')\nconst { keyObjectSupported } = require('../../help/runtime_support')\nconst { createPublicKey, createPrivateKey } = require('../../help/key_object')\n\nconst Key = require('./base')\n\nconst generateKeyPair = promisify(async)\n\nconst RSA_PUBLIC = new Set(['e', 'n'])\nObject.freeze(RSA_PUBLIC)\nconst RSA_PRIVATE = new Set([...RSA_PUBLIC, 'd', 'p', 'q', 'dp', 'dq', 'qi'])\nObject.freeze(RSA_PRIVATE)\n\n// RSA Key Type\nclass RSAKey extends Key {\n  constructor (...args) {\n    super(...args)\n    this[JWK_MEMBERS]()\n    Object.defineProperties(this, {\n      kty: {\n        value: 'RSA',\n        enumerable: true\n      },\n      length: {\n        get () {\n          Object.defineProperty(this, 'length', {\n            value: Buffer.byteLength(this.n, 'base64') * 8,\n            configurable: false\n          })\n\n          return this.length\n        },\n        configurable: true\n      }\n    })\n  }\n\n  static get [PUBLIC_MEMBERS] () {\n    return RSA_PUBLIC\n  }\n\n  static get [PRIVATE_MEMBERS] () {\n    return RSA_PRIVATE\n  }\n\n  // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special\n  // JSON.stringify handling in V8\n  [THUMBPRINT_MATERIAL] () {\n    return { e: this.e, kty: 'RSA', n: this.n }\n  }\n\n  [KEY_MANAGEMENT_ENCRYPT] () {\n    return this.algorithms('wrapKey')\n  }\n\n  [KEY_MANAGEMENT_DECRYPT] () {\n    return this.algorithms('unwrapKey')\n  }\n\n  static async generate (len = 2048, privat = true) {\n    if (!Number.isSafeInteger(len) || len < 512 || len % 8 !== 0 || (('electron' in process.versions) && len % 128 !== 0)) {\n      throw new TypeError('invalid bit length')\n    }\n\n    let privateKey, publicKey\n\n    if (keyObjectSupported) {\n      ({ privateKey, publicKey } = await generateKeyPair('rsa', { modulusLength: len }))\n      return privat ? privateKey : publicKey\n    }\n\n    ({ privateKey, publicKey } = await generateKeyPair('rsa', {\n      modulusLength: len,\n      publicKeyEncoding: { type: 'spki', format: 'pem' },\n      privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n    }))\n\n    if (privat) {\n      return createPrivateKey(privateKey)\n    } else {\n      return createPublicKey(publicKey)\n    }\n  }\n\n  static generateSync (len = 2048, privat = true) {\n    if (!Number.isSafeInteger(len) || len < 512 || len % 8 !== 0 || (('electron' in process.versions) && len % 128 !== 0)) {\n      throw new TypeError('invalid bit length')\n    }\n\n    let privateKey, publicKey\n\n    if (keyObjectSupported) {\n      ({ privateKey, publicKey } = generateKeyPairSync('rsa', { modulusLength: len }))\n      return privat ? privateKey : publicKey\n    }\n\n    ({ privateKey, publicKey } = generateKeyPairSync('rsa', {\n      modulusLength: len,\n      publicKeyEncoding: { type: 'spki', format: 'pem' },\n      privateKeyEncoding: { type: 'pkcs8', format: 'pem' }\n    }))\n\n    if (privat) {\n      return createPrivateKey(privateKey)\n    } else {\n      return createPublicKey(publicKey)\n    }\n  }\n}\n\nmodule.exports = RSAKey\n","const { createHash } = require('crypto')\n\nconst base64url = require('../help/base64url')\n\nconst x5t = (hash, cert) => base64url.encodeBuffer(createHash(hash).update(Buffer.from(cert, 'base64')).digest())\n\nmodule.exports.kid = components => base64url.encodeBuffer(createHash('sha256').update(JSON.stringify(components)).digest())\nmodule.exports.x5t = x5t.bind(undefined, 'sha1')\nmodule.exports['x5t#S256'] = x5t.bind(undefined, 'sha256')\n","const KeyStore = require('./keystore')\n\nmodule.exports = KeyStore\n","const { inspect } = require('util')\n\nconst isObject = require('../help/is_object')\nconst { generate, generateSync } = require('../jwk/generate')\nconst { USES_MAPPING } = require('../help/consts')\nconst { isKey, asKey: importKey } = require('../jwk')\n\nconst keyscore = (key, { alg, use, ops }) => {\n  let score = 0\n\n  if (alg && key.alg) {\n    score++\n  }\n\n  if (use && key.use) {\n    score++\n  }\n\n  if (ops && key.key_ops) {\n    score++\n  }\n\n  return score\n}\n\nclass KeyStore {\n  constructor (...keys) {\n    while (keys.some(Array.isArray)) {\n      keys = keys.flat\n        ? keys.flat()\n        : keys.reduce((acc, val) => {\n          if (Array.isArray(val)) {\n            return [...acc, ...val]\n          }\n\n          acc.push(val)\n          return acc\n        }, [])\n    }\n    if (keys.some(k => !isKey(k) || !k.kty)) {\n      throw new TypeError('all keys must be instances of a key instantiated by JWK.asKey')\n    }\n\n    this._keys = new Set(keys)\n  }\n\n  all ({ alg, kid, thumbprint, use, kty, key_ops: ops, x5t, 'x5t#S256': x5t256, crv } = {}) {\n    if (ops !== undefined && (!Array.isArray(ops) || !ops.length || ops.some(x => typeof x !== 'string'))) {\n      throw new TypeError('`key_ops` must be a non-empty array of strings')\n    }\n\n    const search = { alg, use, ops }\n    return [...this._keys]\n      .filter((key) => {\n        let candidate = true\n\n        if (candidate && kid !== undefined && key.kid !== kid) {\n          candidate = false\n        }\n\n        if (candidate && thumbprint !== undefined && key.thumbprint !== thumbprint) {\n          candidate = false\n        }\n\n        if (candidate && x5t !== undefined && key.x5t !== x5t) {\n          candidate = false\n        }\n\n        if (candidate && x5t256 !== undefined && key['x5t#S256'] !== x5t256) {\n          candidate = false\n        }\n\n        if (candidate && kty !== undefined && key.kty !== kty) {\n          candidate = false\n        }\n\n        if (candidate && crv !== undefined && (key.crv !== crv)) {\n          candidate = false\n        }\n\n        if (alg !== undefined && !key.algorithms().has(alg)) {\n          candidate = false\n        }\n\n        if (candidate && use !== undefined && (key.use !== undefined && key.use !== use)) {\n          candidate = false\n        }\n\n        // TODO:\n        if (candidate && ops !== undefined && (key.key_ops !== undefined || key.use !== undefined)) {\n          let keyOps\n          if (key.key_ops) {\n            keyOps = new Set(key.key_ops)\n          } else {\n            keyOps = USES_MAPPING[key.use]\n          }\n          if (ops.some(x => !keyOps.has(x))) {\n            candidate = false\n          }\n        }\n\n        return candidate\n      })\n      .sort((first, second) => keyscore(second, search) - keyscore(first, search))\n  }\n\n  get (...args) {\n    return this.all(...args)[0]\n  }\n\n  add (key) {\n    if (!isKey(key) || !key.kty) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey')\n    }\n\n    this._keys.add(key)\n  }\n\n  remove (key) {\n    if (!isKey(key)) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey')\n    }\n\n    this._keys.delete(key)\n  }\n\n  toJWKS (priv = false) {\n    return {\n      keys: [...this._keys.values()].map(\n        key => key.toJWK(priv && (key.private || (key.secret && key.k)))\n      )\n    }\n  }\n\n  async generate (...args) {\n    this._keys.add(await generate(...args))\n  }\n\n  generateSync (...args) {\n    this._keys.add(generateSync(...args))\n  }\n\n  get size () {\n    return this._keys.size\n  }\n\n  /* c8 ignore next 8 */\n  [inspect.custom] () {\n    return `${this.constructor.name} ${inspect(this.toJWKS(false), {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`\n  }\n\n  * [Symbol.iterator] () {\n    for (const key of this._keys) {\n      yield key\n    }\n  }\n}\n\nfunction asKeyStore (jwks, { ignoreErrors = false, calculateMissingRSAPrimes = false } = {}) {\n  if (!isObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some(k => !isObject(k) || !('kty' in k))) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object')\n  }\n\n  const keys = jwks.keys.map((jwk) => {\n    try {\n      return importKey(jwk, { calculateMissingRSAPrimes })\n    } catch (err) {\n      if (!ignoreErrors) {\n        throw err\n      }\n      return undefined\n    }\n  }).filter(Boolean)\n\n  return new KeyStore(...keys)\n}\n\nmodule.exports = { KeyStore, asKeyStore }\n","const Sign = require('./sign')\nconst { verify } = require('./verify')\n\nconst single = (serialization, payload, key, protectedHeader, unprotectedHeader) => {\n  return new Sign(payload)\n    .recipient(key, protectedHeader, unprotectedHeader)\n    .sign(serialization)\n}\n\nmodule.exports.Sign = Sign\nmodule.exports.sign = single.bind(undefined, 'compact')\nmodule.exports.sign.flattened = single.bind(undefined, 'flattened')\nmodule.exports.sign.general = single.bind(undefined, 'general')\n\nmodule.exports.verify = verify\n","const isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\nconst { JWSInvalid } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWSInvalid)\n\nconst compactSerializer = (payload, [recipient]) => {\n  return `${recipient.protected}.${payload}.${recipient.signature}`\n}\ncompactSerializer.validate = (jws, { 0: { unprotectedHeader, protectedHeader }, length }) => {\n  if (length !== 1 || unprotectedHeader) {\n    throw new JWSInvalid('JWS Compact Serialization doesn\\'t support multiple recipients or JWS unprotected headers')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst flattenedSerializer = (payload, [recipient]) => {\n  const { header, signature, protected: prot } = recipient\n\n  return {\n    payload,\n    ...prot ? { protected: prot } : undefined,\n    ...header ? { header } : undefined,\n    signature\n  }\n}\nflattenedSerializer.validate = (jws, { 0: { unprotectedHeader, protectedHeader }, length }) => {\n  if (length !== 1) {\n    throw new JWSInvalid('Flattened JWS JSON Serialization doesn\\'t support multiple recipients')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst generalSerializer = (payload, recipients) => {\n  return {\n    payload,\n    signatures: recipients.map(({ header, signature, protected: prot }) => {\n      return {\n        ...prot ? { protected: prot } : undefined,\n        ...header ? { header } : undefined,\n        signature\n      }\n    })\n  }\n}\ngeneralSerializer.validate = (jws, recipients) => {\n  let validateB64 = false\n  recipients.forEach(({ protectedHeader, unprotectedHeader }) => {\n    if (protectedHeader && !validateB64 && 'b64' in protectedHeader) {\n      validateB64 = true\n    }\n    validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n  })\n\n  if (validateB64) {\n    const values = recipients.map(({ protectedHeader }) => protectedHeader && protectedHeader.b64)\n    if (!values.every((actual, i, [expected]) => actual === expected)) {\n      throw new JWSInvalid('the \"b64\" Header Parameter value MUST be the same for all recipients')\n    }\n  }\n}\n\nconst isJSON = (input) => {\n  return isObject(input) && (typeof input.payload === 'string' || Buffer.isBuffer(input.payload))\n}\n\nconst isValidRecipient = (recipient) => {\n  return isObject(recipient) && typeof recipient.signature === 'string' &&\n    (recipient.header === undefined || isObject(recipient.header)) &&\n    (recipient.protected === undefined || typeof recipient.protected === 'string')\n}\n\nconst isMultiRecipient = (input) => {\n  if (Array.isArray(input.signatures) && input.signatures.every(isValidRecipient)) {\n    return true\n  }\n\n  return false\n}\n\nconst detect = (input) => {\n  if (typeof input === 'string' && input.split('.').length === 3) {\n    return 'compact'\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general'\n    }\n\n    if (isValidRecipient(input)) {\n      return 'flattened'\n    }\n  }\n\n  throw new JWSInvalid('JWS malformed or invalid serialization')\n}\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n}\n","const base64url = require('../help/base64url')\nconst isDisjoint = require('../help/is_disjoint')\nconst isObject = require('../help/is_object')\nconst deepClone = require('../help/deep_clone')\nconst { JWSInvalid } = require('../errors')\nconst { sign } = require('../jwa')\nconst getKey = require('../help/get_key')\n\nconst serializers = require('./serializers')\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')\n\nclass Sign {\n  constructor (payload) {\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload)\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload)\n      this._binary = true\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload)\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object')\n    }\n\n    this._payload = payload\n    this._recipients = []\n  }\n\n  /*\n   * @public\n   */\n  recipient (key, protectedHeader, unprotectedHeader) {\n    key = getKey(key)\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided')\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided')\n    }\n\n    if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')\n    }\n\n    this._recipients.push({\n      key,\n      protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n      unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    })\n\n    return this\n  }\n\n  /*\n   * @private\n   */\n  [PROCESS_RECIPIENT] (recipient, first) {\n    const { key, protectedHeader, unprotectedHeader } = recipient\n\n    if (key.use === 'enc') {\n      throw new TypeError('a key with \"use\":\"enc\" is not usable for signing')\n    }\n\n    const joseHeader = {\n      protected: protectedHeader || {},\n      unprotected: unprotectedHeader || {}\n    }\n\n    let alg = joseHeader.protected.alg || joseHeader.unprotected.alg\n\n    if (!alg) {\n      alg = key.alg || [...key.algorithms('sign')][0]\n      if (recipient.protectedHeader) {\n        joseHeader.protected.alg = recipient.protectedHeader.alg = alg\n      } else {\n        joseHeader.protected = recipient.protectedHeader = { alg }\n      }\n    }\n\n    if (!alg) {\n      throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient')\n    }\n\n    recipient.header = unprotectedHeader\n    recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : ''\n\n    if (first && joseHeader.protected.crit && joseHeader.protected.crit.includes('b64') && joseHeader.protected.b64 === false) {\n      if (this._binary) {\n        this._payload = base64url.decodeToBuffer(this._payload)\n      } else {\n        this._payload = base64url.decode(this._payload)\n      }\n    }\n\n    const data = Buffer.concat([\n      Buffer.from(recipient.protected || ''),\n      Buffer.from('.'),\n      Buffer.from(this._payload)\n    ])\n\n    recipient.signature = base64url.encodeBuffer(sign(alg, key, data))\n  }\n\n  /*\n   * @public\n   */\n  sign (serialization) {\n    const serializer = serializers[serialization]\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"')\n    }\n\n    if (!this._recipients.length) {\n      throw new JWSInvalid('missing recipients')\n    }\n\n    serializer.validate(this, this._recipients)\n\n    this._recipients.forEach((recipient, i) => {\n      this[PROCESS_RECIPIENT](recipient, i === 0)\n    })\n\n    return serializer(this._payload, this._recipients)\n  }\n}\n\nmodule.exports = Sign\n","const { EOL } = require('os')\n\nconst base64url = require('../help/base64url')\nconst isDisjoint = require('../help/is_disjoint')\nconst isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, verify } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { detect: resolveSerialization } = require('./serializers')\n\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid)\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed'])\n\n/*\n * @public\n */\nconst jwsVerify = (skipDisjointCheck, serialization, jws, key, { crit = [], complete = false, algorithms } = {}) => {\n  key = getKey(key, true)\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings')\n  } else if (algorithms) {\n    algorithms = new Set(algorithms)\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jws)\n  }\n\n  let prot // protected header\n  let header // unprotected header\n  let payload\n  let signature\n  let alg\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened'\n    const { signatures, ...root } = jws\n    jws = { ...root, ...signatures[0] }\n  }\n\n  let decoded\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    let parsedProt = {}\n\n    switch (serialization) {\n      case 'compact': // compact serialization format\n        ([prot, payload, signature] = jws.split('.'))\n        break\n      case 'flattened': // flattened serialization format\n        ({ protected: prot, payload, signature, header } = jws)\n        break\n      case 'preparsed': { // from the JWT module\n        ({ decoded } = jws);\n        ([prot, payload, signature] = jws.token.split('.'))\n        break\n      }\n    }\n\n    if (!header) {\n      skipDisjointCheck = true\n    }\n\n    if (decoded) {\n      parsedProt = decoded.header\n    } else if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot)\n      } catch (err) {\n        throw new errors.JWSInvalid('could not parse JWS protected header')\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true\n    }\n\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')\n    }\n\n    const combinedHeader = { ...parsedProt, ...header }\n    validateCrit(parsedProt, header, crit)\n\n    alg = parsedProt.alg || (header && header.alg)\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm')\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      const keys = keystore.all({ kid: combinedHeader.kid, alg: combinedHeader.alg, key_ops: ['verify'] })\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jwsVerify(true, serialization, jws, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n            throw new errors.JWSVerificationFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    if (key === JWK.EmbeddedJWK) {\n      if (!isObject(combinedHeader.jwk)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object')\n      }\n      key = JWK.asKey(combinedHeader.jwk)\n      if (key.type !== 'public') {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key')\n      }\n    } else if (key === JWK.EmbeddedX5C) {\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(c => typeof c !== 'string' || !c)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings')\n      }\n      key = JWK.asKey(\n        `-----BEGIN CERTIFICATE-----${EOL}${(combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END CERTIFICATE-----`,\n        { x5c: combinedHeader.x5c }\n      )\n    }\n\n    check(key, 'verify', alg)\n\n    const toBeVerified = Buffer.concat([\n      Buffer.from(prot || ''),\n      Buffer.from('.'),\n      Buffer.isBuffer(payload) ? payload : Buffer.from(payload)\n    ])\n\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed()\n    }\n\n    if (combinedHeader.b64 === false) {\n      payload = Buffer.from(payload)\n    } else {\n      payload = base64url.decodeToBuffer(payload)\n    }\n\n    if (complete) {\n      const result = { payload, key }\n      if (prot) result.protected = parsedProt\n      if (header) result.header = header\n      return result\n    }\n\n    return payload\n  }\n\n  // general serialization format\n  const { signatures, ...root } = jws\n  const errs = []\n  for (const recipient of signatures) {\n    try {\n      return jwsVerify(false, 'flattened', { ...root, ...recipient }, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n    throw new errors.JWSVerificationFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = {\n  bare: jwsVerify,\n  verify: jwsVerify.bind(undefined, false, undefined)\n}\n","const base64url = require('../help/base64url')\nconst errors = require('../errors')\n\nmodule.exports = (token, { complete = false } = {}) => {\n  if (typeof token !== 'string' || !token) {\n    throw new TypeError('JWT must be a string')\n  }\n\n  const { 0: header, 1: payload, 2: signature, length } = token.split('.')\n\n  if (length === 5) {\n    throw new TypeError('encrypted JWTs cannot be decoded')\n  }\n\n  if (length !== 3) {\n    throw new errors.JWTMalformed('JWTs must have three components')\n  }\n\n  try {\n    const result = {\n      header: base64url.JSON.decode(header),\n      payload: base64url.JSON.decode(payload),\n      signature\n    }\n\n    return complete ? result : result.payload\n  } catch (err) {\n    throw new errors.JWTMalformed('JWT is malformed')\n  }\n}\n","const decode = require('./decode')\nconst sign = require('./sign')\nconst verify = require('./verify')\nconst profiles = require('./profiles')\n\nmodule.exports = {\n  sign,\n  verify,\n  ...profiles\n}\n\nObject.defineProperty(module.exports, 'decode', {\n  enumerable: false,\n  configurable: true,\n  value: decode\n})\n","const { JWTClaimInvalid } = require('../errors')\nconst secs = require('../help/secs')\nconst epoch = require('../help/epoch')\nconst isObject = require('../help/is_object')\n\nconst verify = require('./verify')\nconst {\n  isString,\n  isRequired,\n  isTimestamp,\n  isStringOrArrayOfStrings\n} = require('./shared_validations')\n\nconst isPayloadRequired = isRequired.bind(undefined, JWTClaimInvalid)\nconst isPayloadString = isString.bind(undefined, JWTClaimInvalid)\nconst isOptionString = isString.bind(undefined, TypeError)\n\nconst defineLazyExportWithWarning = (obj, property, name, definition) => {\n  Object.defineProperty(obj, property, {\n    enumerable: true,\n    configurable: true,\n    value (...args) {\n      process.emitWarning(\n        `The ${name} API implements an IETF draft. Breaking draft implementations are included as minor versions of the jose library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.`,\n        'DraftWarning'\n      )\n      Object.defineProperty(obj, property, {\n        enumerable: true,\n        configurable: true,\n        value: definition\n      })\n      return obj[property](...args)\n    }\n  })\n}\n\nconst validateCommonOptions = (options, profile) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object')\n  }\n\n  if (!options.issuer) {\n    throw new TypeError(`\"issuer\" option is required to validate ${profile}`)\n  }\n\n  if (!options.audience) {\n    throw new TypeError(`\"audience\" option is required to validate ${profile}`)\n  }\n}\n\nmodule.exports = {\n  IdToken: {\n    verify: (token, key, options = {}) => {\n      validateCommonOptions(options, 'an ID Token')\n\n      if ('maxAuthAge' in options) {\n        isOptionString(options.maxAuthAge, 'options.maxAuthAge')\n      }\n      if ('nonce' in options) {\n        isOptionString(options.nonce, 'options.nonce')\n      }\n\n      const unix = epoch(options.now || new Date())\n      const result = verify(token, key, { ...options })\n      const payload = options.complete ? result.payload : result\n\n      if (Array.isArray(payload.aud) && payload.aud.length > 1) {\n        isPayloadRequired(payload.azp, '\"azp\" claim', 'azp')\n      }\n      isPayloadRequired(payload.iat, '\"iat\" claim', 'iat')\n      isPayloadRequired(payload.sub, '\"sub\" claim', 'sub')\n      isPayloadRequired(payload.exp, '\"exp\" claim', 'exp')\n      isTimestamp(payload.auth_time, 'auth_time', !!options.maxAuthAge)\n      isPayloadString(payload.nonce, '\"nonce\" claim', 'nonce', !!options.nonce)\n      isPayloadString(payload.acr, '\"acr\" claim', 'acr')\n      isStringOrArrayOfStrings(payload.amr, 'amr')\n\n      if (options.nonce && payload.nonce !== options.nonce) {\n        throw new JWTClaimInvalid('unexpected \"nonce\" claim value', 'nonce', 'check_failed')\n      }\n\n      const tolerance = options.clockTolerance ? secs(options.clockTolerance) : 0\n\n      if (options.maxAuthAge) {\n        const maxAuthAgeSeconds = secs(options.maxAuthAge)\n        if (payload.auth_time + maxAuthAgeSeconds < unix - tolerance) {\n          throw new JWTClaimInvalid('\"auth_time\" claim timestamp check failed (too much time has elapsed since the last End-User authentication)', 'auth_time', 'check_failed')\n        }\n      }\n\n      if (Array.isArray(payload.aud) && payload.aud.length > 1 && payload.azp !== options.audience) {\n        throw new JWTClaimInvalid('unexpected \"azp\" claim value', 'azp', 'check_failed')\n      }\n\n      return result\n    }\n  },\n  LogoutToken: {},\n  AccessToken: {}\n}\n\ndefineLazyExportWithWarning(module.exports.LogoutToken, 'verify', 'jose.JWT.LogoutToken.verify', (token, key, options = {}) => {\n  validateCommonOptions(options, 'a Logout Token')\n\n  const result = verify(token, key, { ...options })\n  const payload = options.complete ? result.payload : result\n\n  isPayloadRequired(payload.iat, '\"iat\" claim', 'iat')\n  isPayloadRequired(payload.jti, '\"jti\" claim', 'jti')\n  isPayloadString(payload.sid, '\"sid\" claim', 'sid')\n\n  if (!('sid' in payload) && !('sub' in payload)) {\n    throw new JWTClaimInvalid('either \"sid\" or \"sub\" (or both) claims must be present')\n  }\n\n  if ('nonce' in payload) {\n    throw new JWTClaimInvalid('\"nonce\" claim is prohibited', 'nonce', 'prohibited')\n  }\n\n  if (!('events' in payload)) {\n    throw new JWTClaimInvalid('\"events\" claim is missing', 'events', 'missing')\n  }\n\n  if (!isObject(payload.events)) {\n    throw new JWTClaimInvalid('\"events\" claim must be an object', 'events', 'invalid')\n  }\n\n  if (!('http://schemas.openid.net/event/backchannel-logout' in payload.events)) {\n    throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member is missing in the \"events\" claim', 'events', 'invalid')\n  }\n\n  if (!isObject(payload.events['http://schemas.openid.net/event/backchannel-logout'])) {\n    throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member in the \"events\" claim must be an object', 'events', 'invalid')\n  }\n\n  return result\n})\n\ndefineLazyExportWithWarning(module.exports.AccessToken, 'verify', 'jose.JWT.AccessToken.verify', (token, key, options = {}) => {\n  validateCommonOptions(options, 'a JWT Access Token')\n\n  isOptionString(options.maxAuthAge, 'options.maxAuthAge')\n\n  const unix = epoch(options.now || new Date())\n  const typ = 'at+JWT'\n  const result = verify(token, key, { ...options, typ })\n  const payload = options.complete ? result.payload : result\n\n  isPayloadRequired(payload.iat, '\"iat\" claim', 'iat')\n  isPayloadRequired(payload.exp, '\"exp\" claim', 'exp')\n  isPayloadRequired(payload.sub, '\"sub\" claim', 'sub')\n  isPayloadRequired(payload.jti, '\"jti\" claim', 'jti')\n  isPayloadString(payload.client_id, '\"client_id\" claim', 'client_id', true)\n  isTimestamp(payload.auth_time, 'auth_time', !!options.maxAuthAge)\n  isPayloadString(payload.acr, '\"acr\" claim', 'acr')\n  isStringOrArrayOfStrings(payload.amr, 'amr')\n\n  const tolerance = options.clockTolerance ? secs(options.clockTolerance) : 0\n\n  if (options.maxAuthAge) {\n    const maxAuthAgeSeconds = secs(options.maxAuthAge)\n    if (payload.auth_time + maxAuthAgeSeconds < unix - tolerance) {\n      throw new JWTClaimInvalid('\"auth_time\" claim timestamp check failed (too much time has elapsed since the last End-User authentication)', 'auth_time', 'check_failed')\n    }\n  }\n\n  return result\n})\n","const { JWTClaimInvalid } = require('../errors')\n\nconst isNotString = val => typeof val !== 'string' || val.length === 0\nconst isNotArrayOfStrings = val => !Array.isArray(val) || val.length === 0 || val.some(isNotString)\nconst isRequired = (Err, value, label, claim) => {\n  if (value === undefined) {\n    throw new Err(`${label} is missing`, claim, 'missing')\n  }\n}\nconst isString = (Err, value, label, claim, required = false) => {\n  if (required) {\n    isRequired(Err, value, label, claim)\n  }\n\n  if (value !== undefined && isNotString(value)) {\n    throw new Err(`${label} must be a string`, claim, 'invalid')\n  }\n}\nconst isTimestamp = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(`\"${label}\" claim is missing`, label, 'missing')\n  }\n\n  if (value !== undefined && (typeof value !== 'number')) {\n    throw new JWTClaimInvalid(`\"${label}\" claim must be a JSON numeric value`, label, 'invalid')\n  }\n}\nconst isStringOrArrayOfStrings = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(`\"${label}\" claim is missing`, label, 'missing')\n  }\n\n  if (value !== undefined && (isNotString(value) && isNotArrayOfStrings(value))) {\n    throw new JWTClaimInvalid(`\"${label}\" claim must be a string or array of strings`, label, 'invalid')\n  }\n}\n\nmodule.exports = {\n  isNotArrayOfStrings,\n  isRequired,\n  isNotString,\n  isString,\n  isTimestamp,\n  isStringOrArrayOfStrings\n}\n","const isObject = require('../help/is_object')\nconst secs = require('../help/secs')\nconst epoch = require('../help/epoch')\nconst getKey = require('../help/get_key')\nconst JWS = require('../jws')\n\nconst isString = require('./shared_validations').isString.bind(undefined, TypeError)\n\nconst validateOptions = (options) => {\n  if (typeof options.iat !== 'boolean') {\n    throw new TypeError('options.iat must be a boolean')\n  }\n\n  if (typeof options.kid !== 'boolean') {\n    throw new TypeError('options.kid must be a boolean')\n  }\n\n  isString(options.subject, 'options.subject')\n  isString(options.issuer, 'options.issuer')\n\n  if (\n    options.audience !== undefined &&\n    (\n      (typeof options.audience !== 'string' || !options.audience) &&\n      (!Array.isArray(options.audience) || options.audience.length === 0 || options.audience.some(a => !a || typeof a !== 'string'))\n    )\n  ) {\n    throw new TypeError('options.audience must be a string or an array of strings')\n  }\n\n  if (!isObject(options.header)) {\n    throw new TypeError('options.header must be an object')\n  }\n\n  isString(options.algorithm, 'options.algorithm')\n  isString(options.expiresIn, 'options.expiresIn')\n  isString(options.notBefore, 'options.notBefore')\n  isString(options.jti, 'options.jti')\n\n  if (options.now !== undefined && (!(options.now instanceof Date) || !options.now.getTime())) {\n    throw new TypeError('options.now must be a valid Date object')\n  }\n}\n\nmodule.exports = (payload, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object')\n  }\n\n  const {\n    algorithm, audience, expiresIn, header = {}, iat = true,\n    issuer, jti, kid = true, notBefore, subject, now\n  } = options\n\n  validateOptions({\n    algorithm, audience, expiresIn, header, iat, issuer, jti, kid, notBefore, now, subject\n  })\n\n  if (!isObject(payload)) {\n    throw new TypeError('payload must be an object')\n  }\n\n  let unix\n  if (expiresIn || notBefore || iat) {\n    unix = epoch(now || new Date())\n  }\n\n  payload = {\n    ...payload,\n    sub: subject || payload.sub,\n    aud: audience || payload.aud,\n    iss: issuer || payload.iss,\n    jti: jti || payload.jti,\n    iat: iat ? unix : payload.iat,\n    exp: expiresIn ? unix + secs(expiresIn) : payload.exp,\n    nbf: notBefore ? unix + secs(notBefore) : payload.nbf\n  }\n\n  key = getKey(key)\n\n  let includeKid\n\n  if (typeof options.kid === 'boolean') {\n    includeKid = kid\n  } else {\n    includeKid = !key.secret\n  }\n\n  return JWS.sign(JSON.stringify(payload), key, {\n    ...header,\n    alg: algorithm || header.alg,\n    kid: includeKid ? key.kid : header.kid\n  })\n}\n","const isObject = require('../help/is_object')\nconst epoch = require('../help/epoch')\nconst secs = require('../help/secs')\nconst getKey = require('../help/get_key')\nconst { bare: verify } = require('../jws/verify')\nconst { JWTClaimInvalid, JWTExpired } = require('../errors')\n\nconst {\n  isString,\n  isNotString,\n  isNotArrayOfStrings,\n  isTimestamp,\n  isStringOrArrayOfStrings\n} = require('./shared_validations')\nconst decode = require('./decode')\n\nconst isPayloadString = isString.bind(undefined, JWTClaimInvalid)\nconst isOptionString = isString.bind(undefined, TypeError)\n\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '')\n\nconst validateOptions = ({\n  algorithms, audience, clockTolerance, complete = false, crit, ignoreExp = false,\n  ignoreIat = false, ignoreNbf = false, issuer, jti, maxTokenAge, now = new Date(),\n  subject, typ\n}) => {\n  if (typeof complete !== 'boolean') {\n    throw new TypeError('options.complete must be a boolean')\n  }\n\n  if (typeof ignoreExp !== 'boolean') {\n    throw new TypeError('options.ignoreExp must be a boolean')\n  }\n\n  if (typeof ignoreNbf !== 'boolean') {\n    throw new TypeError('options.ignoreNbf must be a boolean')\n  }\n\n  if (typeof ignoreIat !== 'boolean') {\n    throw new TypeError('options.ignoreIat must be a boolean')\n  }\n\n  isOptionString(maxTokenAge, 'options.maxTokenAge')\n  isOptionString(subject, 'options.subject')\n  isOptionString(jti, 'options.jti')\n  isOptionString(clockTolerance, 'options.clockTolerance')\n  isOptionString(typ, 'options.typ')\n\n  if (issuer !== undefined && (isNotString(issuer) && isNotArrayOfStrings(issuer))) {\n    throw new TypeError('options.issuer must be a string or an array of strings')\n  }\n\n  if (audience !== undefined && (isNotString(audience) && isNotArrayOfStrings(audience))) {\n    throw new TypeError('options.audience must be a string or an array of strings')\n  }\n\n  if (algorithms !== undefined && isNotArrayOfStrings(algorithms)) {\n    throw new TypeError('options.algorithms must be an array of strings')\n  }\n\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object')\n  }\n\n  if (ignoreIat && maxTokenAge !== undefined) {\n    throw new TypeError('options.ignoreIat and options.maxTokenAge cannot used together')\n  }\n\n  if (crit !== undefined && isNotArrayOfStrings(crit)) {\n    throw new TypeError('options.crit must be an array of strings')\n  }\n\n  return {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxTokenAge,\n    now,\n    subject,\n    typ\n  }\n}\n\nconst validateTypes = ({ header, payload }, options) => {\n  isPayloadString(header.alg, '\"alg\" header parameter', 'alg', true)\n\n  isTimestamp(payload.iat, 'iat', !!options.maxTokenAge)\n  isTimestamp(payload.exp, 'exp')\n  isTimestamp(payload.nbf, 'nbf')\n  isPayloadString(payload.jti, '\"jti\" claim', 'jti', !!options.jti)\n  isStringOrArrayOfStrings(payload.iss, 'iss', !!options.issuer)\n  isPayloadString(payload.sub, '\"sub\" claim', 'sub', !!options.subject)\n  isStringOrArrayOfStrings(payload.aud, 'aud', !!options.audience)\n  isPayloadString(header.typ, '\"typ\" header parameter', 'typ', !!options.typ)\n}\n\nconst checkAudiencePresence = (audPayload, audOption) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload)\n  }\n\n  // Each principal intended to process the JWT MUST\n  // identify itself with a value in the audience claim\n  audPayload = new Set(audPayload)\n  return audOption.some(Set.prototype.has.bind(audPayload))\n}\n\nmodule.exports = (token, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object')\n  }\n\n  const {\n    algorithms, audience, clockTolerance, complete, crit, ignoreExp, ignoreIat, ignoreNbf, issuer,\n    jti, maxTokenAge, now, subject, typ\n  } = options = validateOptions(options)\n\n  const decoded = decode(token, { complete: true })\n  key = getKey(key, true)\n\n  if (complete) {\n    ({ key } = verify(true, 'preparsed', { decoded, token }, key, { crit, algorithms, complete: true }))\n    decoded.key = key\n  } else {\n    verify(true, 'preparsed', { decoded, token }, key, { crit, algorithms })\n  }\n\n  const unix = epoch(now)\n  validateTypes(decoded, options)\n\n  if (issuer && (typeof decoded.payload.iss !== 'string' || !(typeof issuer === 'string' ? [issuer] : issuer).includes(decoded.payload.iss))) {\n    throw new JWTClaimInvalid('unexpected \"iss\" claim value', 'iss', 'check_failed')\n  }\n\n  if (subject && decoded.payload.sub !== subject) {\n    throw new JWTClaimInvalid('unexpected \"sub\" claim value', 'sub', 'check_failed')\n  }\n\n  if (jti && decoded.payload.jti !== jti) {\n    throw new JWTClaimInvalid('unexpected \"jti\" claim value', 'jti', 'check_failed')\n  }\n\n  if (audience && !checkAudiencePresence(decoded.payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimInvalid('unexpected \"aud\" claim value', 'aud', 'check_failed')\n  }\n\n  if (typ && normalizeTyp(decoded.header.typ) !== normalizeTyp(typ)) {\n    throw new JWTClaimInvalid('unexpected \"typ\" JWT header value', 'typ', 'check_failed')\n  }\n\n  const tolerance = clockTolerance ? secs(clockTolerance) : 0\n\n  if (!ignoreIat && !('exp' in decoded.payload) && 'iat' in decoded.payload && decoded.payload.iat > unix + tolerance) {\n    throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')\n  }\n\n  if (!ignoreNbf && 'nbf' in decoded.payload && decoded.payload.nbf > unix + tolerance) {\n    throw new JWTClaimInvalid('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed')\n  }\n\n  if (!ignoreExp && 'exp' in decoded.payload && decoded.payload.exp <= unix - tolerance) {\n    throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed')\n  }\n\n  if (maxTokenAge) {\n    const age = unix - decoded.payload.iat\n    const max = secs(maxTokenAge)\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed')\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')\n    }\n  }\n\n  return complete ? decoded : decoded.payload\n}\n","const { getCurves } = require('crypto')\n\nconst curves = new Set()\n\nif (getCurves().includes('prime256v1')) {\n  curves.add('P-256')\n}\n\nif (getCurves().includes('secp256k1')) {\n  curves.add('secp256k1')\n}\n\nif (getCurves().includes('secp384r1')) {\n  curves.add('P-384')\n}\n\nif (getCurves().includes('secp521r1')) {\n  curves.add('P-521')\n}\n\nmodule.exports = curves\n","module.exports = new Map()\n","const EC_CURVES = require('./ec_curves')\nconst IVLENGTHS = require('./iv_lengths')\nconst JWA = require('./jwa')\nconst JWK = require('./jwk')\nconst KEYLENGTHS = require('./key_lengths')\nconst OKP_CURVES = require('./okp_curves')\nconst ECDH_DERIVE_LENGTHS = require('./ecdh_derive_lengths')\n\nmodule.exports = {\n  EC_CURVES,\n  ECDH_DERIVE_LENGTHS,\n  IVLENGTHS,\n  JWA,\n  JWK,\n  KEYLENGTHS,\n  OKP_CURVES\n}\n","module.exports = new Map([\n  ['A128CBC-HS256', 128],\n  ['A128GCM', 96],\n  ['A128GCMKW', 96],\n  ['A192CBC-HS384', 128],\n  ['A192GCM', 96],\n  ['A192GCMKW', 96],\n  ['A256CBC-HS512', 128],\n  ['A256GCM', 96],\n  ['A256GCMKW', 96]\n])\n","module.exports = {\n  sign: new Map(),\n  verify: new Map(),\n  keyManagementEncrypt: new Map(),\n  keyManagementDecrypt: new Map(),\n  encrypt: new Map(),\n  decrypt: new Map()\n}\n","module.exports = {\n  oct: {\n    decrypt: {},\n    deriveKey: {},\n    encrypt: {},\n    sign: {},\n    unwrapKey: {},\n    verify: {},\n    wrapKey: {}\n  },\n  EC: {\n    decrypt: {},\n    deriveKey: {},\n    encrypt: {},\n    sign: {},\n    unwrapKey: {},\n    verify: {},\n    wrapKey: {}\n  },\n  RSA: {\n    decrypt: {},\n    deriveKey: {},\n    encrypt: {},\n    sign: {},\n    unwrapKey: {},\n    verify: {},\n    wrapKey: {}\n  },\n  OKP: {\n    decrypt: {},\n    deriveKey: {},\n    encrypt: {},\n    sign: {},\n    unwrapKey: {},\n    verify: {},\n    wrapKey: {}\n  }\n}\n","module.exports = new Map([\n  ['A128CBC-HS256', 256],\n  ['A128GCM', 128],\n  ['A192CBC-HS384', 384],\n  ['A192GCM', 192],\n  ['A256CBC-HS512', 512],\n  ['A256GCM', 256]\n])\n","const curves = new Set(['Ed25519'])\n\nif (!('electron' in process.versions)) {\n  curves.add('Ed448')\n  curves.add('X25519')\n  curves.add('X448')\n}\n\nmodule.exports = curves\n","const logger = require('debug')('jwks');\nconst { retrieveSigningKeys } = require('./utils') ;\nconst { request, cacheSigningKey, rateLimitSigningKey, getKeysInterceptor, callbackSupport } = require('./wrappers');\nconst JwksError = require('./errors/JwksError');\nconst SigningKeyNotFoundError = require('./errors/SigningKeyNotFoundError');\n\nclass JwksClient {\n  constructor(options) {\n    this.options = {\n      rateLimit: false,\n      cache: true,\n      timeout: 30000,\n      ...options\n    };\n\n    // Initialize wrappers.\n    if (this.options.getKeysInterceptor) {\n      this.getSigningKey = getKeysInterceptor(this, options);\n    }\n\n    if (this.options.rateLimit) {\n      this.getSigningKey = rateLimitSigningKey(this, options);\n    }\n    if (this.options.cache) {\n      this.getSigningKey = cacheSigningKey(this, options);\n    }\n\n    this.getSigningKey = callbackSupport(this, options);\n  }\n\n  async getKeys() {\n    logger(`Fetching keys from '${this.options.jwksUri}'`);\n\n    try {\n      const res = await request({\n        uri: this.options.jwksUri,\n        headers: this.options.requestHeaders,\n        agent: this.options.requestAgent,\n        timeout: this.options.timeout,\n        fetcher: this.options.fetcher\n      });\n\n      logger('Keys:', res.keys);\n      return res.keys;\n    } catch (err) {\n      const { errorMsg } = err;\n      logger('Failure:', errorMsg || err);\n      throw (errorMsg ? new JwksError(errorMsg) : err);\n    }\n  }\n\n  async getSigningKeys() {\n    const keys = await this.getKeys();\n\n    if (!keys || !keys.length) {\n      throw new JwksError('The JWKS endpoint did not contain any keys');\n    }\n\n    const signingKeys = retrieveSigningKeys(keys);\n\n    if (!signingKeys.length) {\n      throw new JwksError('The JWKS endpoint did not contain any signing keys');\n    }\n\n    logger('Signing Keys:', signingKeys);\n    return signingKeys;\n  }\n\n  async getSigningKey (kid) {\n    logger(`Fetching signing key for '${kid}'`);\n    const keys = await this.getSigningKeys();\n\n    const kidDefined = kid !== undefined && kid !== null;\n    if (!kidDefined && keys.length > 1) {\n      logger('No KID specified and JWKS endpoint returned more than 1 key');\n      throw new SigningKeyNotFoundError('No KID specified and JWKS endpoint returned more than 1 key');\n    }\n\n    const key = keys.find(k => !kidDefined || k.kid === kid);\n    if (key) {\n      return key;\n    } else {\n      logger(`Unable to find a signing key that matches '${kid}'`);\n      throw new SigningKeyNotFoundError(`Unable to find a signing key that matches '${kid}'`);\n    }\n  }\n}\n\nmodule.exports = {\n  JwksClient\n};\n","function ArgumentError(message) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'ArgumentError';\n  this.message = message;\n}\n\nArgumentError.prototype = Object.create(Error.prototype);\nArgumentError.prototype.constructor = ArgumentError;\nmodule.exports = ArgumentError;\n","function JwksError(message) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'JwksError';\n  this.message = message;\n}\n\nJwksError.prototype = Object.create(Error.prototype);\nJwksError.prototype.constructor = JwksError;\nmodule.exports = JwksError;\n","function JwksRateLimitError(message) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'JwksRateLimitError';\n  this.message = message;\n}\n\nJwksRateLimitError.prototype = Object.create(Error.prototype);\nJwksRateLimitError.prototype.constructor = JwksRateLimitError;\nmodule.exports = JwksRateLimitError;\n","function SigningKeyNotFoundError(message) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = 'SigningKeyNotFoundError';\n  this.message = message;\n}\n\nSigningKeyNotFoundError.prototype = Object.create(Error.prototype);\nSigningKeyNotFoundError.prototype.constructor = SigningKeyNotFoundError;\nmodule.exports = SigningKeyNotFoundError;\n","module.exports = {\n  ArgumentError: require('./ArgumentError'),\n  JwksError: require('./JwksError'),\n  JwksRateLimitError: require('./JwksRateLimitError'),\n  SigningKeyNotFoundError: require('./SigningKeyNotFoundError')\n};\n","const { JwksClient } = require('./JwksClient');\nconst errors = require('./errors');\nconst { hapiJwt2Key, hapiJwt2KeyAsync } = require('./integrations/hapi');\nconst { expressJwtSecret } = require('./integrations/express');\nconst { koaJwtSecret } = require('./integrations/koa');\nconst { passportJwtSecret } = require('./integrations/passport');\n\nmodule.exports = (options) => {\n  return new JwksClient(options);\n};\nmodule.exports.JwksClient = JwksClient;\n\nmodule.exports.ArgumentError = errors.ArgumentError;\nmodule.exports.JwksError = errors.JwksError;\nmodule.exports.JwksRateLimitError = errors.JwksRateLimitError;\nmodule.exports.SigningKeyNotFoundError = errors.SigningKeyNotFoundError;\n\nmodule.exports.expressJwtSecret = expressJwtSecret;\nmodule.exports.hapiJwt2Key = hapiJwt2Key;\nmodule.exports.hapiJwt2KeyAsync = hapiJwt2KeyAsync;\nmodule.exports.koaJwtSecret = koaJwtSecret;\nmodule.exports.passportJwtSecret = passportJwtSecret;\n","const allowedSignatureAlg = [\n  'RS256',\n  'RS384',\n  'RS512',\n  'PS256',\n  'PS384',\n  'PS512',\n  'ES256',\n  'ES256K',\n  'ES384',\n  'ES512',\n  'EdDSA'\n];\n\nmodule.exports = allowedSignatureAlg;\n","const { ArgumentError } = require('../errors');\nconst { JwksClient } = require('../JwksClient');\nconst supportedAlg = require('./config');\n\nconst handleSigningKeyError = (err, cb) => {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(null);\n  }\n\n  // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n  if (err) {\n    return cb(err);\n  }\n};\n\nmodule.exports.expressJwtSecret = function (options) {\n  if (options === null || options === undefined) {\n    throw new ArgumentError('An options object must be provided when initializing expressJwtSecret');\n  }\n\n  const client = new JwksClient(options);\n  const onError = options.handleSigningKeyError || handleSigningKeyError;\n\n  const expressJwt7Provider = async (req, token) => {\n    if (!token) { return; }\n    const header = token.header;\n    if (!header || !supportedAlg.includes(header.alg)) {\n      return;\n    }\n    try {\n      const key = await client.getSigningKey(header.kid);\n      return key.publicKey || key.rsaPublicKey;\n    } catch (err) {\n      return new Promise((resolve, reject) => {\n        onError(err, (newError) => {\n          if (!newError) { return resolve(); }\n          reject(newError);\n        });\n      });\n    }\n  };\n\n  return function secretProvider(req, header, payload, cb) {\n    //This function has 4 parameters to make it work with express-jwt@6\n    //but it also supports express-jwt@7 which only has 2.\n    if (arguments.length === 4) {\n      expressJwt7Provider(req, { header })\n        .then(key => {\n          setImmediate(cb, null, key);\n        }).catch(err => {\n          setImmediate(cb, err);\n        });\n\n      return;\n    }\n\n    return expressJwt7Provider(req, arguments[1]);\n  };\n};\n","const { ArgumentError } = require('../errors');\nconst { JwksClient } = require('../JwksClient');\nconst supportedAlg = require('./config');\n\nconst handleSigningKeyError = (err, cb) => {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(err, null, null);\n  }\n\n  // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n  if (err) {\n    return cb(err, null, null);\n  }\n};\n\n/**\n * Call hapiJwt2Key as a Promise\n * @param {object} options \n * @returns {Promise}\n */\nmodule.exports.hapiJwt2KeyAsync = (options) => {\n  const secretProvider = module.exports.hapiJwt2Key(options);\n  return function(decoded) {\n    return new Promise((resolve, reject) => {\n      const cb = (err, key) => {\n        (!key || err) ? reject(err) : resolve({ key });\n      };\n      secretProvider(decoded, cb);\n    });\n  };\n}; \n\nmodule.exports.hapiJwt2Key = function (options) {\n  if (options === null || options === undefined) {\n    throw new ArgumentError('An options object must be provided when initializing hapiJwt2Key');\n  }\n\n  const client = new JwksClient(options);\n  const onError = options.handleSigningKeyError || handleSigningKeyError;\n\n  return function secretProvider(decoded, cb) {\n    // We cannot find a signing certificate if there is no header (no kid).\n    if (!decoded || !decoded.header) {\n      return cb(new Error('Cannot find a signing certificate if there is no header'), null, null);\n    }\n\n    if (!supportedAlg.includes(decoded.header.alg)) {\n      return cb(new Error('Unsupported algorithm ' + decoded.header.alg + ' supplied.'), null, null);\n    }\n\n    client.getSigningKey(decoded.header.kid)\n      .then(key => {\n        return cb(null, key.publicKey || key.rsaPublicKey, key);\n      }).catch(err => {\n        return onError(err, (newError) => cb(newError, null, null));\n      });\n  };\n};\n","const { ArgumentError } = require('../errors');\nconst { JwksClient } = require('../JwksClient');\nconst supportedAlg = require('./config');\n\nmodule.exports.koaJwtSecret = function (options = {}) {\n  if (!options.jwksUri) {\n    throw new ArgumentError('No JWKS provided. Please provide a jwksUri');\n  }\n\n  const client = new JwksClient(options);\n\n  return function secretProvider({ alg, kid } = {}) {\n    return new Promise((resolve, reject) => {\n      if (!supportedAlg.includes(alg)) {\n        return reject(new Error('Missing / invalid token algorithm'));\n      }\n\n      client.getSigningKey(kid)\n        .then(key => {\n          resolve(key.publicKey || key.rsaPublicKey);\n        }).catch(err => {\n          if (options.handleSigningKeyError) {\n            return options.handleSigningKeyError(err).then(reject);\n          }\n\n          return reject(err);\n        });\n    });\n  };\n};\n","const JWT = require('jose').JWT;\nconst { ArgumentError } = require('../errors');\nconst { JwksClient } = require('../JwksClient');\nconst supportedAlg = require('./config');\n\nconst handleSigningKeyError = (err, cb) => {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(null);\n  }\n\n  // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n  if (err) {\n    return cb(err);\n  }\n};\n\nmodule.exports.passportJwtSecret = function (options) {\n  if (options === null || options === undefined) {\n    throw new ArgumentError('An options object must be provided when initializing passportJwtSecret');\n  }\n\n  if (!options.jwksUri) {\n    throw new ArgumentError('No JWKS provided. Please provide a jwksUri');\n  }\n\n  const client = new JwksClient(options);\n  const onError = options.handleSigningKeyError || handleSigningKeyError;\n\n  return function secretProvider(req, rawJwtToken, cb) {\n    let decoded;\n    try {\n      decoded = JWT.decode(rawJwtToken, { complete: true });\n    } catch (err) {\n      decoded = null;\n    }\n\n    if (!decoded || !supportedAlg.includes(decoded.header.alg)) {\n      return cb(null, null);\n    }\n\n    client.getSigningKey(decoded.header.kid)\n      .then(key => {\n        cb(null, key.publicKey || key.rsaPublicKey);\n      }).catch(err => {\n        onError(err, (newError) => cb(newError, null));\n      });\n  };\n};\n","const jose = require('jose');\n\nfunction retrieveSigningKeys(keys) {\n  const keystore = jose.JWKS.asKeyStore({ keys }, { ignoreErrors: true });\n\n  return keystore.all({ use: 'sig' }).map((key) => {\n    return {\n      kid: key.kid,\n      alg: key.alg,\n      get publicKey() { return key.toPEM(false); },\n      get rsaPublicKey() { return key.toPEM(false); },\n      getPublicKey() { return key.toPEM(false); }\n    };\n  });\n}\n\nmodule.exports = {\n  retrieveSigningKeys\n};\n","const logger = require('debug')('jwks');\nconst memoizer = require('lru-memoizer');\nconst { promisify, callbackify } = require('util');\n\nfunction cacheWrapper(client, { cacheMaxEntries = 5, cacheMaxAge = 600000 }) {\n  logger(`Configured caching of signing keys. Max: ${cacheMaxEntries} / Age: ${cacheMaxAge}`);\n  return promisify(memoizer({\n    hash: (kid) => kid,\n    load: callbackify(client.getSigningKey.bind(client)),\n    maxAge: cacheMaxAge,\n    max: cacheMaxEntries\n  }));\n}\n\nmodule.exports.default = cacheWrapper;\n","const { callbackify } = require('util');\n\nconst callbackSupport = (client) => {\n  const getSigningKey = client.getSigningKey.bind(client);\n\n  return (kid, cb) => {\n    if (cb) {\n      const callbackFunc = callbackify(getSigningKey);\n      return callbackFunc(kid, cb);\n    }\n\n    return getSigningKey(kid);\n  };\n};\n\nmodule.exports.default = callbackSupport;\n","module.exports = {\n  request: require('./request').default,\n  cacheSigningKey: require('./cache').default,\n  rateLimitSigningKey: require('./rateLimit').default,\n  getKeysInterceptor: require('./interceptor').default,\n  callbackSupport: require('./callbackSupport').default\n};\n","const retrieveSigningKeys = require('../utils').retrieveSigningKeys;\n\n/**\n * Uses getKeysInterceptor to allow users to retrieve keys from a file,\n * external cache, or provided object before falling back to the jwksUri endpoint\n */\nfunction getKeysInterceptor(client, { getKeysInterceptor }) {\n  const getSigningKey = client.getSigningKey.bind(client);\n\n  return async (kid) => {\n    const keys = await getKeysInterceptor();\n\n    let signingKeys;\n    if (keys && keys.length) {\n      signingKeys = retrieveSigningKeys(keys);\n    }\n\n    if (signingKeys && signingKeys.length) {\n      const key = signingKeys.find(k => !kid || k.kid === kid);\n\n      if (key) {\n        return key;\n      }\n    }\n\n    return getSigningKey(kid);\n  };\n}\n\nmodule.exports.default = getKeysInterceptor;\n","const logger = require('debug')('jwks');\nconst { RateLimiter } = require('limiter');\n\nconst JwksRateLimitError = require('../errors/JwksRateLimitError');\n\nfunction rateLimitWrapper(client, { jwksRequestsPerMinute = 10 }) {\n  const getSigningKey = client.getSigningKey.bind(client);\n\n  const limiter = new RateLimiter(jwksRequestsPerMinute, 'minute', true);\n  logger(`Configured rate limiting to JWKS endpoint at ${jwksRequestsPerMinute}/minute`);\n\n  return async (kid) => await new Promise((resolve, reject) => {\n    limiter.removeTokens(1, async (err, remaining) => {\n      if (err) {\n        reject(err);\n      }\n\n      logger('Requests to the JWKS endpoint available for the next minute:', remaining);\n      if (remaining < 0) {\n        logger('Too many requests to the JWKS endpoint');\n        reject(new JwksRateLimitError('Too many requests to the JWKS endpoint'));\n      } else {\n        try {\n          const key = await getSigningKey(kid);\n          resolve(key);\n        } catch (error) {\n          reject(error);\n        }\n      }\n    });\n  });\n}\n\nmodule.exports.default = rateLimitWrapper;\n","const http = require('http');\nconst https = require('https');\nconst urlUtil = require('url');\n\nmodule.exports.default =  (options) => {\n  if (options.fetcher) {\n    return options.fetcher(options.uri);\n  }\n\n  return new Promise((resolve, reject) => {\n    const {\n      hostname,\n      path,\n      port,\n      protocol\n    } = urlUtil.parse(options.uri);\n\n    const requestOptions = {\n      hostname,\n      path,\n      port,\n      method: 'GET',\n      ...(options.headers && { headers: { ...options.headers } }),\n      ...(options.timeout && { timeout: options.timeout }),\n      ...(options.agent && { agent: options.agent })\n    };\n\n    const httpRequestLib = protocol === 'https:' ? https : http;\n    const httpRequest = httpRequestLib.request(requestOptions, (res) => {\n      let rawData = '';\n      res.setEncoding('utf8');\n      res.on('data', (chunk) => { rawData += chunk; });\n      res.on('end', () => {\n        if (res.statusCode < 200 || res.statusCode >= 300) {\n          const errorMsg = res.body && (res.body.message || res.body) || res.statusMessage || `Http Error ${res.statusCode}`;\n          reject({ errorMsg });\n        } else {\n          try {\n            resolve(rawData && JSON.parse(rawData));\n          } catch (error) {\n            reject(error);\n          }\n        }\n      });\n    });\n\n    httpRequest\n      .on('timeout', () => httpRequest.destroy())\n      .on('error', (e) => reject(e))\n      .end();\n  });\n};\n","\r\nexports.RateLimiter = require('./lib/rateLimiter');\r\nexports.TokenBucket = require('./lib/tokenBucket');\r\n","var getMilliseconds = function() {\r\n  if (typeof process !== 'undefined' && process.hrtime) {\r\n    var hrtime = process.hrtime();\r\n    var seconds = hrtime[0];\r\n    var nanoseconds = hrtime[1];\r\n\r\n    return seconds * 1e3 +  Math.floor(nanoseconds / 1e6);\r\n  }\r\n\r\n  return new Date().getTime();\r\n}\r\n\r\nmodule.exports = getMilliseconds;\r\n","var TokenBucket = require('./tokenBucket');\r\nvar getMilliseconds = require('./clock');\r\n\r\n/**\r\n * A generic rate limiter. Underneath the hood, this uses a token bucket plus\r\n * an additional check to limit how many tokens we can remove each interval.\r\n * @author John Hurliman <jhurliman@jhurliman.org>\r\n *\r\n * @param {Number} tokensPerInterval Maximum number of tokens that can be\r\n *  removed at any given moment and over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {Boolean} fireImmediately Optional. Whether or not the callback\r\n *  will fire immediately when rate limiting is in effect (default is false).\r\n */\r\nvar RateLimiter = function(tokensPerInterval, interval, fireImmediately) {\r\n  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval,\r\n    interval, null);\r\n\r\n  // Fill the token bucket to start\r\n  this.tokenBucket.content = tokensPerInterval;\r\n\r\n  this.curIntervalStart = getMilliseconds();\r\n  this.tokensThisInterval = 0;\r\n  this.fireImmediately = fireImmediately;\r\n};\r\n\r\nRateLimiter.prototype = {\r\n  tokenBucket: null,\r\n  curIntervalStart: 0,\r\n  tokensThisInterval: 0,\r\n  fireImmediately: false,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * rate limiter contains enough tokens and we haven't spent too many tokens\r\n   * in this interval already, this will happen immediately. Otherwise, the\r\n   * removal and callback will happen when enough tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    // Make sure the request isn't for more than we can handle\r\n    if (count > this.tokenBucket.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count +\r\n        ' exceeds maximum tokens per interval ' + this.tokenBucket.bucketSize,\r\n        null));\r\n      return false;\r\n    }\r\n\r\n    var self = this;\r\n    var now = getMilliseconds();\r\n\r\n    // Advance the current interval and reset the current interval token count\r\n    // if needed\r\n    if (now < this.curIntervalStart\r\n      || now - this.curIntervalStart >= this.tokenBucket.interval) {\r\n      this.curIntervalStart = now;\r\n      this.tokensThisInterval = 0;\r\n    }\r\n\r\n    // If we don't have enough tokens left in this interval, wait until the\r\n    // next interval\r\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {\r\n      if (this.fireImmediately) {\r\n        process.nextTick(callback.bind(null, null, -1));\r\n      } else {\r\n        var waitInterval = Math.ceil(\r\n          this.curIntervalStart + this.tokenBucket.interval - now);\r\n\r\n        setTimeout(function() {\r\n          self.tokenBucket.removeTokens(count, afterTokensRemoved);\r\n        }, waitInterval);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // Remove the requested number of tokens from the token bucket\r\n    return this.tokenBucket.removeTokens(count, afterTokensRemoved);\r\n\r\n    function afterTokensRemoved(err, tokensRemaining) {\r\n      if (err) return callback(err, null);\r\n\r\n      self.tokensThisInterval += count;\r\n      callback(null, tokensRemaining);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens and we\r\n   * haven't spent too many tokens in this interval already, this will return\r\n   * true. Otherwise, false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Make sure the request isn't for more than we can handle\r\n    if (count > this.tokenBucket.bucketSize)\r\n      return false;\r\n\r\n    var now = getMilliseconds();\r\n\r\n    // Advance the current interval and reset the current interval token count\r\n    // if needed\r\n    if (now < this.curIntervalStart\r\n      || now - this.curIntervalStart >= this.tokenBucket.interval) {\r\n      this.curIntervalStart = now;\r\n      this.tokensThisInterval = 0;\r\n    }\r\n\r\n    // If we don't have enough tokens left in this interval, return false\r\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)\r\n      return false;\r\n\r\n    // Try to remove the requested number of tokens from the token bucket\r\n    var removed = this.tokenBucket.tryRemoveTokens(count);\r\n    if (removed) {\r\n      this.tokensThisInterval += count;\r\n    }\r\n    return removed;\r\n  },\r\n\r\n  /**\r\n   * Returns the number of tokens remaining in the TokenBucket.\r\n   * @returns {Number} The number of tokens remaining.\r\n   */\r\n  getTokensRemaining: function () {\r\n    this.tokenBucket.drip();\r\n    return this.tokenBucket.content;\r\n  }\r\n};\r\n\r\nmodule.exports = RateLimiter;\r\n","\r\n/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\r\nvar TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {\r\n  this.bucketSize = bucketSize;\r\n  this.tokensPerInterval = tokensPerInterval;\r\n\r\n  if (typeof interval === 'string') {\r\n    switch (interval) {\r\n      case 'sec': case 'second':\r\n        this.interval = 1000; break;\r\n      case 'min': case 'minute':\r\n        this.interval = 1000 * 60; break;\r\n      case 'hr': case 'hour':\r\n        this.interval = 1000 * 60 * 60; break;\r\n      case 'day':\r\n        this.interval = 1000 * 60 * 60 * 24; break;\r\n      default:\r\n        throw new Error('Invaid interval ' + interval);\r\n    }\r\n  } else {\r\n    this.interval = interval;\r\n  }\r\n\r\n  this.parentBucket = parentBucket;\r\n  this.content = 0;\r\n  this.lastDrip = +new Date();\r\n};\r\n\r\nTokenBucket.prototype = {\r\n  bucketSize: 1,\r\n  tokensPerInterval: 1,\r\n  interval: 1000,\r\n  parentBucket: null,\r\n  content: 0,\r\n  lastDrip: 0,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    var self = this;\r\n\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize) {\r\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\r\n      return true;\r\n    }\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +\r\n        this.bucketSize, null));\r\n      return false;\r\n    }\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, come back later\r\n    if (count > this.content)\r\n      return comeBackLater();\r\n\r\n    if (this.parentBucket) {\r\n      // Remove the requested from the parent bucket first\r\n      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {\r\n        if (err) return callback(err, null);\r\n\r\n        // Check that we still have enough tokens in this bucket\r\n        if (count > self.content)\r\n          return comeBackLater();\r\n\r\n        // Tokens were removed from the parent bucket, now remove them from\r\n        // this bucket and fire the callback. Note that we look at the current\r\n        // bucket and parent bucket's remaining tokens and return the smaller\r\n        // of the two values\r\n        self.content -= count;\r\n        callback(null, Math.min(remainingTokens, self.content));\r\n      });\r\n    } else {\r\n      // Remove the requested tokens from this bucket and fire the callback\r\n      this.content -= count;\r\n      process.nextTick(callback.bind(null, null, this.content));\r\n      return true;\r\n    }\r\n\r\n    function comeBackLater() {\r\n      // How long do we need to wait to make up the difference in tokens?\r\n      var waitInterval = Math.ceil(\r\n        (count - self.content) * (self.interval / self.tokensPerInterval));\r\n      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize)\r\n      return true;\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize)\r\n      return false;\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, return false\r\n    if (count > this.content)\r\n      return false;\r\n\r\n    // Try to remove the requested tokens from the parent bucket\r\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))\r\n      return false;\r\n\r\n    // Remove the requested tokens from this bucket and return\r\n    this.content -= count;\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\r\n  drip: function() {\r\n    if (!this.tokensPerInterval) {\r\n      this.content = this.bucketSize;\r\n      return;\r\n    }\r\n\r\n    var now = +new Date();\r\n    var deltaMS = Math.max(now - this.lastDrip, 0);\r\n    this.lastDrip = now;\r\n\r\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\r\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\r\n  }\r\n};\r\n\r\nmodule.exports = TokenBucket;\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asyncMemoizer = void 0;\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\nvar events_1 = require(\"events\");\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nvar freeze_1 = require(\"./freeze\");\nvar sync_1 = require(\"./sync\");\nfunction asyncMemoizer(options) {\n    var cache = new lru_cache_1.default(options);\n    var load = options.load;\n    var hash = options.hash;\n    var bypass = options.bypass;\n    var itemMaxAge = options.itemMaxAge;\n    var freeze = options.freeze;\n    var clone = options.clone;\n    var queueMaxAge = options.queueMaxAge || 1000;\n    var loading = new Map();\n    var emitter = new events_1.EventEmitter();\n    var memoizerMethods = Object.assign({\n        del: del,\n        reset: function () { return cache.reset(); },\n        keys: cache.keys.bind(cache),\n        on: emitter.on.bind(emitter),\n        once: emitter.once.bind(emitter)\n    }, options);\n    if (options.disable) {\n        return Object.assign(load, memoizerMethods);\n    }\n    function del() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var key = hash.apply(void 0, __spread(args));\n        cache.del(key);\n    }\n    function add(key, parameters, result) {\n        if (freeze) {\n            result.forEach(freeze_1.deepFreeze);\n        }\n        if (itemMaxAge) {\n            cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));\n        }\n        else {\n            cache.set(key, result);\n        }\n    }\n    function runCallbacks(callbacks, args) {\n        var e_1, _a;\n        try {\n            for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n                var callback = callbacks_1_1.value;\n                // Simulate async call when returning from cache\n                // and yield between callback resolution\n                if (clone) {\n                    setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));\n                }\n                else {\n                    setImmediate.apply(void 0, __spread([callback], args));\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    function emit(event) {\n        var parameters = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            parameters[_i - 1] = arguments[_i];\n        }\n        emitter.emit.apply(emitter, __spread([event], parameters));\n    }\n    function memoizedFunction() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var parameters = args.slice(0, -1);\n        var callback = args.slice(-1).pop();\n        var key;\n        if (bypass && bypass.apply(void 0, __spread(parameters))) {\n            emit.apply(void 0, __spread(['miss'], parameters));\n            return load.apply(void 0, __spread(args));\n        }\n        if (parameters.length === 0 && !hash) {\n            //the load function only receives callback.\n            key = '_';\n        }\n        else {\n            key = hash.apply(void 0, __spread(parameters));\n        }\n        var fromCache = cache.get(key);\n        if (fromCache) {\n            emit.apply(void 0, __spread(['hit'], parameters));\n            // found, invoke callback\n            return runCallbacks([callback], [null].concat(fromCache));\n        }\n        var pendingLoad = loading.get(key);\n        if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n            // request already in progress, queue and return\n            pendingLoad.queue.push(callback);\n            emit.apply(void 0, __spread(['queue'], parameters));\n            return;\n        }\n        emit.apply(void 0, __spread(['miss'], parameters));\n        var started = Date.now();\n        // no pending request or not resolved before expiration\n        // create a new queue and invoke load\n        var queue = [callback];\n        loading.set(key, {\n            queue: queue,\n            expiresAt: started + queueMaxAge\n        });\n        var loadHandler = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var err = args[0];\n            if (!err) {\n                add(key, parameters, args.slice(1));\n            }\n            // this can potentially delete a different queue than `queue` if\n            // this callback was called after expiration.\n            // that will only cause a new call to be performed and a new queue to be\n            // created\n            loading.delete(key);\n            emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));\n            runCallbacks(queue, args);\n        };\n        load.apply(void 0, __spread(parameters, [loadHandler]));\n    }\n    ;\n    return Object.assign(memoizedFunction, memoizerMethods);\n}\nexports.asyncMemoizer = asyncMemoizer;\nasyncMemoizer.sync = sync_1.syncMemoizer;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvYXN5bmMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdEQUE0QjtBQUM1QixpQ0FBc0M7QUFDdEMsc0VBQXlDO0FBQ3pDLG1DQUFzQztBQUN0QywrQkFBc0M7QUE2R3RDLFNBQVMsYUFBYSxDQUNwQixPQUF3QjtJQUV4QixJQUFNLEtBQUssR0FBUSxJQUFJLG1CQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEMsSUFBTSxJQUFJLEdBQVMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNoQyxJQUFNLElBQUksR0FBUyxPQUFPLENBQUMsSUFBSSxDQUFDO0lBQ2hDLElBQU0sTUFBTSxHQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUM7SUFDbEMsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztJQUN0QyxJQUFNLE1BQU0sR0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO0lBQ2xDLElBQU0sS0FBSyxHQUFRLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDakMsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUM7SUFDaEQsSUFBTSxPQUFPLEdBQU0sSUFBSSxHQUFHLEVBQXVCLENBQUM7SUFDbEQsSUFBTSxPQUFPLEdBQU0sSUFBSSxxQkFBWSxFQUFFLENBQUM7SUFFdEMsSUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNwQyxHQUFHLEtBQUE7UUFDSCxLQUFLLEVBQUUsY0FBTSxPQUFBLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBYixDQUFhO1FBQzFCLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDNUIsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUM1QixJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0tBQ2pDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFWixJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUU7UUFDbkIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztLQUM3QztJQUVELFNBQVMsR0FBRztRQUFDLGNBQWM7YUFBZCxVQUFjLEVBQWQscUJBQWMsRUFBZCxJQUFjO1lBQWQseUJBQWM7O1FBQ3pCLElBQU0sR0FBRyxHQUFHLElBQUksd0JBQUksSUFBSSxFQUFDLENBQUM7UUFDMUIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixDQUFDO0lBRUQsU0FBUyxHQUFHLENBQUMsR0FBVyxFQUFFLFVBQWlCLEVBQUUsTUFBYTtRQUN4RCxJQUFJLE1BQU0sRUFBRTtZQUNWLE1BQU0sQ0FBQyxPQUFPLENBQUMsbUJBQVUsQ0FBQyxDQUFDO1NBQzVCO1FBRUQsSUFBSSxVQUFVLEVBQUU7WUFDZCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsVUFBVSx3QkFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFFLENBQUM7U0FDbEU7YUFBTTtZQUNMLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQztJQUVELFNBQVMsWUFBWSxDQUFDLFNBQXFCLEVBQUUsSUFBVzs7O1lBQ3RELEtBQXVCLElBQUEsY0FBQSxTQUFBLFNBQVMsQ0FBQSxvQ0FBQSwyREFBRTtnQkFBN0IsSUFBTSxRQUFRLHNCQUFBO2dCQUNqQixnREFBZ0Q7Z0JBQ2hELHdDQUF3QztnQkFDeEMsSUFBSSxLQUFLLEVBQUU7b0JBQ1QsWUFBWSx5QkFBQyxRQUFRLEdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQywwQkFBUyxDQUFDLEdBQUU7aUJBQ2hEO3FCQUFNO29CQUNMLFlBQVkseUJBQUMsUUFBUSxHQUFLLElBQUksR0FBRTtpQkFDakM7YUFDRjs7Ozs7Ozs7O0lBQ0gsQ0FBQztJQUVELFNBQVMsSUFBSSxDQUFDLEtBQWE7UUFBRSxvQkFBb0I7YUFBcEIsVUFBb0IsRUFBcEIscUJBQW9CLEVBQXBCLElBQW9CO1lBQXBCLG1DQUFvQjs7UUFDL0MsT0FBTyxDQUFDLElBQUksT0FBWixPQUFPLFlBQU0sS0FBSyxHQUFLLFVBQVUsR0FBRTtJQUNyQyxDQUFDO0lBRUQsU0FBUyxnQkFBZ0I7UUFBQyxjQUFjO2FBQWQsVUFBYyxFQUFkLHFCQUFjLEVBQWQsSUFBYztZQUFkLHlCQUFjOztRQUN0QyxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLElBQU0sUUFBUSxHQUFhLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNoRCxJQUFJLEdBQVcsQ0FBQztRQUVoQixJQUFJLE1BQU0sSUFBSSxNQUFNLHdCQUFJLFVBQVUsRUFBQyxFQUFFO1lBQ25DLElBQUkseUJBQUMsTUFBTSxHQUFLLFVBQVUsR0FBRTtZQUM1QixPQUFPLElBQUksd0JBQUksSUFBSSxHQUFFO1NBQ3RCO1FBRUQsSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNwQywyQ0FBMkM7WUFDM0MsR0FBRyxHQUFHLEdBQUcsQ0FBQztTQUNYO2FBQU07WUFDTCxHQUFHLEdBQUcsSUFBSSx3QkFBSSxVQUFVLEVBQUMsQ0FBQztTQUMzQjtRQUVELElBQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxTQUFTLEVBQUU7WUFDYixJQUFJLHlCQUFDLEtBQUssR0FBSyxVQUFVLEdBQUU7WUFDM0IseUJBQXlCO1lBQ3pCLE9BQU8sWUFBWSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUMzRDtRQUVELElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDckMsSUFBSSxXQUFXLElBQUksV0FBVyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDckQsZ0RBQWdEO1lBQ2hELFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ2pDLElBQUkseUJBQUMsT0FBTyxHQUFLLFVBQVUsR0FBRTtZQUM3QixPQUFPO1NBQ1I7UUFFRCxJQUFJLHlCQUFDLE1BQU0sR0FBSyxVQUFVLEdBQUU7UUFFNUIsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTNCLHVEQUF1RDtRQUN2RCxxQ0FBcUM7UUFDckMsSUFBTSxLQUFLLEdBQUcsQ0FBRSxRQUFRLENBQUUsQ0FBQztRQUMzQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtZQUNmLEtBQUssT0FBQTtZQUNMLFNBQVMsRUFBRSxPQUFPLEdBQUcsV0FBVztTQUNqQyxDQUFDLENBQUM7UUFFSCxJQUFNLFdBQVcsR0FBRztZQUFDLGNBQWM7aUJBQWQsVUFBYyxFQUFkLHFCQUFjLEVBQWQsSUFBYztnQkFBZCx5QkFBYzs7WUFDakMsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BCLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ1IsR0FBRyxDQUFDLEdBQUcsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JDO1lBRUQsZ0VBQWdFO1lBQ2hFLDZDQUE2QztZQUM3Qyx3RUFBd0U7WUFDeEUsVUFBVTtZQUNWLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFcEIsSUFBSSx5QkFBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLE9BQU8sR0FBSyxVQUFVLEdBQUU7WUFDcEQsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUM7UUFFRixJQUFJLHdCQUFJLFVBQVUsR0FBRSxXQUFXLElBQUU7SUFDbkMsQ0FBQztJQUFBLENBQUM7SUFFRixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsZUFBZSxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUlRLHNDQUFhO0FBRnRCLGFBQWEsQ0FBQyxJQUFJLEdBQUcsbUJBQVksQ0FBQyJ9","\"use strict\";\n// From https://raw.githubusercontent.com/nikoskalogridis/deep-freeze/fb921b32064dce1645197be2bf975fe0385450b0/index.js\n// which is sadly, no longer maintained\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deepFreeze = void 0;\nfunction deepFreeze(o) {\n    if (o) {\n        Object.freeze(o);\n        Object.getOwnPropertyNames(o).forEach(function (prop) {\n            if (o.hasOwnProperty(prop)\n                && o[prop] !== null\n                && (typeof o[prop] === 'object' || typeof o[prop] === 'function')\n                && (o[prop].constructor !== Buffer)\n                && !Object.isFrozen(o[prop])) {\n                deepFreeze(o[prop]);\n            }\n        });\n    }\n    return o;\n}\nexports.deepFreeze = deepFreeze;\n;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJlZXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZyZWV6ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsdUhBQXVIO0FBQ3ZILHVDQUF1Qzs7O0FBRXZDLFNBQWdCLFVBQVUsQ0FBRSxDQUFNO0lBQ2hDLElBQUksQ0FBQyxFQUFFO1FBQ0wsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVqQixNQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSTtZQUNsRCxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDO21CQUNyQixDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSTttQkFDaEIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLElBQUksT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxDQUFDO21CQUM5RCxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLEtBQUssTUFBTSxDQUFDO21CQUNoQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7Z0JBQzVCLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUNyQjtRQUNMLENBQUMsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFoQkQsZ0NBZ0JDO0FBQUEsQ0FBQyJ9","\"use strict\";\nvar async_1 = require(\"./async\");\nmodule.exports = async_1.asyncMemoizer;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGlDQUF3QztBQUV4QyxpQkFBUyxxQkFBYSxDQUFDIn0=","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.syncMemoizer = void 0;\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\nvar events_1 = require(\"events\");\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nvar freeze_1 = require(\"./freeze\");\nfunction syncMemoizer(options) {\n    var cache = new lru_cache_1.default(options);\n    var load = options.load;\n    var hash = options.hash;\n    var bypass = options.bypass;\n    var itemMaxAge = options.itemMaxAge;\n    var freeze = options.freeze;\n    var clone = options.clone;\n    var emitter = new events_1.EventEmitter();\n    var defaultResult = Object.assign({\n        del: del,\n        reset: function () { return cache.reset(); },\n        keys: cache.keys.bind(cache),\n        on: emitter.on.bind(emitter),\n        once: emitter.once.bind(emitter),\n    }, options);\n    if (options.disable) {\n        return Object.assign(load, defaultResult);\n    }\n    function del() {\n        var key = hash.apply(void 0, __spread(arguments));\n        cache.del(key);\n    }\n    function emit(event) {\n        var parameters = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            parameters[_i - 1] = arguments[_i];\n        }\n        emitter.emit.apply(emitter, __spread([event], parameters));\n    }\n    function isPromise(result) {\n        // detect native, bluebird, A+ promises\n        return result && result.then && typeof result.then === 'function';\n    }\n    function processResult(result) {\n        var res = result;\n        if (clone) {\n            if (isPromise(res)) {\n                res = res.then(lodash_clonedeep_1.default);\n            }\n            else {\n                res = lodash_clonedeep_1.default(res);\n            }\n        }\n        if (freeze) {\n            if (isPromise(res)) {\n                res = res.then(freeze_1.deepFreeze);\n            }\n            else {\n                freeze_1.deepFreeze(res);\n            }\n        }\n        return res;\n    }\n    var result = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (bypass && bypass.apply(void 0, __spread(args))) {\n            emit.apply(void 0, __spread(['miss'], args));\n            return load.apply(void 0, __spread(args));\n        }\n        var key = hash.apply(void 0, __spread(args));\n        var fromCache = cache.get(key);\n        if (fromCache) {\n            emit.apply(void 0, __spread(['hit'], args));\n            return processResult(fromCache);\n        }\n        emit.apply(void 0, __spread(['miss'], args));\n        var result = load.apply(void 0, __spread(args));\n        if (itemMaxAge) {\n            // @ts-ignore\n            cache.set(key, result, itemMaxAge.apply(void 0, __spread(args.concat([result]))));\n        }\n        else {\n            cache.set(key, result);\n        }\n        return processResult(result);\n    };\n    return Object.assign(result, defaultResult);\n}\nexports.syncMemoizer = syncMemoizer;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3luYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zeW5jLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsd0RBQTRCO0FBQzVCLGlDQUFzQztBQUN0QyxzRUFBeUM7QUFDekMsbUNBQXNDO0FBaUd0QyxTQUFnQixZQUFZLENBQzFCLE9BQWdDO0lBRWhDLElBQU0sS0FBSyxHQUFRLElBQUksbUJBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxJQUFNLElBQUksR0FBUyxPQUFPLENBQUMsSUFBSSxDQUFDO0lBQ2hDLElBQU0sSUFBSSxHQUFTLE9BQU8sQ0FBQyxJQUFJLENBQUM7SUFDaEMsSUFBTSxNQUFNLEdBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUNsQyxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0lBQ3RDLElBQU0sTUFBTSxHQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUM7SUFDbEMsSUFBTSxLQUFLLEdBQVEsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUNqQyxJQUFNLE9BQU8sR0FBTSxJQUFJLHFCQUFZLEVBQUUsQ0FBQztJQUV0QyxJQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ2xDLEdBQUcsS0FBQTtRQUNILEtBQUssRUFBRSxjQUFNLE9BQUEsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFiLENBQWE7UUFDMUIsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUM1QixFQUFFLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzVCLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7S0FDakMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUVaLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtRQUNuQixPQUFPLE1BQU0sQ0FB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","module.exports = LRUCache\n\n// This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\nvar Map = require('pseudomap')\nvar util = require('util')\n\n// A linked list to keep track of recently-used-ness\nvar Yallist = require('yallist')\n\n// use symbols if possible, otherwise just _props\nvar symbols = {}\nvar hasSymbol = typeof Symbol === 'function'\nvar makeSymbol\n/* istanbul ignore if */\nif (hasSymbol) {\n  makeSymbol = function (key) {\n    return Symbol.for(key)\n  }\n} else {\n  makeSymbol = function (key) {\n    return '_' + key\n  }\n}\n\nfunction priv (obj, key, val) {\n  var sym\n  if (symbols[key]) {\n    sym = symbols[key]\n  } else {\n    sym = makeSymbol(key)\n    symbols[key] = sym\n  }\n  if (arguments.length === 2) {\n    return obj[sym]\n  } else {\n    obj[sym] = val\n    return val\n  }\n}\n\nfunction naiveLength () { return 1 }\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options)\n  }\n\n  if (typeof options === 'number') {\n    options = { max: options }\n  }\n\n  if (!options) {\n    options = {}\n  }\n\n  var max = priv(this, 'max', options.max)\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!max ||\n      !(typeof max === 'number') ||\n      max <= 0) {\n    priv(this, 'max', Infinity)\n  }\n\n  var lc = options.length || naiveLength\n  if (typeof lc !== 'function') {\n    lc = naiveLength\n  }\n  priv(this, 'lengthCalculator', lc)\n\n  priv(this, 'allowStale', options.stale || false)\n  priv(this, 'maxAge', options.maxAge || 0)\n  priv(this, 'dispose', options.dispose)\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function (mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity\n    }\n    priv(this, 'max', mL)\n    trim(this)\n  },\n  get: function () {\n    return priv(this, 'max')\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function (allowStale) {\n    priv(this, 'allowStale', !!allowStale)\n  },\n  get: function () {\n    return priv(this, 'allowStale')\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function (mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0\n    }\n    priv(this, 'maxAge', mA)\n    trim(this)\n  },\n  get: function () {\n    return priv(this, 'maxAge')\n  },\n  enumerable: true\n})\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function (lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength\n    }\n    if (lC !== priv(this, 'lengthCalculator')) {\n      priv(this, 'lengthCalculator', lC)\n      priv(this, 'length', 0)\n      priv(this, 'lruList').forEach(function (hit) {\n        hit.length = priv(this, 'lengthCalculator').call(this, hit.value, hit.key)\n        priv(this, 'length', priv(this, 'length') + hit.length)\n      }, this)\n    }\n    trim(this)\n  },\n  get: function () { return priv(this, 'lengthCalculator') },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function () { return priv(this, 'length') },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function () { return priv(this, 'lruList').length },\n  enumerable: true\n})\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = priv(this, 'lruList').tail; walker !== null;) {\n    var prev = walker.prev\n    forEachStep(this, fn, walker, thisp)\n    walker = prev\n  }\n}\n\nfunction forEachStep (self, fn, node, thisp) {\n  var hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!priv(self, 'allowStale')) {\n      hit = undefined\n    }\n  }\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self)\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = priv(this, 'lruList').head; walker !== null;) {\n    var next = walker.next\n    forEachStep(this, fn, walker, thisp)\n    walker = next\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  return priv(this, 'lruList').toArray().map(function (k) {\n    return k.key\n  }, this)\n}\n\nLRUCache.prototype.values = function () {\n  return priv(this, 'lruList').toArray().map(function (k) {\n    return k.value\n  }, this)\n}\n\nLRUCache.prototype.reset = function () {\n  if (priv(this, 'dispose') &&\n      priv(this, 'lruList') &&\n      priv(this, 'lruList').length) {\n    priv(this, 'lruList').forEach(function (hit) {\n      priv(this, 'dispose').call(this, hit.key, hit.value)\n    }, this)\n  }\n\n  priv(this, 'cache', new Map()) // hash of items by key\n  priv(this, 'lruList', new Yallist()) // list of items in order of use recency\n  priv(this, 'length', 0) // length of items in the list\n}\n\nLRUCache.prototype.dump = function () {\n  return priv(this, 'lruList').map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }\n    }\n  }, this).toArray().filter(function (h) {\n    return h\n  })\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return priv(this, 'lruList')\n}\n\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {'\n  var extras = false\n\n  var as = priv(this, 'allowStale')\n  if (as) {\n    str += '\\n  allowStale: true'\n    extras = true\n  }\n\n  var max = priv(this, 'max')\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  max: ' + util.inspect(max, opts)\n    extras = true\n  }\n\n  var maxAge = priv(this, 'maxAge')\n  if (maxAge) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts)\n    extras = true\n  }\n\n  var lc = priv(this, 'lengthCalculator')\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  length: ' + util.inspect(priv(this, 'length'), opts)\n    extras = true\n  }\n\n  var didFirst = false\n  priv(this, 'lruList').forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  '\n    } else {\n      if (extras) {\n        str += ',\\n'\n      }\n      didFirst = true\n      str += '\\n  '\n    }\n    var key = util.inspect(item.key).split('\\n').join('\\n  ')\n    var val = { value: item.value }\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge\n    }\n    if (lc !== naiveLength) {\n      val.length = item.length\n    }\n    if (isStale(this, item)) {\n      val.stale = true\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ')\n    str += key + ' => ' + val\n  })\n\n  if (didFirst || extras) {\n    str += '\\n'\n  }\n  str += '}'\n\n  return str\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || priv(this, 'maxAge')\n\n  var now = maxAge ? Date.now() : 0\n  var len = priv(this, 'lengthCalculator').call(this, value, key)\n\n  if (priv(this, 'cache').has(key)) {\n    if (len > priv(this, 'max')) {\n      del(this, priv(this, 'cache').get(key))\n      return false\n    }\n\n    var node = priv(this, 'cache').get(key)\n    var item = node.value\n\n    // dispose of the old one before overwriting\n    if (priv(this, 'dispose')) {\n      priv(this, 'dispose').call(this, key, item.value)\n    }\n\n    item.now = now\n    item.maxAge = maxAge\n    item.value = value\n    priv(this, 'length', priv(this, 'length') + (len - item.length))\n    item.length = len\n    this.get(key)\n    trim(this)\n    return true\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > priv(this, 'max')) {\n    if (priv(this, 'dispose')) {\n      priv(this, 'dispose').call(this, key, value)\n    }\n    return false\n  }\n\n  priv(this, 'length', priv(this, 'length') + hit.length)\n  priv(this, 'lruList').unshift(hit)\n  priv(this, 'cache').set(key, priv(this, 'lruList').head)\n  trim(this)\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  if (!priv(this, 'cache').has(key)) return false\n  var hit = priv(this, 'cache').get(key).value\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var node = priv(this, 'lruList').tail\n  if (!node) return null\n  del(this, node)\n  return node.value\n}\n\nLRUCache.prototype.del = function (key) {\n  del(this, priv(this, 'cache').get(key))\n}\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset()\n\n  var now = Date.now()\n  // A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l]\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      // dont add already expired items\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge)\n      }\n    }\n  }\n}\n\nLRUCache.prototype.prune = function () {\n  var self = this\n  priv(this, 'cache').forEach(function (value, key) {\n    get(self, key, false)\n  })\n}\n\nfunction get (self, key, doUse) {\n  var node = priv(self, 'cache').get(key)\n  if (node) {\n    var hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!priv(self, 'allowStale')) hit = undefined\n    } else {\n      if (doUse) {\n        priv(self, 'lruList').unshiftNode(node)\n      }\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale (self, hit) {\n  if (!hit || (!hit.maxAge && !priv(self, 'maxAge'))) {\n    return false\n  }\n  var stale = false\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = priv(self, 'maxAge') && (diff > priv(self, 'maxAge'))\n  }\n  return stale\n}\n\nfunction trim (self) {\n  if (priv(self, 'length') > priv(self, 'max')) {\n    for (var walker = priv(self, 'lruList').tail;\n         priv(self, 'length') > priv(self, 'max') && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nfunction del (self, node) {\n  if (node) {\n    var hit = node.value\n    if (priv(self, 'dispose')) {\n      priv(self, 'dispose').call(this, hit.key, hit.value)\n    }\n    priv(self, 'length', priv(self, 'length') - hit.length)\n    priv(self, 'cache').delete(hit.key)\n    priv(self, 'lruList').removeNode(node)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.length = length\n  this.now = now\n  this.maxAge = maxAge || 0\n}\n","module.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n","/*!\n * morgan\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = morgan\nmodule.exports.compile = compile\nmodule.exports.format = format\nmodule.exports.token = token\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar auth = require('basic-auth')\nvar debug = require('debug')('morgan')\nvar deprecate = require('depd')('morgan')\nvar onFinished = require('on-finished')\nvar onHeaders = require('on-headers')\n\n/**\n * Array of CLF month names.\n * @private\n */\n\nvar CLF_MONTH = [\n  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n]\n\n/**\n * Default log buffer duration.\n * @private\n */\n\nvar DEFAULT_BUFFER_DURATION = 1000\n\n/**\n * Create a logger middleware.\n *\n * @public\n * @param {String|Function} format\n * @param {Object} [options]\n * @return {Function} middleware\n */\n\nfunction morgan (format, options) {\n  var fmt = format\n  var opts = options || {}\n\n  if (format && typeof format === 'object') {\n    opts = format\n    fmt = opts.format || 'default'\n\n    // smart deprecation message\n    deprecate('morgan(options): use morgan(' + (typeof fmt === 'string' ? JSON.stringify(fmt) : 'format') + ', options) instead')\n  }\n\n  if (fmt === undefined) {\n    deprecate('undefined format: specify a format')\n  }\n\n  // output on request instead of response\n  var immediate = opts.immediate\n\n  // check if log entry should be skipped\n  var skip = opts.skip || false\n\n  // format function\n  var formatLine = typeof fmt !== 'function'\n    ? getFormatFunction(fmt)\n    : fmt\n\n  // stream\n  var buffer = opts.buffer\n  var stream = opts.stream || process.stdout\n\n  // buffering support\n  if (buffer) {\n    deprecate('buffer option')\n\n    // flush interval\n    var interval = typeof buffer !== 'number'\n      ? DEFAULT_BUFFER_DURATION\n      : buffer\n\n    // swap the stream\n    stream = createBufferStream(stream, interval)\n  }\n\n  return function logger (req, res, next) {\n    // request data\n    req._startAt = undefined\n    req._startTime = undefined\n    req._remoteAddress = getip(req)\n\n    // response data\n    res._startAt = undefined\n    res._startTime = undefined\n\n    // record request start\n    recordStartTime.call(req)\n\n    function logRequest () {\n      if (skip !== false && skip(req, res)) {\n        debug('skip request')\n        return\n      }\n\n      var line = formatLine(morgan, req, res)\n\n      if (line == null) {\n        debug('skip line')\n        return\n      }\n\n      debug('log request')\n      stream.write(line + '\\n')\n    };\n\n    if (immediate) {\n      // immediate log\n      logRequest()\n    } else {\n      // record response start\n      onHeaders(res, recordStartTime)\n\n      // log when response finished\n      onFinished(res, logRequest)\n    }\n\n    next()\n  }\n}\n\n/**\n * Apache combined log format.\n */\n\nmorgan.format('combined', ':remote-addr - :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"')\n\n/**\n * Apache common log format.\n */\n\nmorgan.format('common', ':remote-addr - :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length]')\n\n/**\n * Default format.\n */\n\nmorgan.format('default', ':remote-addr - :remote-user [:date] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"')\ndeprecate.property(morgan, 'default', 'default format: use combined format')\n\n/**\n * Short format.\n */\n\nmorgan.format('short', ':remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms')\n\n/**\n * Tiny format.\n */\n\nmorgan.format('tiny', ':method :url :status :res[content-length] - :response-time ms')\n\n/**\n * dev (colored)\n */\n\nmorgan.format('dev', function developmentFormatLine (tokens, req, res) {\n  // get the status code if response written\n  var status = headersSent(res)\n    ? res.statusCode\n    : undefined\n\n  // get status color\n  var color = status >= 500 ? 31 // red\n    : status >= 400 ? 33 // yellow\n      : status >= 300 ? 36 // cyan\n        : status >= 200 ? 32 // green\n          : 0 // no color\n\n  // get colored function\n  var fn = developmentFormatLine[color]\n\n  if (!fn) {\n    // compile\n    fn = developmentFormatLine[color] = compile('\\x1b[0m:method :url \\x1b[' +\n      color + 'm:status \\x1b[0m:response-time ms - :res[content-length]\\x1b[0m')\n  }\n\n  return fn(tokens, req, res)\n})\n\n/**\n * request url\n */\n\nmorgan.token('url', function getUrlToken (req) {\n  return req.originalUrl || req.url\n})\n\n/**\n * request method\n */\n\nmorgan.token('method', function getMethodToken (req) {\n  return req.method\n})\n\n/**\n * response time in milliseconds\n */\n\nmorgan.token('response-time', function getResponseTimeToken (req, res, digits) {\n  if (!req._startAt || !res._startAt) {\n    // missing request and/or response start time\n    return\n  }\n\n  // calculate diff\n  var ms = (res._startAt[0] - req._startAt[0]) * 1e3 +\n    (res._startAt[1] - req._startAt[1]) * 1e-6\n\n  // return truncated value\n  return ms.toFixed(digits === undefined ? 3 : digits)\n})\n\n/**\n * current date\n */\n\nmorgan.token('date', function getDateToken (req, res, format) {\n  var date = new Date()\n\n  switch (format || 'web') {\n    case 'clf':\n      return clfdate(date)\n    case 'iso':\n      return date.toISOString()\n    case 'web':\n      return date.toUTCString()\n  }\n})\n\n/**\n * response status code\n */\n\nmorgan.token('status', function getStatusToken (req, res) {\n  return headersSent(res)\n    ? String(res.statusCode)\n    : undefined\n})\n\n/**\n * normalized referrer\n */\n\nmorgan.token('referrer', function getReferrerToken (req) {\n  return req.headers['referer'] || req.headers['referrer']\n})\n\n/**\n * remote address\n */\n\nmorgan.token('remote-addr', getip)\n\n/**\n * remote user\n */\n\nmorgan.token('remote-user', function getRemoteUserToken (req) {\n  // parse basic credentials\n  var credentials = auth(req)\n\n  // return username\n  return credentials\n    ? credentials.name\n    : undefined\n})\n\n/**\n * HTTP version\n */\n\nmorgan.token('http-version', function getHttpVersionToken (req) {\n  return req.httpVersionMajor + '.' + req.httpVersionMinor\n})\n\n/**\n * UA string\n */\n\nmorgan.token('user-agent', function getUserAgentToken (req) {\n  return req.headers['user-agent']\n})\n\n/**\n * request header\n */\n\nmorgan.token('req', function getRequestToken (req, res, field) {\n  // get header\n  var header = req.headers[field.toLowerCase()]\n\n  return Array.isArray(header)\n    ? header.join(', ')\n    : header\n})\n\n/**\n * response header\n */\n\nmorgan.token('res', function getResponseHeader (req, res, field) {\n  if (!headersSent(res)) {\n    return undefined\n  }\n\n  // get header\n  var header = res.getHeader(field)\n\n  return Array.isArray(header)\n    ? header.join(', ')\n    : header\n})\n\n/**\n * Format a Date in the common log format.\n *\n * @private\n * @param {Date} dateTime\n * @return {string}\n */\n\nfunction clfdate (dateTime) {\n  var date = dateTime.getUTCDate()\n  var hour = dateTime.getUTCHours()\n  var mins = dateTime.getUTCMinutes()\n  var secs = dateTime.getUTCSeconds()\n  var year = dateTime.getUTCFullYear()\n\n  var month = CLF_MONTH[dateTime.getUTCMonth()]\n\n  return pad2(date) + '/' + month + '/' + year +\n    ':' + pad2(hour) + ':' + pad2(mins) + ':' + pad2(secs) +\n    ' +0000'\n}\n\n/**\n * Compile a format string into a function.\n *\n * @param {string} format\n * @return {function}\n * @public\n */\n\nfunction compile (format) {\n  if (typeof format !== 'string') {\n    throw new TypeError('argument format must be a string')\n  }\n\n  var fmt = String(JSON.stringify(format))\n  var js = '  \"use strict\"\\n  return ' + fmt.replace(/:([-\\w]{2,})(?:\\[([^\\]]+)\\])?/g, function (_, name, arg) {\n    var tokenArguments = 'req, res'\n    var tokenFunction = 'tokens[' + String(JSON.stringify(name)) + ']'\n\n    if (arg !== undefined) {\n      tokenArguments += ', ' + String(JSON.stringify(arg))\n    }\n\n    return '\" +\\n    (' + tokenFunction + '(' + tokenArguments + ') || \"-\") + \"'\n  })\n\n  // eslint-disable-next-line no-new-func\n  return new Function('tokens, req, res', js)\n}\n\n/**\n * Create a basic buffering stream.\n *\n * @param {object} stream\n * @param {number} interval\n * @public\n */\n\nfunction createBufferStream (stream, interval) {\n  var buf = []\n  var timer = null\n\n  // flush function\n  function flush () {\n    timer = null\n    stream.write(buf.join(''))\n    buf.length = 0\n  }\n\n  // write function\n  function write (str) {\n    if (timer === null) {\n      timer = setTimeout(flush, interval)\n    }\n\n    buf.push(str)\n  }\n\n  // return a minimal \"stream\"\n  return { write: write }\n}\n\n/**\n * Define a format with the given name.\n *\n * @param {string} name\n * @param {string|function} fmt\n * @public\n */\n\nfunction format (name, fmt) {\n  morgan[name] = fmt\n  return this\n}\n\n/**\n * Lookup and compile a named format function.\n *\n * @param {string} name\n * @return {function}\n * @public\n */\n\nfunction getFormatFunction (name) {\n  // lookup format\n  var fmt = morgan[name] || name || morgan.default\n\n  // return compiled format\n  return typeof fmt !== 'function'\n    ? compile(fmt)\n    : fmt\n}\n\n/**\n * Get request IP address.\n *\n * @private\n * @param {IncomingMessage} req\n * @return {string}\n */\n\nfunction getip (req) {\n  return req.ip ||\n    req._remoteAddress ||\n    (req.connection && req.connection.remoteAddress) ||\n    undefined\n}\n\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\nfunction headersSent (res) {\n  return typeof res.headersSent !== 'boolean'\n    ? Boolean(res._header)\n    : res.headersSent\n}\n\n/**\n * Pad number to two digits.\n *\n * @private\n * @param {number} num\n * @return {string}\n */\n\nfunction pad2 (num) {\n  var str = String(num)\n\n  return (str.length === 1 ? '0' : '') + str\n}\n\n/**\n * Record the start time.\n * @private\n */\n\nfunction recordStartTime () {\n  this._startAt = process.hrtime()\n  this._startTime = new Date()\n}\n\n/**\n * Define a token function with the given name,\n * and callback fn(req, res).\n *\n * @param {string} name\n * @param {function} fn\n * @public\n */\n\nfunction token (name, fn) {\n  morgan[name] = fn\n  return this\n}\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","if (process.env.npm_package_name === 'pseudomap' &&\n    process.env.npm_lifecycle_script === 'test')\n  process.env.TEST_PSEUDOMAP = 'true'\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map\n} else {\n  module.exports = require('./pseudomap')\n}\n","var hasOwnProperty = Object.prototype.hasOwnProperty\n\nmodule.exports = PseudoMap\n\nfunction PseudoMap (set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\")\n\n  this.clear()\n\n  if (set) {\n    if ((set instanceof PseudoMap) ||\n        (typeof Map === 'function' && set instanceof Map))\n      set.forEach(function (value, key) {\n        this.set(key, value)\n      }, this)\n    else if (Array.isArray(set))\n      set.forEach(function (kv) {\n        this.set(kv[0], kv[1])\n      }, this)\n    else\n      throw new TypeError('invalid argument')\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size')\n      fn.call(thisp, this._data[k].value, this._data[k].key)\n  }, this)\n}\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k)\n}\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k)\n  return res && res.value\n}\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v)\n}\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k)\n  if (res) {\n    delete this._data[res._index]\n    this._data.size--\n  }\n}\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null)\n  data.size = 0\n\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  })\n}\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function () {\n    return this._data.size\n  },\n  set: function (n) {},\n  enumerable: true,\n  configurable: true\n})\n\nPseudoMap.prototype.values =\nPseudoMap.prototype.keys =\nPseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version')\n}\n\n// Either identical, or both NaN\nfunction same (a, b) {\n  return a === b || a !== a && b !== b\n}\n\nfunction Entry (k, v, i) {\n  this.key = k\n  this.value = v\n  this._index = i\n}\n\nfunction find (data, k) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k))\n      return data[key]\n  }\n}\n\nfunction set (data, k, v) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v\n      return\n    }\n  }\n  data.size++\n  data[key] = new Entry(k, v, key)\n}\n","\"use strict\";\n\nvar punycode = require(\"punycode\");\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar PROCESSING_OPTIONS = {\n  TRANSITIONAL: 0,\n  NONTRANSITIONAL: 1\n};\n\nfunction normalize(str) { // fix bug in v8\n  return str.split('\\u0000').map(function (s) { return s.normalize('NFC'); }).join('\\u0000');\n}\n\nfunction findStatus(val) {\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n\n    var target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      return target;\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction countSymbols(string) {\n  return string\n    // replace every surrogate pair with a BMP symbol\n    .replace(regexAstralSymbols, '_')\n    // then get the length\n    .length;\n}\n\nfunction mapChars(domain_name, useSTD3, processing_option) {\n  var hasError = false;\n  var processed = \"\";\n\n  var len = countSymbols(domain_name);\n  for (var i = 0; i < len; ++i) {\n    var codePoint = domain_name.codePointAt(i);\n    var status = findStatus(codePoint);\n\n    switch (status[1]) {\n      case \"disallowed\":\n        hasError = true;\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += String.fromCodePoint.apply(String, status[2]);\n        break;\n      case \"deviation\":\n        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        } else {\n          processed += String.fromCodePoint(codePoint);\n        }\n        break;\n      case \"valid\":\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"disallowed_STD3_mapped\":\n        if (useSTD3) {\n          hasError = true;\n          processed += String.fromCodePoint(codePoint);\n        } else {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        }\n        break;\n      case \"disallowed_STD3_valid\":\n        if (useSTD3) {\n          hasError = true;\n        }\n\n        processed += String.fromCodePoint(codePoint);\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nvar combiningMarksRegex = /[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2D]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDE2C-\\uDE37\\uDEDF-\\uDEEA\\uDF01-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD83A[\\uDCD0-\\uDCD6]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nfunction validateLabel(label, processing_option) {\n  if (label.substr(0, 4) === \"xn--\") {\n    label = punycode.toUnicode(label);\n    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;\n  }\n\n  var error = false;\n\n  if (normalize(label) !== label ||\n      (label[3] === \"-\" && label[4] === \"-\") ||\n      label[0] === \"-\" || label[label.length - 1] === \"-\" ||\n      label.indexOf(\".\") !== -1 ||\n      label.search(combiningMarksRegex) === 0) {\n    error = true;\n  }\n\n  var len = countSymbols(label);\n  for (var i = 0; i < len; ++i) {\n    var status = findStatus(label.codePointAt(i));\n    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== \"valid\") ||\n        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&\n         status[1] !== \"valid\" && status[1] !== \"deviation\")) {\n      error = true;\n      break;\n    }\n  }\n\n  return {\n    label: label,\n    error: error\n  };\n}\n\nfunction processing(domain_name, useSTD3, processing_option) {\n  var result = mapChars(domain_name, useSTD3, processing_option);\n  result.string = normalize(result.string);\n\n  var labels = result.string.split(\".\");\n  for (var i = 0; i < labels.length; ++i) {\n    try {\n      var validation = validateLabel(labels[i]);\n      labels[i] = validation.label;\n      result.error = result.error || validation.error;\n    } catch(e) {\n      result.error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: result.error\n  };\n}\n\nmodule.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {\n  var result = processing(domain_name, useSTD3, processing_option);\n  var labels = result.string.split(\".\");\n  labels = labels.map(function(l) {\n    try {\n      return punycode.toASCII(l);\n    } catch(e) {\n      result.error = true;\n      return l;\n    }\n  });\n\n  if (verifyDnsLength) {\n    var total = labels.slice(0, labels.length - 1).join(\".\").length;\n    if (total.length > 253 || total.length === 0) {\n      result.error = true;\n    }\n\n    for (var i=0; i < labels.length; ++i) {\n      if (labels.length > 63 || labels.length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) return null;\n  return labels.join(\".\");\n};\n\nmodule.exports.toUnicode = function(domain_name, useSTD3) {\n  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n};\n\nmodule.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;\n","\"use strict\";\nconst usm = require(\"./url-state-machine\");\n\nexports.implementation = class URLImpl {\n  constructor(constructorArgs) {\n    const url = constructorArgs[0];\n    const base = constructorArgs[1];\n\n    let parsedBase = null;\n    if (base !== undefined) {\n      parsedBase = usm.basicURLParse(base);\n      if (parsedBase === \"failure\") {\n        throw new TypeError(\"Invalid base URL\");\n      }\n    }\n\n    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n\n    // TODO: query stuff\n  }\n\n  get href() {\n    return usm.serializeURL(this._url);\n  }\n\n  set href(v) {\n    const parsedURL = usm.basicURLParse(v);\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n  }\n\n  get origin() {\n    return usm.serializeURLOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    usm.basicURLParse(v + \":\", { url: this._url, stateOverride: \"scheme start\" });\n  }\n\n  get username() {\n    return this._url.username;\n  }\n\n  set username(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setTheUsername(this._url, v);\n  }\n\n  get password() {\n    return this._url.password;\n  }\n\n  set password(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setThePassword(this._url, v);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return usm.serializeHost(url.host);\n    }\n\n    return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"host\" });\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return usm.serializeHost(this._url.host);\n  }\n\n  set hostname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"hostname\" });\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return usm.serializeInteger(this._url.port);\n  }\n\n  set port(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    if (v === \"\") {\n      this._url.port = null;\n    } else {\n      usm.basicURLParse(v, { url: this._url, stateOverride: \"port\" });\n    }\n  }\n\n  get pathname() {\n    if (this._url.cannotBeABaseURL) {\n      return this._url.path[0];\n    }\n\n    if (this._url.path.length === 0) {\n      return \"\";\n    }\n\n    return \"/\" + this._url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    this._url.path = [];\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n\n  set search(v) {\n    // TODO: query stuff\n\n    const url = this._url;\n\n    if (v === \"\") {\n      url.query = null;\n      return;\n    }\n\n    const input = v[0] === \"?\" ? v.substring(1) : v;\n    url.query = \"\";\n    usm.basicURLParse(input, { url, stateOverride: \"query\" });\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n\n  set hash(v) {\n    if (v === \"\") {\n      this._url.fragment = null;\n      return;\n    }\n\n    const input = v[0] === \"#\" ? v.substring(1) : v;\n    this._url.fragment = \"\";\n    usm.basicURLParse(input, { url: this._url, stateOverride: \"fragment\" });\n  }\n\n  toJSON() {\n    return this.href;\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Impl = require(\".//URL-impl.js\");\n\nconst impl = utils.implSymbol;\n\nfunction URL(url) {\n  if (!this || this[impl] || !(this instanceof URL)) {\n    throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"USVString\"](args[1]);\n  }\n\n  module.exports.setup(this, args);\n}\n\nURL.prototype.toJSON = function toJSON() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = arguments[i];\n  }\n  return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nURL.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this.href;\n};\n\nObject.defineProperty(URL.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nmodule.exports = {\n  is(obj) {\n    return !!obj && obj[impl] instanceof Impl.implementation;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URL.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: URL,\n  expose: {\n    Window: { URL: URL },\n    Worker: { URL: URL }\n  }\n};\n\n","\"use strict\";\n\nexports.URL = require(\"./URL\").interface;\nexports.serializeURL = require(\"./url-state-machine\").serializeURL;\nexports.serializeURLOrigin = require(\"./url-state-machine\").serializeURLOrigin;\nexports.basicURLParse = require(\"./url-state-machine\").basicURLParse;\nexports.setTheUsername = require(\"./url-state-machine\").setTheUsername;\nexports.setThePassword = require(\"./url-state-machine\").setThePassword;\nexports.serializeHost = require(\"./url-state-machine\").serializeHost;\nexports.serializeInteger = require(\"./url-state-machine\").serializeInteger;\nexports.parseURL = require(\"./url-state-machine\").parseURL;\n","\"use strict\";\r\nconst punycode = require(\"punycode\");\r\nconst tr46 = require(\"tr46\");\r\n\r\nconst specialSchemes = {\r\n  ftp: 21,\r\n  file: null,\r\n  gopher: 70,\r\n  http: 80,\r\n  https: 443,\r\n  ws: 80,\r\n  wss: 443\r\n};\r\n\r\nconst failure = Symbol(\"failure\");\r\n\r\nfunction countSymbols(str) {\r\n  return punycode.ucs2.decode(str).length;\r\n}\r\n\r\nfunction at(input, idx) {\r\n  const c = input[idx];\r\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\r\n}\r\n\r\nfunction isASCIIDigit(c) {\r\n  return c >= 0x30 && c <= 0x39;\r\n}\r\n\r\nfunction isASCIIAlpha(c) {\r\n  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);\r\n}\r\n\r\nfunction isASCIIAlphanumeric(c) {\r\n  return isASCIIAlpha(c) || isASCIIDigit(c);\r\n}\r\n\r\nfunction isASCIIHex(c) {\r\n  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);\r\n}\r\n\r\nfunction isSingleDot(buffer) {\r\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\r\n}\r\n\r\nfunction isDoubleDot(buffer) {\r\n  buffer = buffer.toLowerCase();\r\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\r\n}\r\n\r\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\r\n  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\r\n}\r\n\r\nfunction isWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\r\n}\r\n\r\nfunction containsForbiddenHostCodePoint(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction isSpecialScheme(scheme) {\r\n  return specialSchemes[scheme] !== undefined;\r\n}\r\n\r\nfunction isSpecial(url) {\r\n  return isSpecialScheme(url.scheme);\r\n}\r\n\r\nfunction defaultPort(scheme) {\r\n  return specialSchemes[scheme];\r\n}\r\n\r\nfunction percentEncode(c) {\r\n  let hex = c.toString(16).toUpperCase();\r\n  if (hex.length === 1) {\r\n    hex = \"0\" + hex;\r\n  }\r\n\r\n  return \"%\" + hex;\r\n}\r\n\r\nfunction utf8PercentEncode(c) {\r\n  const buf = new Buffer(c);\r\n\r\n  let str = \"\";\r\n\r\n  for (let i = 0; i < buf.length; ++i) {\r\n    str += percentEncode(buf[i]);\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction utf8PercentDecode(str) {\r\n  const input = new Buffer(str);\r\n  const output = [];\r\n  for (let i = 0; i < input.length; ++i) {\r\n    if (input[i] !== 37) {\r\n      output.push(input[i]);\r\n    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\r\n      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\r\n      i += 2;\r\n    } else {\r\n      output.push(input[i]);\r\n    }\r\n  }\r\n  return new Buffer(output).toString();\r\n}\r\n\r\nfunction isC0ControlPercentEncode(c) {\r\n  return c <= 0x1F || c > 0x7E;\r\n}\r\n\r\nconst extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);\r\nfunction isPathPercentEncode(c) {\r\n  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\r\n}\r\n\r\nconst extraUserinfoPercentEncodeSet =\r\n  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\r\nfunction isUserinfoPercentEncode(c) {\r\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\r\n}\r\n\r\nfunction percentEncodeChar(c, encodeSetPredicate) {\r\n  const cStr = String.fromCodePoint(c);\r\n\r\n  if (encodeSetPredicate(c)) {\r\n    return utf8PercentEncode(cStr);\r\n  }\r\n\r\n  return cStr;\r\n}\r\n\r\nfunction parseIPv4Number(input) {\r\n  let R = 10;\r\n\r\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\r\n    input = input.substring(2);\r\n    R = 16;\r\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\r\n    input = input.substring(1);\r\n    R = 8;\r\n  }\r\n\r\n  if (input === \"\") {\r\n    return 0;\r\n  }\r\n\r\n  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);\r\n  if (regex.test(input)) {\r\n    return failure;\r\n  }\r\n\r\n  return parseInt(input, R);\r\n}\r\n\r\nfunction parseIPv4(input) {\r\n  const parts = input.split(\".\");\r\n  if (parts[parts.length - 1] === \"\") {\r\n    if (parts.length > 1) {\r\n      parts.pop();\r\n    }\r\n  }\r\n\r\n  if (parts.length > 4) {\r\n    return input;\r\n  }\r\n\r\n  const numbers = [];\r\n  for (const part of parts) {\r\n    if (part === \"\") {\r\n      return input;\r\n    }\r\n    const n = parseIPv4Number(part);\r\n    if (n === failure) {\r\n      return input;\r\n    }\r\n\r\n    numbers.push(n);\r\n  }\r\n\r\n  for (let i = 0; i < numbers.length - 1; ++i) {\r\n    if (numbers[i] > 255) {\r\n      return failure;\r\n    }\r\n  }\r\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\r\n    return failure;\r\n  }\r\n\r\n  let ipv4 = numbers.pop();\r\n  let counter = 0;\r\n\r\n  for (const n of numbers) {\r\n    ipv4 += n * Math.pow(256, 3 - counter);\r\n    ++counter;\r\n  }\r\n\r\n  return ipv4;\r\n}\r\n\r\nfunction serializeIPv4(address) {\r\n  let output = \"\";\r\n  let n = address;\r\n\r\n  for (let i = 1; i <= 4; ++i) {\r\n    output = String(n % 256) + output;\r\n    if (i !== 4) {\r\n      output = \".\" + output;\r\n    }\r\n    n = Math.floor(n / 256);\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseIPv6(input) {\r\n  const address = [0, 0, 0, 0, 0, 0, 0, 0];\r\n  let pieceIndex = 0;\r\n  let compress = null;\r\n  let pointer = 0;\r\n\r\n  input = punycode.ucs2.decode(input);\r\n\r\n  if (input[pointer] === 58) {\r\n    if (input[pointer + 1] !== 58) {\r\n      return failure;\r\n    }\r\n\r\n    pointer += 2;\r\n    ++pieceIndex;\r\n    compress = pieceIndex;\r\n  }\r\n\r\n  while (pointer < input.length) {\r\n    if (pieceIndex === 8) {\r\n      return failure;\r\n    }\r\n\r\n    if (input[pointer] === 58) {\r\n      if (compress !== null) {\r\n        return failure;\r\n      }\r\n      ++pointer;\r\n      ++pieceIndex;\r\n      compress = pieceIndex;\r\n      continue;\r\n    }\r\n\r\n    let value = 0;\r\n    let length = 0;\r\n\r\n    while (length < 4 && isASCIIHex(input[pointer])) {\r\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\r\n      ++pointer;\r\n      ++length;\r\n    }\r\n\r\n    if (input[pointer] === 46) {\r\n      if (length === 0) {\r\n        return failure;\r\n      }\r\n\r\n      pointer -= length;\r\n\r\n      if (pieceIndex > 6) {\r\n        return failure;\r\n      }\r\n\r\n      let numbersSeen = 0;\r\n\r\n      while (input[pointer] !== undefined) {\r\n        let ipv4Piece = null;\r\n\r\n        if (numbersSeen > 0) {\r\n          if (input[pointer] === 46 && numbersSeen < 4) {\r\n            ++pointer;\r\n          } else {\r\n            return failure;\r\n          }\r\n        }\r\n\r\n        if (!isASCIIDigit(input[pointer])) {\r\n          return failure;\r\n        }\r\n\r\n        while (isASCIIDigit(input[pointer])) {\r\n          const number = parseInt(at(input, pointer));\r\n          if (ipv4Piece === null) {\r\n            ipv4Piece = number;\r\n          } else if (ipv4Piece === 0) {\r\n            return failure;\r\n          } else {\r\n            ipv4Piece = ipv4Piece * 10 + number;\r\n          }\r\n          if (ipv4Piece > 255) {\r\n            return failure;\r\n          }\r\n          ++pointer;\r\n        }\r\n\r\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\r\n\r\n        ++numbersSeen;\r\n\r\n        if (numbersSeen === 2 || numbersSeen === 4) {\r\n          ++pieceIndex;\r\n        }\r\n      }\r\n\r\n      if (numbersSeen !== 4) {\r\n        return failure;\r\n      }\r\n\r\n      break;\r\n    } else if (input[pointer] === 58) {\r\n      ++pointer;\r\n      if (input[pointer] === undefined) {\r\n        return failure;\r\n      }\r\n    } else if (input[pointer] !== undefined) {\r\n      return failure;\r\n    }\r\n\r\n    address[pieceIndex] = value;\r\n    ++pieceIndex;\r\n  }\r\n\r\n  if (compress !== null) {\r\n    let swaps = pieceIndex - compress;\r\n    pieceIndex = 7;\r\n    while (pieceIndex !== 0 && swaps > 0) {\r\n      const temp = address[compress + swaps - 1];\r\n      address[compress + swaps - 1] = address[pieceIndex];\r\n      address[pieceIndex] = temp;\r\n      --pieceIndex;\r\n      --swaps;\r\n    }\r\n  } else if (compress === null && pieceIndex !== 8) {\r\n    return failure;\r\n  }\r\n\r\n  return address;\r\n}\r\n\r\nfunction serializeIPv6(address) {\r\n  let output = \"\";\r\n  const seqResult = findLongestZeroSequence(address);\r\n  const compress = seqResult.idx;\r\n  let ignore0 = false;\r\n\r\n  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\r\n    if (ignore0 && address[pieceIndex] === 0) {\r\n      continue;\r\n    } else if (ignore0) {\r\n      ignore0 = false;\r\n    }\r\n\r\n    if (compress === pieceIndex) {\r\n      const separator = pieceIndex === 0 ? \"::\" : \":\";\r\n      output += separator;\r\n      ignore0 = true;\r\n      continue;\r\n    }\r\n\r\n    output += address[pieceIndex].toString(16);\r\n\r\n    if (pieceIndex !== 7) {\r\n      output += \":\";\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseHost(input, isSpecialArg) {\r\n  if (input[0] === \"[\") {\r\n    if (input[input.length - 1] !== \"]\") {\r\n      return failure;\r\n    }\r\n\r\n    return parseIPv6(input.substring(1, input.length - 1));\r\n  }\r\n\r\n  if (!isSpecialArg) {\r\n    return parseOpaqueHost(input);\r\n  }\r\n\r\n  const domain = utf8PercentDecode(input);\r\n  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\r\n  if (asciiDomain === null) {\r\n    return failure;\r\n  }\r\n\r\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\r\n    return failure;\r\n  }\r\n\r\n  const ipv4Host = parseIPv4(asciiDomain);\r\n  if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\r\n    return ipv4Host;\r\n  }\r\n\r\n  return asciiDomain;\r\n}\r\n\r\nfunction parseOpaqueHost(input) {\r\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\r\n    return failure;\r\n  }\r\n\r\n  let output = \"\";\r\n  const decoded = punycode.ucs2.decode(input);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction findLongestZeroSequence(arr) {\r\n  let maxIdx = null;\r\n  let maxLen = 1; // only find elements > 1\r\n  let currStart = null;\r\n  let currLen = 0;\r\n\r\n  for (let i = 0; i < arr.length; ++i) {\r\n    if (arr[i] !== 0) {\r\n      if (currLen > maxLen) {\r\n        maxIdx = currStart;\r\n        maxLen = currLen;\r\n      }\r\n\r\n      currStart = null;\r\n      currLen = 0;\r\n    } else {\r\n      if (currStart === null) {\r\n        currStart = i;\r\n      }\r\n      ++currLen;\r\n    }\r\n  }\r\n\r\n  // if trailing zeros\r\n  if (currLen > maxLen) {\r\n    maxIdx = currStart;\r\n    maxLen = currLen;\r\n  }\r\n\r\n  return {\r\n    idx: maxIdx,\r\n    len: maxLen\r\n  };\r\n}\r\n\r\nfunction serializeHost(host) {\r\n  if (typeof host === \"number\") {\r\n    return serializeIPv4(host);\r\n  }\r\n\r\n  // IPv6 serializer\r\n  if (host instanceof Array) {\r\n    return \"[\" + serializeIPv6(host) + \"]\";\r\n  }\r\n\r\n  return host;\r\n}\r\n\r\nfunction trimControlChars(url) {\r\n  return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\r\n}\r\n\r\nfunction trimTabAndNewline(url) {\r\n  return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\r\n}\r\n\r\nfunction shortenPath(url) {\r\n  const path = url.path;\r\n  if (path.length === 0) {\r\n    return;\r\n  }\r\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\r\n    return;\r\n  }\r\n\r\n  path.pop();\r\n}\r\n\r\nfunction includesCredentials(url) {\r\n  return url.username !== \"\" || url.password !== \"\";\r\n}\r\n\r\nfunction cannotHaveAUsernamePasswordPort(url) {\r\n  return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetter(string) {\r\n  return /^[A-Za-z]:$/.test(string);\r\n}\r\n\r\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\r\n  this.pointer = 0;\r\n  this.input = input;\r\n  this.base = base || null;\r\n  this.encodingOverride = encodingOverride || \"utf-8\";\r\n  this.stateOverride = stateOverride;\r\n  this.url = url;\r\n  this.failure = false;\r\n  this.parseError = false;\r\n\r\n  if (!this.url) {\r\n    this.url = {\r\n      scheme: \"\",\r\n      username: \"\",\r\n      password: \"\",\r\n      host: null,\r\n      port: null,\r\n      path: [],\r\n      query: null,\r\n      fragment: null,\r\n\r\n      cannotBeABaseURL: false\r\n    };\r\n\r\n    const res = trimControlChars(this.input);\r\n    if (res !== this.input) {\r\n      this.parseError = true;\r\n    }\r\n    this.input = res;\r\n  }\r\n\r\n  const res = trimTabAndNewline(this.input);\r\n  if (res !== this.input) {\r\n    this.parseError = true;\r\n  }\r\n  this.input = res;\r\n\r\n  this.state = stateOverride || \"scheme start\";\r\n\r\n  this.buffer = \"\";\r\n  this.atFlag = false;\r\n  this.arrFlag = false;\r\n  this.passwordTokenSeenFlag = false;\r\n\r\n  this.input = punycode.ucs2.decode(this.input);\r\n\r\n  for (; this.pointer <= this.input.length; ++this.pointer) {\r\n    const c = this.input[this.pointer];\r\n    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\r\n\r\n    // exec state machine\r\n    const ret = this[\"parse \" + this.state](c, cStr);\r\n    if (!ret) {\r\n      break; // terminate algorithm\r\n    } else if (ret === failure) {\r\n      this.failure = true;\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\r\n  if (isASCIIAlpha(c)) {\r\n    this.buffer += cStr.toLowerCase();\r\n    this.state = \"scheme\";\r\n  } else if (!this.stateOverride) {\r\n    this.state = \"no scheme\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\r\n  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\r\n    this.buffer += cStr.toLowerCase();\r\n  } else if (c === 58) {\r\n    if (this.stateOverride) {\r\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\r\n        return false;\r\n      }\r\n\r\n      if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.url.scheme = this.buffer;\r\n    this.buffer = \"\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    if (this.url.scheme === \"file\") {\r\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\r\n        this.parseError = true;\r\n      }\r\n      this.state = \"file\";\r\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\r\n      this.state = \"special relative or authority\";\r\n    } else if (isSpecial(this.url)) {\r\n      this.state = \"special authority slashes\";\r\n    } else if (this.input[this.pointer + 1] === 47) {\r\n      this.state = \"path or authority\";\r\n      ++this.pointer;\r\n    } else {\r\n      this.url.cannotBeABaseURL = true;\r\n      this.url.path.push(\"\");\r\n      this.state = \"cannot-be-a-base-URL path\";\r\n    }\r\n  } else if (!this.stateOverride) {\r\n    this.buffer = \"\";\r\n    this.state = \"no scheme\";\r\n    this.pointer = -1;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\r\n  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {\r\n    return failure;\r\n  } else if (this.base.cannotBeABaseURL && c === 35) {\r\n    this.url.scheme = this.base.scheme;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.url.cannotBeABaseURL = true;\r\n    this.state = \"fragment\";\r\n  } else if (this.base.scheme === \"file\") {\r\n    this.state = \"file\";\r\n    --this.pointer;\r\n  } else {\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\r\n  if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\r\n  this.url.scheme = this.base.scheme;\r\n  if (isNaN(c)) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n  } else if (c === 47) {\r\n    this.state = \"relative slash\";\r\n  } else if (c === 63) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (isSpecial(this.url) && c === 92) {\r\n    this.parseError = true;\r\n    this.state = \"relative slash\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\r\n\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\r\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"special authority ignore slashes\";\r\n  } else if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"special authority ignore slashes\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\r\n  if (c !== 47 && c !== 92) {\r\n    this.state = \"authority\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\r\n  if (c === 64) {\r\n    this.parseError = true;\r\n    if (this.atFlag) {\r\n      this.buffer = \"%40\" + this.buffer;\r\n    }\r\n    this.atFlag = true;\r\n\r\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\r\n    const len = countSymbols(this.buffer);\r\n    for (let pointer = 0; pointer < len; ++pointer) {\r\n      const codePoint = this.buffer.codePointAt(pointer);\r\n\r\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\r\n        this.passwordTokenSeenFlag = true;\r\n        continue;\r\n      }\r\n      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\r\n      if (this.passwordTokenSeenFlag) {\r\n        this.url.password += encodedCodePoints;\r\n      } else {\r\n        this.url.username += encodedCodePoints;\r\n      }\r\n    }\r\n    this.buffer = \"\";\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    if (this.atFlag && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n    this.pointer -= countSymbols(this.buffer) + 1;\r\n    this.buffer = \"\";\r\n    this.state = \"host\";\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse hostname\"] =\r\nURLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\r\n  if (this.stateOverride && this.url.scheme === \"file\") {\r\n    --this.pointer;\r\n    this.state = \"file host\";\r\n  } else if (c === 58 && !this.arrFlag) {\r\n    if (this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"port\";\r\n    if (this.stateOverride === \"hostname\") {\r\n      return false;\r\n    }\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    --this.pointer;\r\n    if (isSpecial(this.url) && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    } else if (this.stateOverride && this.buffer === \"\" &&\r\n               (includesCredentials(this.url) || this.url.port !== null)) {\r\n      this.parseError = true;\r\n      return false;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"path start\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (c === 91) {\r\n      this.arrFlag = true;\r\n    } else if (c === 93) {\r\n      this.arrFlag = false;\r\n    }\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\r\n  if (isASCIIDigit(c)) {\r\n    this.buffer += cStr;\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92) ||\r\n             this.stateOverride) {\r\n    if (this.buffer !== \"\") {\r\n      const port = parseInt(this.buffer);\r\n      if (port > Math.pow(2, 16) - 1) {\r\n        this.parseError = true;\r\n        return failure;\r\n      }\r\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\r\n      this.buffer = \"\";\r\n    }\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    this.state = \"path start\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\r\n\r\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\r\n  this.url.scheme = \"file\";\r\n\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file slash\";\r\n  } else if (this.base !== null && this.base.scheme === \"file\") {\r\n    if (isNaN(c)) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n    } else if (c === 63) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    } else if (c === 35) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    } else {\r\n      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\r\n          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||\r\n          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\r\n           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {\r\n        this.url.host = this.base.host;\r\n        this.url.path = this.base.path.slice();\r\n        shortenPath(this.url);\r\n      } else {\r\n        this.parseError = true;\r\n      }\r\n\r\n      this.state = \"path\";\r\n      --this.pointer;\r\n    }\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file host\";\r\n  } else {\r\n    if (this.base !== null && this.base.scheme === \"file\") {\r\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\r\n        this.url.path.push(this.base.path[0]);\r\n      } else {\r\n        this.url.host = this.base.host;\r\n      }\r\n    }\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\r\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\r\n    --this.pointer;\r\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\r\n      this.parseError = true;\r\n      this.state = \"path\";\r\n    } else if (this.buffer === \"\") {\r\n      this.url.host = \"\";\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n      this.state = \"path start\";\r\n    } else {\r\n      let host = parseHost(this.buffer, isSpecial(this.url));\r\n      if (host === failure) {\r\n        return failure;\r\n      }\r\n      if (host === \"localhost\") {\r\n        host = \"\";\r\n      }\r\n      this.url.host = host;\r\n\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n\r\n      this.buffer = \"\";\r\n      this.state = \"path start\";\r\n    }\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\r\n  if (isSpecial(this.url)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"path\";\r\n\r\n    if (c !== 47 && c !== 92) {\r\n      --this.pointer;\r\n    }\r\n  } else if (!this.stateOverride && c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (!this.stateOverride && c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (c !== undefined) {\r\n    this.state = \"path\";\r\n    if (c !== 47) {\r\n      --this.pointer;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\r\n  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||\r\n      (!this.stateOverride && (c === 63 || c === 35))) {\r\n    if (isSpecial(this.url) && c === 92) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (isDoubleDot(this.buffer)) {\r\n      shortenPath(this.url);\r\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\r\n        this.url.path.push(\"\");\r\n      }\r\n    } else if (isSingleDot(this.buffer) && c !== 47 &&\r\n               !(isSpecial(this.url) && c === 92)) {\r\n      this.url.path.push(\"\");\r\n    } else if (!isSingleDot(this.buffer)) {\r\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\r\n        if (this.url.host !== \"\" && this.url.host !== null) {\r\n          this.parseError = true;\r\n          this.url.host = \"\";\r\n        }\r\n        this.buffer = this.buffer[0] + \":\";\r\n      }\r\n      this.url.path.push(this.buffer);\r\n    }\r\n    this.buffer = \"\";\r\n    if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\r\n      while (this.url.path.length > 1 && this.url.path[0] === \"\") {\r\n        this.parseError = true;\r\n        this.url.path.shift();\r\n      }\r\n    }\r\n    if (c === 63) {\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    }\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\r\n  if (c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else {\r\n    // TODO: Add: not a URL code point\r\n    if (!isNaN(c) && c !== 37) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (c === 37 &&\r\n        (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n         !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (!isNaN(c)) {\r\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\r\n  if (isNaN(c) || (!this.stateOverride && c === 35)) {\r\n    if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\r\n      this.encodingOverride = \"utf-8\";\r\n    }\r\n\r\n    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||\r\n          buffer[i] === 0x3C || buffer[i] === 0x3E) {\r\n        this.url.query += percentEncode(buffer[i]);\r\n      } else {\r\n        this.url.query += String.fromCodePoint(buffer[i]);\r\n      }\r\n    }\r\n\r\n    this.buffer = \"\";\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\r\n  if (isNaN(c)) { // do nothing\r\n  } else if (c === 0x0) {\r\n    this.parseError = true;\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction serializeURL(url, excludeFragment) {\r\n  let output = url.scheme + \":\";\r\n  if (url.host !== null) {\r\n    output += \"//\";\r\n\r\n    if (url.username !== \"\" || url.password !== \"\") {\r\n      output += url.username;\r\n      if (url.password !== \"\") {\r\n        output += \":\" + url.password;\r\n      }\r\n      output += \"@\";\r\n    }\r\n\r\n    output += serializeHost(url.host);\r\n\r\n    if (url.port !== null) {\r\n      output += \":\" + url.port;\r\n    }\r\n  } else if (url.host === null && url.scheme === \"file\") {\r\n    output += \"//\";\r\n  }\r\n\r\n  if (url.cannotBeABaseURL) {\r\n    output += url.path[0];\r\n  } else {\r\n    for (const string of url.path) {\r\n      output += \"/\" + string;\r\n    }\r\n  }\r\n\r\n  if (url.query !== null) {\r\n    output += \"?\" + url.query;\r\n  }\r\n\r\n  if (!excludeFragment && url.fragment !== null) {\r\n    output += \"#\" + url.fragment;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction serializeOrigin(tuple) {\r\n  let result = tuple.scheme + \"://\";\r\n  result += serializeHost(tuple.host);\r\n\r\n  if (tuple.port !== null) {\r\n    result += \":\" + tuple.port;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.serializeURL = serializeURL;\r\n\r\nmodule.exports.serializeURLOrigin = function (url) {\r\n  // https://url.spec.whatwg.org/#concept-url-origin\r\n  switch (url.scheme) {\r\n    case \"blob\":\r\n      try {\r\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\r\n      } catch (e) {\r\n        // serializing an opaque origin returns \"null\"\r\n        return \"null\";\r\n      }\r\n    case \"ftp\":\r\n    case \"gopher\":\r\n    case \"http\":\r\n    case \"https\":\r\n    case \"ws\":\r\n    case \"wss\":\r\n      return serializeOrigin({\r\n        scheme: url.scheme,\r\n        host: url.host,\r\n        port: url.port\r\n      });\r\n    case \"file\":\r\n      // spec says \"exercise to the reader\", chrome says \"file://\"\r\n      return \"file://\";\r\n    default:\r\n      // serializing an opaque origin returns \"null\"\r\n      return \"null\";\r\n  }\r\n};\r\n\r\nmodule.exports.basicURLParse = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\r\n  if (usm.failure) {\r\n    return \"failure\";\r\n  }\r\n\r\n  return usm.url;\r\n};\r\n\r\nmodule.exports.setTheUsername = function (url, username) {\r\n  url.username = \"\";\r\n  const decoded = punycode.ucs2.decode(username);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.setThePassword = function (url, password) {\r\n  url.password = \"\";\r\n  const decoded = punycode.ucs2.decode(password);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.serializeHost = serializeHost;\r\n\r\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\r\n\r\nmodule.exports.serializeInteger = function (integer) {\r\n  return String(integer);\r\n};\r\n\r\nmodule.exports.parseURL = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  // We don't handle blobs, so this just delegates:\r\n  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });\r\n};\r\n","\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\n\nmodule.exports.wrapperForImpl = function (impl) {\n  return impl[module.exports.wrapperSymbol];\n};\n\nmodule.exports.implForWrapper = function (wrapper) {\n  return wrapper[module.exports.implSymbol];\n};\n\n","\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\n\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n\n    return function(V, opts) {\n        if (!opts) opts = {};\n\n        let x = +V;\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n\n            return x;\n        }\n\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n              x += moduloVal;\n            } else if (x === -0) { // don't return negative zero\n              return 0;\n            }\n        }\n\n        return x;\n    }\n}\n\nconversions[\"void\"] = function () {\n    return undefined;\n};\n\nconversions[\"boolean\"] = function (val) {\n    return !!val;\n};\n\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\n\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\n\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\n\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\n\nconversions[\"double\"] = function (V) {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n\n    return x;\n};\n\nconversions[\"unrestricted double\"] = function (V) {\n    const x = +V;\n\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n\n    return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\n\nconversions[\"DOMString\"] = function (V, opts) {\n    if (!opts) opts = {};\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    return String(V);\n};\n\nconversions[\"ByteString\"] = function (V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n\n    return x;\n};\n\nconversions[\"USVString\"] = function (V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n\n    return U.join('');\n};\n\nconversions[\"Date\"] = function (V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n\n    return V;\n};\n\nconversions[\"RegExp\"] = function (V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n\n    return V;\n};\n","module.exports = require(\"cookie\");","module.exports = require(\"cookie-signature\");","module.exports = require(\"debug\");","module.exports = require(\"events\");","module.exports = require(\"express\");","module.exports = require(\"http-errors\");","module.exports = require(\"jsonwebtoken\");","module.exports = require(\"on-finished\");","module.exports = require(\"on-headers\");","module.exports = require(\"punycode\");","module.exports = require(\"safe-buffer\");","module.exports = require(\"vary\");","module.exports = require(\"assert\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport whatwgUrl from 'whatwg-url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n\tconst orig = new URL$1(original).protocol;\n\tconst dest = new URL$1(destination).protocol;\n\n\treturn orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\tdestroyStream(request.body, error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(req, function (err) {\n\t\t\tif (signal && signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (parseInt(process.version.substring(1)) < 14) {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\treq.on('socket', function (s) {\n\t\t\t\ts.addListener('close', function (hadError) {\n\t\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\t\tconst hasDataListener = s.listenerCount('data') > 0;\n\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n\t\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.on('end', function () {\n\t\t\t\t\t// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tlet socket;\n\n\trequest.on('socket', function (s) {\n\t\tsocket = s;\n\t});\n\n\trequest.on('response', function (response) {\n\t\tconst headers = response.headers;\n\n\t\tif (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n\t\t\tresponse.once('close', function (hadError) {\n\t\t\t\t// tests for socket presence, as in some situations the\n\t\t\t\t// the 'socket' event is not triggered for the request\n\t\t\t\t// (happens in deno), avoids `TypeError`\n\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\tconst hasDataListener = socket && socket.listenerCount('data') > 0;\n\n\t\t\t\tif (hasDataListener && !hadError) {\n\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\terrorCallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction destroyStream(stream, err) {\n\tif (stream.destroy) {\n\t\tstream.destroy(err);\n\t} else {\n\t\t// node < 8\n\t\tstream.emit('error', err);\n\t\tstream.end();\n\t}\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError, AbortError };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/*\n * Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license in root of repo. -->\n *\n * This file is the main Node.js server file that defines the express middleware.\n */\n\nif (process.env.NODE_ENV !== \"production\") {\n  require(\"dotenv\").config();\n}\nimport * as cookieParser from \"cookie-parser\";\nimport cors from 'cors';\nimport express from \"express\";\nimport * as createError from \"http-errors\";\nimport * as logger from \"morgan\";\nimport * as path from \"path\";\nimport { addAttachmentToEmail, createUploadSession, deleteDraftAttachment, getMessageAttachmentByDraftID, getMessageAttachmentByID, getMessageByID, getMessages, getNewestDraftMessage, getUserData, requestUploadLargeAttachment, sendMessagesHasId } from \"./msgraph-helper\";\nimport { validateJwt } from \"./ssoauth-helper\";\n\n/* global console, process, require, __dirname */\n\nconst app = express();\nconst port: number | string = process.env.API_PORT || \"3001\";\n\napp.set(\"port\", port);\n\n// view engine setup\napp.set(\"views\", path.join(__dirname, \"views\"));\napp.set(\"view engine\", \"pug\");\n\napp.use(logger(\"dev\"));\napp.use(express.json({\n  limit: '50mb'\n}));\napp.use(express.urlencoded({\n   extended: true,\n   limit: '50mb',\n   parameterLimit: 50000,\n  }));\napp.use(cookieParser());\n\napp.use(logger(\"dev\"));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cookieParser());\n\napp.use(cors({origin: `*`}));\napp.options('https://localhost:3000', cors());\n\napp.use(express.static('public'));\n\n/* Turn off caching when developing */\nif (process.env.NODE_ENV !== \"production\") {\n  app.use(express.static(path.join(process.cwd(), \"dist\"), { etag: false }));\n\n  app.use(function (req, res, next) {\n    res.header(\"Cache-Control\", \"private, no-cache, no-store, must-revalidate\");\n    res.header(\"Expires\", \"-1\");\n    res.header(\"Pragma\", \"no-cache\");\n    res.setHeader('Access-Control-Allow-Origin', 'https://localhost:3000');\n    // Request methods you wish to allow\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');\n    // Request headers you wish to allow\n    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type');\n    // Set to true if you need the website to include cookies in the requests sent\n    // to the API (e.g. in case you use sessions)\n    res.setHeader('Access-Control-Allow-Credentials', \"true\");\n    // Pass to next layer of middleware\n    next();\n  });\n} else {\n  // In production mode, let static files be cached.\n  app.use(express.static(path.join(process.cwd(), \"dist\")));\n}\n\nconst indexRouter = express.Router();\nindexRouter.get(\"/\", function (req, res) {\n  res.render(\"/decrypt.html\");\n});\n\napp.use(\"/\", indexRouter);\n\n// Middle-tier API calls\n// listen for 'ping' to verify service is running\n// Un comment for development debugging, but un needed for production deployment\n// app.get(\"/ping\", function (req: any, res: any) {\n//   res.send(process.platform);\n// });\n\napp.get(\"/getuserdata\", validateJwt, getUserData);\napp.get(\"/messages\", validateJwt, getMessages);\n\n// Get messsage by messsage ID\napp.get(\"/messageById\", validateJwt, getMessageByID);\napp.get(\"/messageAttachmentById\", validateJwt, getMessageAttachmentByID);\n\napp.get(\"/getNewestDraftMessage\", validateJwt, getNewestDraftMessage);\napp.get(\"/messageAttachmentByDraftId\", validateJwt, getMessageAttachmentByDraftID);\n\napp.delete(\"/deleteDraftAttachment\", validateJwt, deleteDraftAttachment);\n\napp.post(\"/sendMessage\", validateJwt, sendMessagesHasId);\napp.post(\"/addAttachment\", validateJwt, addAttachmentToEmail)\napp.post(\"/createUploadSession\",validateJwt, createUploadSession)\napp.put(\"/requestUploadLargeAttachment\", validateJwt, requestUploadLargeAttachment)\n\n// Get the client side task pane files requested\napp.get(\"/decrypt.html\", async (req: any, res: any) => {\n  return res.sendfile(\"decrypt.html\");\n});\n\napp.get(\"/encrypt.html\", async (req: any, res: any) => {\n  return res.sendfile(\"encrypt.html\");\n});\n\napp.get(\"/popupDecrypted.html\", async (req: any, res: any) => {\n  return res.sendfile(\"popupDecrypted.html\");\n});\n\napp.get(\"/accounts.html\", async (req: any, res: any) => {\n  return res.sendfile(\"accounts.html\");\n});\n\napp.get(\"/fallbackauthdialog.html\", async (req: any, res: any) => {\n  return res.sendfile(\"fallbackauthdialog.html\");\n});\n\n// Catch 404 and forward to error handler\napp.use(function (req: any, res: any, next: any) {\n  next(createError(404));\n});\n\n// error handler\napp.use(function (err: any, req: any, res: any) {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get(\"env\") === \"development\" ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render(\"error\");\n});\n\n// getHttpsServerOptions().then((options) => {\n//   https\n//     .createServer(options, app)\n//     .listen(port, () => console.log(`Server running on ${port} in ${process.env.NODE_ENV} mode`));\n// });\n\napp.listen(port, () => console.log(`Server running on ${port} in ${process.env.NODE_ENV} mode`))"],"names":["createError","https","getAccessToken","getAccessTokenSendMail","domain","version","addAttachmentToEmail","req","res","next","messageId","body","attachmentData","fileName","dataAttachment","postData","JSON","stringify","createUploadSession","fileSize","getUserData","getData","getMessageByID","emailId","query","getMessageAttachmentByID","getMessages","getNewestDraftMessage","getMessageAttachmentByDraftID","deleteDraftAttachment","attachmentID","deleteData","sendMessages","emailData","sendMessagesHasId","requestUploadLargeAttachment","uploadUrl","putData","url","queryParams","authorization","get","then","graphTokenResponse","claims","error","send","graphToken","access_token","graphUrlSegment","graphQueryParamSegment","graphData","getGraphData","code","catch","err","status","message","accessToken","apiUrl","Promise","resolve","reject","options","host","path","method","headers","Accept","Authorization","Expires","Pragma","response","on","d","statusCode","parsedBody","parse","Error","statusMessage","trim","bodyCode","bodyMessage","data_json","postGraphData","Buffer","byteLength","mess","request","write","end","deleteGraphData","putGraphData","URL","token","searchParams","from","to","size","hostname","pathname","search","attachment","fetch","form","jwt","JwksClient","DISCOVERY_KEYS_ENDPOINT","scopeName","assertion","split","tokenScopes","decode","scp","accessAsUserScope","find","scope","formParams","client_id","process","env","CLIENT_ID","client_secret","CLIENT_SECRET","grant_type","requested_token_use","join","stsDomain","tenant","tokenURLSegment","encodedForm","tokenResponse","json","validateJwt","authHeader","validationOptions","audience","verify","getSigningKeys","console","log","sendStatus","header","callback","client","jwksUri","getSigningKey","kid","key","getPublicKey","NODE_ENV","require","config","cookieParser","cors","express","logger","app","port","API_PORT","set","__dirname","use","limit","urlencoded","extended","parameterLimit","origin","static","cwd","etag","setHeader","indexRouter","Router","render","delete","post","put","sendfile","locals","listen"],"sourceRoot":""}